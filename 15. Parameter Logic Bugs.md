# MỤC LỤC
# 1. **Giới thiệu về Lỗi Logic**
- [Giới Thiệu về Lỗi Logic](#1-giới-thiệu-về-lỗi-logic)

# 2. **Các Loại Lỗi Logic**
- [Các Loại Lỗi Logic](#2-các-loại-lỗi-logic)

# 3. **Phương Pháp Kiểm Tra Lỗi Logic**
- [Phương Pháp kiểm tra](#3-phương-pháp-kiểm-tra)

# 4. **Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity)**
- [Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity)](#4-lỗi-mâu-thuẫn-logic-xác-thực-validation-logic-disparity)
- [Kiểm Tra Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity) trong Kiểm Thử Cục Bộ](#6-kiểm-tra-lỗi-mâu-thuẫn-logic-xác-thực-validation-logic-disparity-trong-kiểm-thử-cục-bộ)
- [PoC (Proof of Concept) và Patching - Khắc Phục Lỗi Mâu Thuẫn Logic Xác Thực](#7-poc-proof-of-concept-và-patching-khắc-phục-lỗi-mâu-thuẫn-logic-xác-thực)

# 5. **Lỗi Đầu Vào Không Mong Đợi**
- [Lỗi Đầu Vào Không Mong Đợi](#8-lỗi-đầu-vào-không-mong-đợi)
- [Code Review - Lỗi Đầu Vào Không Mong Đợi](#9-code-review-lỗi-đầu-vào-không-mong-đợi)
- [Kiểm Tra Lỗi Đầu Vào Không Mong Đợi trong `processPayment()`](#10-kiểm-tra-lỗi-đầu-vào-không-mong-đợi-trong-processpayment)
- [Local Testing (Manipulation) - Kiểm tra đầu vào bất ngờ](#11-local-testing-manipulation-kiểm-tra-đầu-vào-bất-ngờ)
- [PoC và Patching - Đầu vào bất ngờ](#12-poc-và-patching-đầu-vào-bất-ngờ)

# 6. **Null Safety và Kiểm Tra Null Safety**
- [Null Safety (An toàn Null)](#13-null-safety-an-toàn-null)
- [Code Review (Biến Null) - An toàn Null trong JavaScript](#14-code-review-biến-null-an-toàn-null-trong-javascript)
- [Kiểm Tra Null Safety trong `UserSchema` và `PasswordResetSchema`](#15-kiểm-tra-null-safety-trong-userschema-và-passwordresetschema)
- [Kiểm Tra Null Safety trong Các Hàm và Tấn Công Null Safety](#16-kiểm-tra-null-safety-trong-các-hàm-và-tấn-công-null-safety)
- [PoC và Patching - Null Safety](#17-poc-và-patching-null-safety)

# 7. **Tránh Lỗi Logic Tham Số**
- [Tránh Lỗi Logic Tham Số](#18-tránh-lỗi-logic-tham-số)

---
# 1. Giới Thiệu về Lỗi Logic

- Trong kiểm tra ứng dụng web, chúng ta thường tuân theo các quy tắc và kỹ thuật để xác định các lỗ hổng hoặc lỗi. Tuy nhiên, có những lỗi thuộc nhóm *lỗi logic* (logic bugs), mà việc nhận diện chúng có thể rất khó khăn, vì chúng chủ yếu do sai sót trong logic của chương trình. Dù chúng khá phức tạp, nhưng nếu hiểu rõ về các lỗi logic, chúng ta có thể xây dựng các hướng dẫn để xác định và xử lý chúng. Bên cạnh đó, tuân thủ phương pháp lập trình an toàn trong quá trình phát triển ứng dụng web cũng giúp giảm thiểu hoặc loại bỏ được các lỗi logic, từ đó tạo ra các ứng dụng vững chắc và không có lỗi logic.



### **Lỗi Logic là gì?**

- Lỗi logic là những sai sót vô tình trong cách ứng dụng xử lý dữ liệu đầu vào hoặc các tương tác của người dùng. Không giống như các lỗi thông thường có thể khiến ứng dụng bị treo hoặc các lỗ hổng bảo mật gây ra việc thực thi mã độc, lỗi logic thay đổi cách ứng dụng hoạt động trong những điều kiện bình thường.

- Ví dụ, một ứng dụng có các tính năng trả phí. Một lỗi logic trong mã của ứng dụng có thể cho phép người dùng truy cập vào các tính năng này mà không cần thanh toán. Lỗi logic trong luồng xử lý của ứng dụng thường có thể bị khai thác qua cách sử dụng bình thường của người dùng (chẳng hạn như chỉ qua giao diện người dùng), trong khi các lỗi logic liên quan đến tham số thường cần các công cụ chuyên dụng để khai thác.

- Những sai sót này không gây ra lỗ hổng bảo mật trực tiếp và không phải là những lỗi rõ ràng khiến ứng dụng gặp sự cố hoặc hỏng hóc, nhưng lại tạo ra hành vi không mong muốn mà kẻ tấn công có thể tận dụng. Những lỗi này có thể ẩn giấu trong quá trình sử dụng bình thường của ứng dụng mà không gây ra vấn đề rõ ràng. Ứng dụng có thể hoạt động hoàn hảo và chỉ lộ ra lỗi logic khi các điều kiện mà nhà phát triển không nghĩ đến trong thiết kế ban đầu xảy ra. Chính sự tinh vi này khiến lỗi logic trở nên rất khó phát hiện.

- Mặc dù các công cụ tự động có thể giúp ích trong một số tình huống, việc nhận diện lỗi logic là một thử thách đặc biệt, vì chúng thường không thể hiểu và phân tích đầy đủ sự phức tạp trong mã của ứng dụng. Tuy nhiên, với những tiến bộ gần đây trong trí tuệ nhân tạo (AI), có thể tình hình sẽ thay đổi trong tương lai.

- Phương pháp đáng tin cậy nhất để phát hiện lỗi logic vẫn dựa vào chuyên môn và tư duy logic của con người. Những kỹ năng này, kết hợp với các hướng dẫn và thực hành mà chúng ta sẽ khám phá trong module này (bao gồm việc xem xét mã nguồn và kiểm tra tĩnh), là rất quan trọng trong việc nhận diện và xử lý lỗi logic hiệu quả.

---

### **Ví Dụ Cơ Bản về Lỗi Logic**

- Đây là một ví dụ đơn giản về lỗi logic, mặc dù có phần hài hước. Lỗi này có thể xảy ra do một dòng mã được viết mà không hiểu rõ tác động của nó, dẫn đến việc gây ra lỗi logic. Các nhà phát triển có thể đã sử dụng từ khóa `unique()` cho tham số trong cơ sở dữ liệu mật khẩu, yêu cầu rằng mật khẩu của người dùng phải là duy nhất. Từ khóa này thường được sử dụng cho các tham số như email và tên người dùng, vì những tham số này cần phải duy nhất. Tuy nhiên, trong trường hợp này, việc áp dụng từ khóa này vào mật khẩu đã gây ra lỗi logic.

- Ngoài ra, ứng dụng có thể đã được cấu hình để ghi log chi tiết, vì vậy thay vì hiển thị một thông báo lỗi chung chung (chẳng hạn như "Mật khẩu không duy nhất"), ứng dụng lại hiển thị lỗi cơ sở dữ liệu trực tiếp cho người dùng, làm lộ mật khẩu của người dùng khác. Ví dụ đơn giản này cho thấy bản chất của lỗi logic, cách mà nó xảy ra từ những sai sót nhỏ và cách nó có thể gây ảnh hưởng lớn khi xuất hiện trong các chức năng nhạy cảm như tiết lộ mật khẩu của người dùng khác.

---

### **Ví Dụ Thực Tế (iPhone chưa phát hành)**

- Một trong những ví dụ đầu tiên về lỗi logic mà tôi gặp phải là trong một cửa hàng trực tuyến bán điện tử (giả sử là Amazon, Walmart hoặc Target). iPhone 4 sẽ được phát hành vào ngày hôm sau tại khu vực của tôi (vào thời điểm đó, việc phát hành sản phẩm được thực hiện theo từng khu vực). Trang sản phẩm chỉ hiển thị "coming soon" thay vì nút "thêm vào giỏ hàng".

- Tôi bắt đầu thử nghiệm ứng dụng web và tự hỏi liệu tôi có thể mua được sản phẩm này nếu tôi có thể thêm sản phẩm "chưa phát hành" vào giỏ hàng hay không. Việc thêm iPhone chưa phát hành vào giỏ hàng rất đơn giản: Tôi chỉ cần thay đổi `productId` trong yêu cầu GET khi thêm bất kỳ mặt hàng nào khác, thay thế nó bằng ID sản phẩm của iPhone chưa phát hành.

- Sau khi thêm vào giỏ hàng, thay vì hiển thị "coming soon", giỏ hàng lại hiển thị số lượng sẵn có của từng loại iPhone. Tôi chọn cấu hình iPhone tôi muốn và chọn "lấy tại cửa hàng" vì các tùy chọn "giao hàng" có vẻ không chính xác, có thể do ứng dụng không xử lý được "sản phẩm chưa phát hành".

- Khi nhấn nút thanh toán, tôi tưởng rằng máy chủ sẽ xử lý lỗi và thông báo rằng sản phẩm này "hết hàng" hoặc "không có sẵn". Tuy nhiên, tôi rất ngạc nhiên khi được chuyển đến trang thanh toán và hoàn tất giao dịch. Tôi vẫn nghĩ rằng đơn hàng sẽ bị hủy tự động, nhưng vào ngày hôm sau, khi iPhone được phát hành, tôi nhận được thông báo hẹn lấy sản phẩm và xác nhận đơn hàng. Như vậy, lỗi này đã giúp tôi mua iPhone 4 trước ngày phát hành.


---
# 2. Các Loại Lỗi Logic

#### 1. **Lỗi do Thiết kế Logic Yếu**
Nguyên nhân chính của lỗi logic là thiết kế logic ứng dụng yếu, dẫn đến các hành động không mong đợi hoặc sai sót trong ứng dụng.  
**Ví dụ**: Một ứng dụng mua sắm cho phép người dùng áp dụng mã giảm giá sau khi đã thanh toán xong, điều này có thể dẫn đến việc người dùng lạm dụng mã giảm giá hoặc áp dụng mã sai thời điểm.

#### 2. **Lỗi Thao tác Tham số (Parameter Manipulation)**
Lỗi này xảy ra khi ứng dụng không xử lý đúng các tham số mà người dùng gửi.  
**Ví dụ**:
```php
// Code yếu:
$price = $_POST['price'];
$quantity = $_POST['quantity'];
$total = $price * $quantity;

// Người dùng có thể gửi giá trị âm cho quantity để được hoàn tiền
```
Trong ví dụ này, người dùng có thể gửi số lượng sản phẩm âm để gian lận và nhận lại tiền.

#### 3. **Lỗi Logic Xác thực không Đồng nhất**
Lỗi này xảy ra khi xác thực giữa frontend và backend không nhất quán, dẫn đến việc bỏ qua các kiểm tra quan trọng.  
**Ví dụ**:
```javascript
// Frontend validation
if(age >= 18) {
  // cho phép truy cập
}

// Backend không có validation
// => Người dùng có thể bỏ qua validation frontend
```
Nếu không có xác thực ở backend, người dùng có thể bỏ qua việc kiểm tra độ tuổi trên frontend và vẫn có thể truy cập ứng dụng.

#### 4. **Lỗi Đầu vào Không mong đợi**
Lỗi này xảy ra khi ứng dụng không xử lý được các loại đầu vào đặc biệt hoặc không mong đợi từ người dùng.  
**Ví dụ**:
```python
def process_number(num):
    result = 100 / num
    # Không xử lý trường hợp num = 0
```
Ở đây, nếu người dùng nhập `num = 0`, ứng dụng sẽ gặp lỗi chia cho số 0 mà không xử lý được trường hợp này.

#### 5. **Lỗi Xử lý Null**
Lỗi này xảy ra khi các tham số `null` không được xử lý đúng cách.  
**Ví dụ**:
```java
String name = request.getParameter("name");
if(name.length() > 10) { // NullPointerException nếu name là null
  // xử lý
}
```
Nếu biến `name` là `null`, việc gọi `name.length()` sẽ gây ra lỗi `NullPointerException`.

#### 6. **Lỗi Bỏ qua Quy trình (Flow Bypass)**
Lỗi này phá vỡ luồng logic của ứng dụng, ví dụ như bỏ qua các bước quan trọng trong quy trình.  
**Ví dụ**: Người dùng có thể bỏ qua bước xác nhận email trong quy trình đăng ký, gây ra việc tài khoản không được xác thực đúng cách.

#### 7. **Lỗi Lặp lại Hành động Một lần**
Lỗi này xảy ra khi một hành động, vốn chỉ được phép thực hiện một lần, lại bị thực hiện nhiều lần.  
**Ví dụ**: Người dùng có thể sử dụng lại mã giảm giá mà chỉ được phép sử dụng một lần, do lỗi trong việc kiểm tra trạng thái mã giảm giá.

#### 8. **Lỗi Thực hiện Bước Không đúng Thứ tự**
Lỗi này phá vỡ quy trình nhiều bước của ứng dụng.  
**Ví dụ**: Người dùng có thể thanh toán trước khi thêm sản phẩm vào giỏ hàng, gây ra lỗi trong quy trình mua sắm.

#### 9. **Lỗi Hành vi Không mong đợi**
Lỗi này xảy ra khi người dùng thực hiện các hành động không được ứng dụng thiết kế để xử lý.  
**Ví dụ**: Người dùng đồng thời mua cùng một sản phẩm có số lượng giới hạn, dẫn đến việc giảm số lượng sản phẩm sai hoặc hết hàng mà không thông báo cho người dùng.

---
# 3. Phương Pháp kiểm tra

Trong phần này, chúng ta sẽ thảo luận về phương pháp luận mà chúng ta sẽ sử dụng trong suốt module này để nhận diện và nghiên cứu các loại lỗi logic mà chúng ta vừa định nghĩa, cũng như kịch bản mà chúng ta sẽ theo dõi để giải thích về chúng.

#### Phương Pháp Luận

Phương pháp luận mà chúng ta sẽ áp dụng trong module này khá giống với quy trình trong module **Whitebox Pentesting** (Kiểm thử thâm nhập kiểu hộp trắng), được chia thành 4 bước chính:

1. **Code Review (Xem xét mã nguồn)**  
2. **Local Testing (Kiểm thử cục bộ)**  
3. **Proof of Concept (Chứng minh khái niệm)**  
4. **Patching & Remediation (Cập nhật và khắc phục)**

Chúng ta sẽ bắt đầu mỗi loại lỗi logic bằng cách giải thích chi tiết về nó và cung cấp ví dụ thực tế về cách lỗi này có thể xuất hiện. Sau đó, chúng ta sẽ theo phương pháp luận trên, cụ thể như sau:

| **Bước** | **Mô Tả** |
|---|---|
| **1. Code Review** | Bắt đầu bằng cách duyệt qua mã nguồn của ứng dụng và hiểu thiết kế ứng dụng để nhận diện các chức năng có thể bị lỗi. Chúng ta sẽ sử dụng cả phân tích tĩnh và động, kết hợp với việc sử dụng ứng dụng để hiểu rõ hơn về logic ứng dụng. |
| **2. Local Testing** | Với danh sách các chức năng cần chú ý, chúng ta sẽ bắt đầu kiểm thử chúng để tìm lỗi logic. Chúng ta sẽ học cách nhận diện từng loại lỗi qua từng phần của module này. |
| **3. Proof of Concept** | Đây là một bài tập lập trình bảo mật, không phải kiểm thử thâm nhập kiểu hộp trắng. Thay vì viết mã khai thác (exploits), chúng ta sẽ tập trung vào việc khai thác các chức năng dễ bị tổn thương dựa trên hiểu biết từ các bước trước, như một cách chứng minh khái niệm. Sau đó, chúng ta có thể xác nhận lỗi trên mục tiêu thực tế, nhưng phải làm điều này một cách an toàn để không gây ra sự cố hoặc mất mát dữ liệu. |
| **4. Patching & Remediation** | Cuối cùng, sau khi khai thác các lỗi logic, chúng ta sẽ thảo luận về cách khắc phục và vá lỗi cho những lỗi này, cũng như kiểm thử lại các cuộc tấn công để đảm bảo chúng đã được khắc phục hoàn toàn. |

---
# 4. Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity)

Lỗi **Mâu Thuẫn Logic Xác Thực** xảy ra khi frontend và backend không áp dụng cùng một bộ lọc xác thực đầu vào, dẫn đến sự không nhất quán giữa hai bên. Điều này có thể tạo ra các lỗi logic trong ứng dụng, đặc biệt khi một bên bỏ qua hoặc không kiểm tra lại các xác thực đã thực hiện ở bên kia.

#### 1. **Logic của Client-Side và Server-Side**

Trong hầu hết các ứng dụng web hiện đại, xác thực đầu vào là một bước quan trọng để đảm bảo người dùng nhập dữ liệu đúng định dạng và tránh các nguy cơ bảo mật. Các bộ lọc này cần được áp dụng ở cả frontend (client-side) và backend (server-side). 

- **Frontend**: Xác thực đầu vào chủ yếu để cải thiện trải nghiệm người dùng, giảm thiểu các yêu cầu không hợp lệ gửi đến server.
- **Backend**: Xác thực để ngăn chặn các yêu cầu độc hại và bảo vệ dữ liệu, đặc biệt là khi có các cuộc tấn công trực tiếp vào backend.

Tuy nhiên, **chỉ dựa vào xác thực frontend** là không đủ, vì người dùng có thể bỏ qua các kiểm tra này thông qua các công cụ như DevTools hoặc gửi yêu cầu thủ công đến backend. Vấn đề sẽ xảy ra nếu **frontend và backend không thực hiện xác thực giống nhau**.

#### 2. **Ví dụ về Lỗi Mâu Thuẫn Logic Xác Thực**

Giả sử trong một ứng dụng mua sắm, frontend hiển thị nút "Thêm vào giỏ hàng" nếu sản phẩm còn trong kho và "Hết hàng" nếu sản phẩm đã hết. Tuy nhiên, backend lại không kiểm tra lại tình trạng kho khi nhận yêu cầu từ frontend, dẫn đến việc người dùng có thể đặt hàng sản phẩm hết hàng nếu họ gửi yêu cầu thủ công tới backend.

**Frontend (JavaScript):**
```javascript
// Kiểm tra tình trạng kho trước khi hiển thị nút
function checkStock(productId) {
  const availableStock = getStockFromBackend(productId); // Lấy thông tin kho từ backend
  if (availableStock > 0) {
    document.getElementById("add-to-cart").style.display = "block"; // Hiển thị nút "Thêm vào giỏ hàng"
  } else {
    document.getElementById("out-of-stock").style.display = "block"; // Hiển thị thông báo "Hết hàng"
  }
}

// Giả sử `getStockFromBackend()` là một hàm gọi backend để lấy số lượng tồn kho
```

**Backend (Node.js/Express):**
```javascript
// Xử lý yêu cầu thêm sản phẩm vào giỏ hàng
app.post("/add-to-cart", (req, res) => {
  const productId = req.body.productId;
  const userId = req.body.userId;

  // Backend không kiểm tra lại tình trạng kho
  // Chỉ giả định frontend đã xác thực đúng
  addToCart(userId, productId);
  res.status(200).send("Product added to cart");
});
```

Ở đây, backend **tin tưởng vào xác thực của frontend**, mà không kiểm tra lại xem sản phẩm có còn trong kho hay không. Nếu người dùng gửi yêu cầu thủ công (bỏ qua frontend), backend sẽ cho phép họ thêm sản phẩm hết hàng vào giỏ mà không kiểm tra lại tình trạng kho.

#### 3. **Các loại Lỗi Mâu Thuẫn Logic Xác Thực**

Các lỗi **Mâu Thuẫn Logic Xác Thực** xảy ra khi:

- **Frontend thiếu bộ lọc xác thực** mà backend đã áp dụng: Điều này có thể dẫn đến lỗi trong trải nghiệm người dùng, chẳng hạn như thông báo "hết hàng" khi sản phẩm vẫn còn.
- **Backend thiếu bộ lọc xác thực hoặc không kiểm tra lại những bộ lọc từ frontend**: Điều này có thể dẫn đến lỗi logic mà chúng ta có thể khai thác.

#### 4. **Cách Xác định Lỗi Mâu Thuẫn Logic Xác Thực**

Để phát hiện lỗi **Mâu Thuẫn Logic Xác Thực**, chúng ta cần kiểm tra các chức năng có các đặc điểm sau:

1. **Chấp nhận đầu vào từ người dùng**.
2. **Áp dụng xác thực phía client (frontend) đối với đầu vào này**.
3. **Dựa vào dữ liệu từ backend để điều chỉnh cách thức hoạt động của kiểm tra xác thực**.

Ví dụ về kiểm thử xác thực động:
- **Frontend** có thể thực hiện xác thực dựa trên tình trạng kho, nhưng **Backend** lại không kiểm tra lại điều này khi nhận yêu cầu.
- Điều này có thể dẫn đến các lỗi, chẳng hạn như **cho phép người dùng đặt hàng sản phẩm hết hàng** nếu chỉ dựa vào xác thực frontend.

**Ví dụ về kiểm tra xác thực động:**

**Frontend (JavaScript):**
```javascript
// Lấy thông tin sản phẩm từ backend
function getStockFromBackend(productId) {
  // Gửi yêu cầu tới backend để lấy số lượng tồn kho
  fetch(`/api/product/${productId}/stock`)
    .then(response => response.json())
    .then(data => {
      if (data.stock > 0) {
        document.getElementById("add-to-cart").style.display = "block";
      } else {
        document.getElementById("out-of-stock").style.display = "block";
      }
    });
}
```

**Backend (Node.js/Express):**
```javascript
// Kiểm tra lại tình trạng kho ở backend khi nhận yêu cầu
app.post("/add-to-cart", (req, res) => {
  const productId = req.body.productId;

  // Lấy số lượng tồn kho từ database
  const availableStock = getStockFromDatabase(productId);
  if (availableStock <= 0) {
    return res.status(400).send("Product is out of stock");
  }

  // Thêm sản phẩm vào giỏ hàng
  addToCart(req.body.userId, productId);
  res.status(200).send("Product added to cart");
});
```

Ở ví dụ trên, **Backend đã kiểm tra lại tình trạng kho** sau khi nhận yêu cầu từ frontend. Nếu sản phẩm không còn, backend sẽ từ chối yêu cầu thêm sản phẩm vào giỏ.

---
# 5. Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity)

Trong phần trước, chúng ta đã thảo luận về cách dễ dàng nhận diện lỗi **mâu thuẫn logic xác thực** (validation logic disparity) thông qua việc so sánh các bộ lọc xác thực ở cả frontend và backend. Trong phần này, chúng ta sẽ đi sâu vào cách phân tích mã nguồn và kiểm tra các hàm xác thực động, đặc biệt là những trường hợp liên quan đến việc lấy dữ liệu từ backend và áp dụng xác thực tương ứng.

#### 1. **Xác Thực Động**

Một trong những cách để nhận diện lỗi mâu thuẫn logic xác thực là tìm kiếm các trường hợp **xác thực động**, tức là những bộ lọc xác thực có sự phụ thuộc vào dữ liệu từ backend. Đây là loại xác thực có thể thay đổi theo từng tình huống, ví dụ như việc kiểm tra ngày giờ, tình trạng sản phẩm trong kho, hoặc tình trạng lịch hẹn.

**Ví dụ về xác thực động trong frontend**:
- **Màn hình Đặt Lịch Thi (Exam Booking)**: Khi người dùng chọn ngày thi, các ngày không khả dụng sẽ bị vô hiệu hóa dựa trên dữ liệu được lấy từ backend.

#### 2. **Quy Trình Đặt Lịch Thi và Kiểm Tra Mâu Thuẫn Logic**

Chúng ta sẽ sử dụng **quy trình đặt lịch thi** làm ví dụ để hiểu rõ hơn cách lỗi mâu thuẫn logic xác thực có thể xảy ra.

**Quy trình đặt lịch thi:**
- Khi vào trang **/exams**, người dùng sẽ thấy danh sách các kỳ thi có sẵn.
- Nếu người dùng đã mua kỳ thi, họ có thể chọn một **slot** trong lịch để đặt lịch thi.
- Sau khi chọn ngày, hệ thống sẽ gửi yêu cầu tới backend để xác nhận tính khả dụng của ngày thi.
- Nếu ngày thi có sẵn, người dùng sẽ nhận được thông báo xác nhận.

#### 3. **Phân Tích Lỗi Mâu Thuẫn Logic Xác Thực**

Chúng ta sẽ phân tích các yêu cầu gửi từ frontend tới backend khi người dùng thực hiện hành động đặt lịch thi.

1. **Lấy dữ liệu về tình trạng khả dụng (Availability)**:
    - Khi người dùng chọn một ngày thi, frontend sẽ gửi yêu cầu `POST` tới `/api/exams/availability` với thông tin về ngày bắt đầu và kết thúc.
    - Backend sẽ trả về dữ liệu về các ngày thi không khả dụng.
    
    **Yêu cầu POST tới `/api/exams/availability`**:
    ```json
    {
      "id": 1,
      "startDate": "2023-09-01T15:47:14.843Z",
      "endDate": "2023-10-01T15:47:14.843Z"
    }
    ```

2. **Đặt lịch thi (Booking the Exam)**:
    - Sau khi người dùng chọn một ngày thi khả dụng, frontend sẽ gửi yêu cầu `POST` tới `/api/exams/book` với thông tin về kỳ thi và ngày đã chọn.
    
    **Yêu cầu POST tới `/api/exams/book`**:
    ```json
    {
      "id": 1,
      "date": "2023-09-14T23:00:00.000Z"
    }
    ```

   Sau khi gửi yêu cầu, backend sẽ thực hiện xác nhận lại tính khả dụng của ngày thi và lưu thông tin này vào cơ sở dữ liệu.

#### 4. **Kiểm Tra Mâu Thuẫn Logic Xác Thực**

Để xác minh lỗi mâu thuẫn logic xác thực, chúng ta cần so sánh bộ lọc xác thực ở **frontend** và **backend**.

**Frontend**:
- Dựa trên dữ liệu từ backend (tình trạng các ngày thi), frontend sẽ vô hiệu hóa các ngày không khả dụng.
- Nếu một ngày thi được chọn, frontend không thực hiện xác nhận lại ngày thi mà chỉ gửi yêu cầu cho backend.

**Backend**:
- Backend có thể chỉ xác thực tình trạng khả dụng của ngày thi khi nhận yêu cầu **đặt lịch**. Nếu backend không kiểm tra lại tình trạng khả dụng khi người dùng thực hiện yêu cầu, thì có thể xảy ra lỗi nếu người dùng thay đổi dữ liệu trong frontend hoặc gửi yêu cầu thủ công.

#### 5. **Locating Endpoints**

Để tìm các endpoint liên quan đến việc kiểm tra và đặt lịch thi, chúng ta cần kiểm tra mã nguồn backend.

**Mã nguồn liên quan tới các endpoint**:
```javascript
// Định nghĩa các route API cho các kỳ thi
app.use("/api/exams", examRoutes);

examRoutes.post("/availability", getExamAvailability);
examRoutes.post("/book", bookExam);
```

Chúng ta sẽ kiểm tra các hàm **`getExamAvailability`** và **`bookExam`** để đảm bảo rằng backend áp dụng cùng một bộ lọc xác thực như frontend và không xảy ra mâu thuẫn.

#### 6. **Kiểm Tra Yêu Cầu và Phản Hồi**

Khi kiểm tra yêu cầu và phản hồi từ các API, cần chú ý đến các khác biệt nhỏ, chẳng hạn như múi giờ, để đảm bảo rằng các ngày thi được xử lý chính xác và thống nhất giữa frontend và backend.

- **Xác thực ở frontend**: Kiểm tra các ngày khả dụng và vô hiệu hóa các ngày không khả dụng.
- **Xác thực ở backend**: Kiểm tra lại tính khả dụng của ngày thi khi nhận yêu cầu đặt lịch và xác nhận lại với cơ sở dữ liệu.

---
# 6. Kiểm Tra Lỗi Mâu Thuẫn Logic Xác Thực (Validation Logic Disparity) trong Kiểm Thử Cục Bộ

Trong phần này, chúng ta sẽ nghiên cứu chi tiết các API backend mà chức năng đặt lịch thi tương tác với, nhằm phát hiện bất kỳ sự mâu thuẫn nào giữa logic xác thực ở phía frontend và backend.

#### **1. Kiểm Tra Hàm `getExamAvailability()`**

Đầu tiên, chúng ta sẽ xem xét hàm `getExamAvailability()`. Hàm này nhận thông tin về `startDate`, `id`, và `endDate` từ thân yêu cầu và thực hiện một số kiểm tra để xác thực định dạng ngày. Sau đó, nó tìm kiếm kỳ thi trong cơ sở dữ liệu với `Exam.findOne` dựa trên `id`:

```javascript
const { id, startDate, endDate } = req.body;
// kiểm tra định dạng ngày
if (!startDate || !endDate || isNaN(Date.parse(startDate)) || isNaN(Date.parse(endDate))) {
  return next({
    message: "Please provide a valid date range.",
    statusCode: 400,
  });
}

let exam;
try {
  // xác thực sự tồn tại của kỳ thi
  exam = await Exam.findOne({ id });
  <SNIP>
} catch (error) {
  return next(error);
}
```

Hàm này sẽ tiếp tục tìm kiếm các slot đã được đặt trong khoảng thời gian được cung cấp bằng cách sử dụng mô hình `UserExam`:

```javascript
const bookedExams = await UserExam.find({
  examId: exam.id,
  date: {
    $gte: new Date(startDate).setUTCHours(0, 0, 0, 0),
    $lte: new Date(endDate).setUTCHours(23, 59, 59, 999),
  },
});
```

Cuối cùng, hàm này trả về danh sách các ngày không khả dụng. Nếu không tìm thấy kết quả hoặc có lỗi, nó trả về một mảng trống.

**Kiểm thử**: Để kiểm tra hàm này, chúng ta có thể gửi một yêu cầu POST đến `/api/exams/availability` thông qua **RapidAPI** với dữ liệu yêu cầu.

#### **2. Kiểm Tra Hàm `bookExam()`**

Tiếp theo, chúng ta sẽ kiểm tra hàm `bookExam()`. Hàm này nhận `date` từ yêu cầu, sau đó xác thực định dạng ngày và lấy thông tin kỳ thi để xác nhận sự tồn tại của kỳ thi:

```javascript
const updateReq = await UserExam.findOneAndUpdate(
  {
    examId: exam.id,
    userId,
    used: false,
    date: { $eq: null }, // kiểm tra nếu chưa đặt lịch
  },
  { date: new Date(date) }
);
```

Hàm này sử dụng `exam.id` để xác minh kỳ thi và `userId` từ token JWT để đảm bảo người dùng đã mua kỳ thi và chưa sử dụng nó.

**Kiểm thử**:
- Để xác minh rằng hàm này hoạt động đúng, chúng ta có thể thêm một **breakpoint** sau khi `userId` được gán giá trị từ token JWT, và thay đổi giá trị `userId` trong quá trình kiểm tra. Khi tiếp tục yêu cầu, nếu `userId` không hợp lệ (chưa mua kỳ thi), hệ thống sẽ trả về lỗi.

#### **3. Kiểm Tra Vấn Đề Logic Xác Thực**

Mặc dù hàm `bookExam()` thực hiện xác thực định dạng ngày và kiểm tra sự tồn tại của kỳ thi, nhưng nó **không thực hiện xác thực về tình trạng khả dụng của ngày thi**. Cụ thể, hàm này không kiểm tra xem ngày thi đã được đặt hay chưa, hoặc xem ngày thi có phải là quá khứ hay không.

- **Frontend**: Ứng dụng frontend thực hiện xác thực bằng cách **vô hiệu hóa các ngày thi không khả dụng** và các ngày trong quá khứ. Tuy nhiên, nếu người dùng gửi yêu cầu trực tiếp (chẳng hạn qua công cụ như Postman hay RapidAPI), backend không kiểm tra lại các điều kiện này, dẫn đến **lỗi mâu thuẫn logic xác thực**.

**Ví dụ mâu thuẫn logic**:
- Người dùng có thể **đặt lịch thi vào một ngày đã được đặt trước**, gây ra tình trạng "over-booking".
- Người dùng có thể **đặt lịch thi vào một ngày trong quá khứ**, điều này có thể gây ra lỗi logic khác.

#### **4. Lý Do Tại Sao Lỗi Này Thường Xảy Ra**

Lỗi mâu thuẫn logic xác thực này có thể xảy ra vì nhiều lý do:
- **Khoảng cách giữa frontend và backend developers**: Có thể các developer frontend và backend không giao tiếp hiệu quả về yêu cầu xác thực.
- **Phức tạp trong mã nguồn**: Có thể backend giả định rằng các kiểm tra đã được thực hiện ở frontend và không cần phải kiểm tra lại.
- **Thiếu kiểm tra hợp lý ở backend**: Đôi khi, các nhà phát triển quên hoặc bỏ qua việc thêm các xác thực bổ sung ở backend, dẫn đến các lỗ hổng bảo mật.

#### **5. Giải Pháp**

Để khắc phục lỗi này và đảm bảo tính đồng nhất trong logic xác thực giữa frontend và backend, chúng ta cần:
- **Xác thực đầy đủ ở cả frontend và backend**: Cả hai bên cần phải kiểm tra tính khả dụng của ngày thi trước khi cho phép người dùng đặt lịch.
- **Thực hiện xác thực lại các ngày thi ở backend**: Backend cần phải kiểm tra xem ngày thi đã được đặt hay chưa, và đảm bảo rằng ngày thi không phải là quá khứ.
  
Điều này giúp đảm bảo rằng người dùng không thể thao tác để đặt lịch thi vào những ngày không khả dụng, và giúp hệ thống tránh được các lỗi logic trong quá trình hoạt động.

---
# 7. PoC (Proof of Concept) và Patching - Khắc Phục Lỗi Mâu Thuẫn Logic Xác Thực

Sau khi đã xác nhận lỗi mâu thuẫn trong logic xác thực giữa frontend và backend, chúng ta sẽ thực hiện các bước sau để kiểm tra và khắc phục vấn đề này.

#### **1. Kiểm Tra Lý Thuyết - PoC (Proof of Concept)**

Để kiểm tra lý thuyết về lỗi mâu thuẫn logic xác thực, chúng ta sẽ thực hiện một bài kiểm tra thực tế (PoC). Quá trình này sẽ bao gồm các bước sau:

- **Khôi phục Docker container**: Đầu tiên, chúng ta cần khởi động lại container Docker để đưa hệ thống về trạng thái ban đầu, xóa bất kỳ breakpoint nào đã được thêm vào trong mã nguồn.
  
- **Điền đầy đủ các slot kỳ thi**: Đảm bảo rằng tất cả các slot kỳ thi đã được đặt hết trong cơ sở dữ liệu, giả lập trạng thái thực tế của hệ thống, với không còn slot nào khả dụng.
  
- **Gửi yêu cầu đặt lịch thi**: Gửi một yêu cầu đặt lịch thi, với thay đổi trong trường `date` để chọn một ngày đã hết slot. Ví dụ, chúng ta có thể gửi yêu cầu:

  ```json
  {
    "id": 1,
    "date": "2023-09-14T23:00:00.000Z"
  }
  ```

- **Xác nhận kết quả**: Mặc dù không còn slot nào khả dụng, hệ thống vẫn trả về thông báo xác nhận rằng lịch thi đã được đặt. Điều này chứng tỏ rằng hệ thống không kiểm tra tính khả dụng của slot thi trên backend.

- **Kiểm tra lại trang**: Sau khi yêu cầu được xử lý, chúng ta có thể làm mới trang `/exams` và kiểm tra xem kỳ thi đã được đánh dấu là "BOOKED" hay chưa, dù rằng nó không thực sự khả dụng.

Qua quá trình này, ta có thể xác nhận rằng lỗi **mâu thuẫn logic xác thực** tồn tại, cho phép người dùng đặt lịch thi ngay cả khi tất cả các slot đã được đặt hết.

#### **2. Giải Thích Lỗi và Nguyên Nhân**

Lỗi này xảy ra vì **thiếu kiểm tra tình trạng khả dụng của ngày thi** ở backend. Mặc dù frontend đã thực hiện xác thực (vô hiệu hóa các ngày trong quá khứ và các ngày không khả dụng), nhưng backend lại không thực hiện kiểm tra này, dẫn đến việc người dùng có thể đặt lịch vào các ngày đã được đặt trước hoặc không hợp lệ.

Điều này không chỉ xảy ra trong trường hợp đặt lịch thi, mà còn có thể gặp phải trong các ứng dụng thương mại điện tử, nơi người dùng có thể đặt mua các sản phẩm không còn tồn kho hoặc chưa phát hành, nếu chỉ có xác thực ở frontend.

#### **3. Patching - Khắc Phục Lỗi**

Để khắc phục lỗi này, chúng ta cần phải **thêm xác thực kiểm tra khả dụng của ngày thi ở backend** trước khi tiến hành đặt lịch. Mã cần thêm vào sẽ trông như sau:

```javascript
// ensure exam slot is available
const bookedExams = UserExam.find({
  examId: exam.id,
  date: new Date(date),
  used: false,
});
if ((await bookedExams).length > 0) {
  return next({
    message: "Exam slot is not available.",
    statusCode: 400,
  });
}
```

**Giải thích**:
- **Xác minh slot thi có sẵn**: Trước khi tiến hành đặt lịch thi, chúng ta kiểm tra xem liệu có bất kỳ kỳ thi nào đã được đặt cho ngày này chưa. Nếu có, hàm trả về một lỗi thông báo rằng "Slot thi không khả dụng".
- **Lý do thêm mã này**: Bằng cách thêm mã này, chúng ta đảm bảo rằng ngay cả khi frontend không thực hiện kiểm tra đầy đủ, backend vẫn sẽ ngăn chặn các yêu cầu đặt lịch vào các ngày đã hết slot.

#### **4. Kiểm Tra Lại PoC sau khi Patching**

Sau khi thực hiện patch, hãy kiểm tra lại PoC như sau để xác minh rằng lỗi đã được khắc phục:
- **Khôi phục trạng thái ban đầu**: Đảm bảo rằng tất cả các slot đã được đặt hết trong cơ sở dữ liệu.
- **Gửi yêu cầu đặt lịch thi**: Gửi lại yêu cầu với ngày đã hết slot, giống như PoC ban đầu.
- **Kiểm tra kết quả**: Kiểm tra xem hệ thống có trả về thông báo lỗi về việc không có slot khả dụng hay không.
- **Xác nhận đã khắc phục**: Nếu hệ thống trả về thông báo lỗi khi người dùng cố gắng đặt lịch vào ngày đã hết slot, điều đó chứng tỏ lỗi đã được khắc phục thành công.

---
# 8. Lỗi Đầu Vào Không Mong Đợi

Khi phát triển logic của một hàm, việc kiểm tra và xác thực kiểu dữ liệu đầu vào là rất quan trọng. Nếu ứng dụng không thực hiện kiểm tra này một cách nhất quán, có thể dẫn đến các lỗi logic không mong đợi, do đầu vào không hợp lệ hoặc không đúng định dạng, gây ra sự cố trong xử lý.

Các lỗi này thường xuất hiện do việc sử dụng **biến kiểu lỏng lẻo** (loose typing), nơi mà một biến có thể nhận nhiều kiểu dữ liệu khác nhau, tùy thuộc vào đầu vào. Điều này có thể dẫn đến các lỗi logic không mong đợi nếu ứng dụng không kiểm tra kiểu dữ liệu đúng cách.

### **So Sánh Ngôn Ngữ Duyệt Kiểu Mạnh và Lỏng**

- **Ngôn ngữ duyệt kiểu mạnh** (Strongly-Typed): Các ngôn ngữ như **C#**, **Java**, và **TypeScript** yêu cầu khai báo biến với kiểu dữ liệu cụ thể, và chỉ nhận giá trị đúng với kiểu đó. Điều này giúp tránh các lỗi về kiểu dữ liệu khi gọi hàm. Trong một số trường hợp, kiểu có thể thay đổi tại thời điểm chạy (dynamic typing), nhưng khi đó kiểu hiện tại của biến vẫn phải phù hợp với kiểu của tham số trong hàm.
  
- **Ngôn ngữ duyệt kiểu lỏng** (Loosely-Typed): Ngược lại, các ngôn ngữ như **JavaScript** và **PHP** cho phép khai báo biến mà không xác định kiểu dữ liệu cụ thể. Điều này có thể dẫn đến việc biến nhận nhiều kiểu dữ liệu khác nhau, từ chuỗi đến số nguyên, số thập phân và nhiều loại khác, tùy thuộc vào đầu vào. Điều này làm tăng khả năng xảy ra các lỗi logic nếu không có sự xác thực đúng cách.

Ví dụ, trong **JavaScript**, một biến có thể nhận nhiều kiểu dữ liệu khác nhau (chuỗi, số, v.v.) tùy thuộc vào đầu vào của người dùng, và điều này có thể gây ra sự cố nếu không kiểm tra kỹ. Một ví dụ đơn giản trong PHP là phép toán **"10" + 10** có thể trả về **20**, cho thấy sự linh hoạt của ngôn ngữ trong việc xử lý kiểu dữ liệu.

### **Các Lỗi Do Đầu Vào Không Mong Đợi**

Một trong những lỗi phổ biến do đầu vào không mong đợi là khi một hàm được thiết kế để nhận các giá trị dương, nhưng lại nhận vào các giá trị âm. Điều này có thể dẫn đến việc người dùng không cần phải thanh toán gì, hoặc tệ hơn, hệ thống có thể **trả tiền lại cho người dùng** sau khi thực hiện một giao dịch. Ví dụ:

- **Giỏ hàng**: Nếu giỏ hàng cho phép thêm số lượng âm của một món hàng, tổng tiền sẽ bị giảm thay vì tăng lên, dẫn đến số tiền thanh toán bằng 0 hoặc thậm chí là âm (ví dụ, giảm giá trị thanh toán).
  
- **Chuyển tiền ngân hàng**: Nếu một ứng dụng ngân hàng không kiểm tra rằng số tiền chuyển đi là dương, thì việc chuyển tiền âm có thể dẫn đến việc **trừ tiền khỏi tài khoản của người khác**, ví dụ, khi người dùng X chuyển **-10 đô la** cho người Y, tài khoản của Y sẽ bị trừ **10 đô la** và số tiền này được chuyển vào tài khoản của X.

Ngoài giá trị âm, có rất nhiều lỗi đầu vào khác có thể gây ra lỗi logic, ví dụ như:
- **Chuỗi dài hơn mong đợi**.
- **Định dạng chuỗi bị thay đổi**.
- **Thao tác trên kiểu dữ liệu không đúng cách**.

Tất cả những lỗi này có thể được phân loại là **lỗi do đầu vào không mong đợi**.

### **Xác Định Các Lỗi Đầu Vào Không Mong Đợi**

Để xác định các lỗi này, chúng ta có thể sử dụng phương pháp **tìm kiếm và lọc hàm** để tìm ra những hàm sử dụng đầu vào trực tiếp từ người dùng. Các bước để làm điều này như sau:

1. **Tìm các hàm sử dụng đầu vào người dùng trực tiếp**: Tìm kiếm các hàm hoặc chức năng sử dụng dữ liệu từ phía người dùng, chẳng hạn như các tham số nhận giá trị từ biểu mẫu hoặc URL.

2. **Giới hạn kiểm tra các hàm sử dụng biến lỏng**: Tập trung vào các hàm sử dụng các biến kiểu lỏng (ví dụ: `var` hoặc `let`) và thực hiện các phép so sánh lỏng (ví dụ: `==` thay vì `===`). Những hàm này dễ bị ảnh hưởng bởi kiểu dữ liệu không mong đợi, đặc biệt nếu không có kiểm tra đầu vào.

3. **Kiểm tra các hàm không xác thực đầu vào**: Nếu hàm không thực hiện kiểm tra kiểu dữ liệu đầu vào hoặc chỉ sử dụng phép so sánh lỏng, thì rất có thể hàm đó sẽ chấp nhận các đầu vào không đúng định dạng và dẫn đến các lỗi logic.

### **Ví Dụ Thực Tế**

Giả sử một ứng dụng mua sắm cho phép người dùng chọn số lượng của các sản phẩm. Nếu không kiểm tra kỹ, người dùng có thể nhập giá trị âm cho số lượng sản phẩm, dẫn đến tổng giá trị giảm đi thay vì tăng lên.

- Nếu giỏ hàng của người dùng cho phép chọn **-3 sản phẩm**, giá trị tổng thanh toán có thể giảm đi, khiến người dùng không phải trả gì hoặc thậm chí nhận lại tiền.

- Một ứng dụng ngân hàng có thể không kiểm tra số tiền chuyển là dương, dẫn đến việc chuyển tiền âm, và trong trường hợp này, tài khoản của người nhận bị trừ tiền thay vì được cộng thêm.

---
# 9. Code Review - Lỗi Đầu Vào Không Mong Đợi

Trong phần này, chúng ta sẽ tập trung vào việc xác định tất cả các hàm nhận đầu vào từ người dùng thông qua các yêu cầu GET và POST. Sau đó, chúng ta sẽ lọc ra những hàm đã áp dụng xác thực đầu vào kiểu dữ liệu và chỉ tập trung vào các hàm còn lại để kiểm tra trong giai đoạn **Local Testing**.

---

### **Xác Định Các Hàm Nhận Đầu Vào Người Dùng**

Để giảm phạm vi tìm kiếm, ta có thể tìm kiếm trong mã nguồn các hàm có tham số từ **GET** (thông qua `req.params`) hoặc **POST** (thông qua `req.body`). Sau khi tìm được các hàm như vậy, ta sẽ lọc ra những hàm đã sử dụng xác thực kiểu dữ liệu và tiếp tục kiểm tra các hàm còn lại.

**Ví dụ các hàm có đầu vào người dùng:**
- `applyCoupon()`
- `getExamById()`, `getExamAvailability()`, `getExamContent()`
- `getModuleById()`, `unlockModule()`
- `processPayment()`
- `createUser()`, `login()`, `updateUserDetails()`, `resetPassword()`

Chúng ta có thể sử dụng biểu thức chính quy để tìm kiếm trong mã nguồn, ví dụ: `req.body` hoặc `req.params`.

---

### **Lọc Các Hàm Đã Áp Dụng Xác Thực Đầu Vào**

Tiếp theo, ta sẽ lọc ra những hàm đã áp dụng xác thực đầu vào. Ví dụ, hàm `applyCoupon()` sử dụng một chức năng xác thực mã giảm giá, và nếu không hợp lệ, hàm sẽ trả về lỗi. Cụ thể, hàm kiểm tra mã giảm giá qua `CouponCodeSchema` và hàm `validate` của gói **yup**, đảm bảo rằng đầu vào phải là một chuỗi và phải khớp với biểu thức chính quy MD5.

**Ví dụ hàm xác thực mã giảm giá:**
```javascript
const errors = await validateCouponCode({ coupon });
if (errors) {
  return next(errors);
}
```

Làm như vậy sẽ giúp ta loại trừ các hàm có xác thực đầu vào mạnh mẽ, tránh mất thời gian kiểm tra lại các hàm này. Nếu cần, ta có thể quay lại kiểm tra chúng sau.

---

### **Lọc Các Hàm Kiểm Tra ID**

Một số hàm như `getExamById()` chỉ nhận **id** và sử dụng nó để truy vấn trong cơ sở dữ liệu. Dù không kiểm tra kiểu dữ liệu đầu vào, nhưng hàm này sẽ trả về lỗi **404** nếu không tìm thấy bản ghi tương ứng. Vì vậy, chúng ta có thể xem xét các tham số **id** là an toàn và không cần xác thực thêm, miễn là hệ thống trả về lỗi hợp lý khi không tìm thấy kết quả.

Ví dụ trong `getExamById()`:
```javascript
if (!exam) {
  throw new Error();
}
```

Các hàm với ID tham số mà không gặp phải lỗi này có thể được lọc ra khỏi quá trình kiểm tra.

---

### **Xem Xét Các Mô Hình Schema**

Sau khi lọc được các hàm, chúng ta cần kiểm tra kỹ hơn các mô hình **Schema** được sử dụng trong xác thực đầu vào. Các schema này có thể xác nhận đầu vào người dùng thông qua **yup** hoặc các hàm xác thực tùy chỉnh.

Ví dụ, trong hàm `applyCoupon()`, schema `CouponCodeSchema` yêu cầu mã coupon phải là một chuỗi khớp với biểu thức chính quy MD5:
```javascript
export const CouponCodeSchema = yup.object({
  coupon: yup
    .string()
    .matches(/^[a-f0-9]{32}$/i, "Invalid coupon.")
    .required(),
});
```

Điều này đảm bảo rằng mã coupon chỉ nhận các giá trị hợp lệ, tránh các đầu vào không mong đợi. Tương tự, chúng ta có thể kiểm tra các schema khác như `CartItemSchema`, `UserSchema`, và `passwordResetSchema` để tìm ra những điểm yếu trong quá trình xác thực.

---

### **Danh Sách Các Hàm Cần Kiểm Tra Kỹ Hơn**

Sau khi lọc qua tất cả các hàm và xác thực, chúng ta chỉ còn lại hai hàm cần kiểm tra kỹ hơn:
- **`processPayment()`**: Hàm này sử dụng `CartItemSchema` để xác thực thông tin mặt hàng trong giỏ hàng.
- **`resetPassword()`**: Sử dụng `passwordResetSchema` để xác thực đầu vào.

Cả hai hàm này đều sử dụng các schema để xác thực dữ liệu, nhưng cần kiểm tra kỹ hơn xem có bất kỳ điểm yếu nào trong các quy tắc xác thực hay không.

---
# 10. Kiểm Tra Lỗi Đầu Vào Không Mong Đợi trong `processPayment()`

Chúng ta sẽ kiểm tra và đánh giá sự vững chắc của xác thực đầu vào trong hàm `processPayment()` của tệp `payment-controllers.js`. Mục tiêu chính là xác định các điểm yếu liên quan đến **an toàn kiểu dữ liệu** và những trường hợp mà chúng ta có thể sử dụng kiểu dữ liệu không mong đợi để vượt qua bộ lọc xác thực.

#### **1. Phân Tích Hàm `processPayment()`**

Hàm `processPayment()` có vẻ khá dài và phức tạp, điều này có thể tạo ra một bề mặt tấn công rộng lớn hơn. Hàm này sử dụng hai đầu vào quan trọng từ người dùng:
- **`cardId`**: Dùng để truy xuất thông tin thẻ thanh toán của người dùng thông qua `PaymentCard.findOne`.
- **`items`**: Đây là mảng các món hàng mà người dùng đang thanh toán.

Trong đoạn mã kiểm tra thẻ thanh toán, nếu người dùng không có thẻ hoặc cung cấp `cardId` sai, hàm sẽ trả về một lỗi:

```javascript
try {
  card = await PaymentCard.findOne({
    userId,
    _id: cardId,
  });
  if (!card) {
    throw new Error();
  }
} catch (err) {
  return next({
    message: "Could not find a card with this id for this user.",
    statusCode: 404,
  });
}
```

**Bước kiểm tra**: Chúng ta có thể thử gửi một yêu cầu với `cardId` là một chuỗi ngẫu nhiên và một mảng rỗng cho `items`, để xác minh xem lỗi có xảy ra hay không.

#### **2. Kiểm Tra `items` với Kiểu Dữ Liệu Không Mong Đợi**

Tiếp theo, chúng ta kiểm tra phần xử lý `items`. Hàm này sẽ lặp qua từng món hàng trong mảng `items` và truy xuất các thuộc tính như `name`, `category`, `price`, và `amount`. Tuy nhiên, mã không kiểm tra xem đầu vào có thực sự là một mảng hay không.

```javascript
// validate items + get prices
try {
  for (const item of items) {
    const { name, category, price, amount } = item;
    // validateCartItemDetails(item);
  }
} catch (err) {
  return next({
    message: "Error processing the items.",
    statusCode: 400,
  });
}
```

Nếu chúng ta thay đổi kiểu dữ liệu của `items` thành một số thay vì mảng, liệu hàm có hoạt động chính xác không? Trong JavaScript, một chuỗi sẽ được coi là mảng và có thể lặp qua, nhưng số sẽ không thể được lặp qua, dẫn đến lỗi.

**Bước kiểm tra**: Chúng ta có thể thử gửi một yêu cầu với `items` là một số thay vì mảng:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": 0
}
```

Sau khi gửi yêu cầu, ta sẽ nhận được thông báo lỗi do hàm không thể lặp qua một số. Lỗi này sẽ là một **lỗi không mong đợi** và gây ra lỗi `TypeError: items not iterable`.

#### **3. Phân Tích `validateCartItemDetails()`**

Tiếp theo, chúng ta sẽ xem xét hàm `validateCartItemDetails()` được sử dụng để xác thực từng món hàng trong mảng `items`. Hàm này sử dụng thư viện **Yup** để kiểm tra tính hợp lệ của các thuộc tính trong từng đối tượng món hàng.

```javascript
export const CartItemSchema = yup
  .object({
    name: yup.string().required(),
    category: yup.mixed().oneOf(["subscription", "exam", "cubes"]).required(),
    price: yup.number().required(), // in usd
    amount: yup.number().required(), // item count
  })
  .required();
```

Chúng ta thấy rằng các thuộc tính `name`, `category`, `price`, và `amount` đều được đánh dấu là **required** và được kiểm tra loại dữ liệu. Tuy nhiên, có một số vấn đề quan trọng:

- **Không kiểm tra giá trị hợp lý**: 
  - `price` và `amount` chỉ kiểm tra kiểu dữ liệu là số mà không đảm bảo chúng là **số dương**. Điều này có thể dẫn đến việc chấp nhận giá trị **giá trị âm** cho `price` hoặc `amount`, điều này không hợp lý trong bối cảnh thanh toán.
  - Không có kiểm tra giới hạn cho `amount`, ví dụ như không cho phép số lượng là **0** hoặc **số âm**.

### **Lợi Ích và Tác Hại của Lỗi Kiểu Dữ Liệu Không Mong Đợi**

1. **Lỗi Kiểu Dữ Liệu Không Mong Đợi**:
   - Việc gửi **số thay vì mảng** dẫn đến lỗi `TypeError: items not iterable`, điều này có thể ngăn không cho hàm thực hiện chính xác. Tuy nhiên, lỗi này được xử lý trong khối `catch` và không ảnh hưởng đến hệ thống nghiêm trọng, nhưng vẫn cần phải xử lý xác thực đầu vào cho `items` là một mảng.
  
2. **Lỗi Xác Thực Mã Hàng Hóa (Cart Item Validation)**:
   - Không có kiểm tra đối với giá trị **âm** hoặc **bằng 0** của `price` và `amount`, điều này có thể tạo cơ hội để người dùng gửi giá trị không hợp lệ, gây ra lỗi trong quá trình thanh toán.

---

# 11. Local Testing (Manipulation) - Kiểm tra đầu vào bất ngờ**

Giờ đây, chúng ta đã có bằng chứng vững chắc cho thấy bài kiểm tra xác thực trong `CartItemSchema` bị lỗi, nên tiếp tục kiểm tra để xem liệu chúng ta có thể tận dụng điểm yếu này hay không. Mục tiêu của chúng ta là chứng minh rằng chúng ta có thể tác động đến tổng giá trị thanh toán bằng cách gửi đầu vào bất ngờ, điều này sẽ ảnh hưởng đến tính toán giá trị tổng và thay đổi logic dự định.

### **Manipulate Giá**
Bắt đầu với một bài kiểm tra đơn giản là đặt giá trị `0` cho một mặt hàng mà chúng ta mua, vì giá trị này được phép theo schema (vì yêu cầu duy nhất là phải là một số). Điều này có thể cho phép chúng ta mua bất kỳ mặt hàng nào mà không mất phí.

Chúng ta sẽ thử nghiệm động và gửi một yêu cầu thanh toán để mua một số "cubes" với giá `0`. Một lần nữa, chúng ta có thể sao chép yêu cầu được gửi từ giao diện người dùng, nhưng thay vì làm như vậy, chúng ta sẽ tạo một đối tượng JSON riêng. Chúng ta có thể tái sử dụng đối tượng JSON mà chúng ta đã gửi, nhưng thay vì giá trị `0` cho `items`, chúng ta sẽ sử dụng một đối tượng với 4 yếu tố đã nêu, và đặt "price" thành `0`, ví dụ:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": [
    {
      "name": "1000",
      "category": "cubes",
      "price": 0,
      "amount": 1
    }
  ]
}
```

Lưu ý: Khi xem qua mã, chúng ta nhận thấy rằng giá trị `name` sẽ được phân tích dưới dạng một số và sử dụng số lượng "cubes" (với `parseInt(name)`), do đó chúng ta có thể nhập số lượng "cubes" muốn mua. Tuy nhiên, khi gửi yêu cầu, chúng ta gặp phải thông báo lỗi "Insufficient funds" (Không đủ tiền).

Vì sao lại không đủ tiền khi giá trị chúng ta gửi là `0`? Khi tiếp tục kiểm tra phần còn lại của vòng lặp, chúng ta nhận thấy rằng giá trị `price` mà chúng ta gửi không được sử dụng, thay vào đó, hệ thống tính toán giá trị bằng cách sử dụng thông tin từ cơ sở dữ liệu:

```javascript
case "cubes":
  total += (parseInt(name) * amount) / 10;
  break;
```

Do đó, giá trị `price` không thực sự ảnh hưởng đến tổng giá trị tính toán, và lỗi logic này không dẫn đến sự cố nghiêm trọng.

### **Thử nghiệm với Dữ liệu Không thể phân tích**
Vậy nếu chúng ta thử gửi một giá trị không thể phân tích cho biến `name`, điều gì sẽ xảy ra? Ví dụ, thay vì một số, chúng ta có thể gửi chuỗi không thể phân tích, như `"test"`.

Khi thực hiện thử nghiệm, chúng ta phát hiện ra rằng yêu cầu vẫn được thông qua mà không gặp lỗi. JavaScript không thể phân tích chuỗi `"test"` thành một số và trả về `NaN` (Not a Number). Tuy nhiên, JavaScript không dừng lại mà tiếp tục thực thi mã, điều này tạo ra lỗi không lường trước được. Giá trị tổng (total) bị hỏng thành `NaN`, và điều này có thể dẫn đến các vấn đề trong cơ sở dữ liệu và các tính toán sau này. Dữ liệu `NaN` có thể gây ra lỗi trong việc xử lý giao dịch và cập nhật số dư của thẻ.

### **Tác động của Đầu vào Bất Ngờ**
Việc gửi giá trị không hợp lệ (như chuỗi `"test"`) không gây ra lỗi ngay lập tức, nhưng nó làm hỏng tổng giá trị thanh toán (tạo ra `NaN`), điều này có thể dẫn đến các lỗi nghiêm trọng trong hệ thống. Khi `NaN` được sử dụng trong các phép toán sau, như trong việc xử lý giao dịch mua "cubes", điều này có thể làm cơ sở dữ liệu bị hỏng và gây ra các vấn đề khác trong việc tính toán số dư thẻ thanh toán.

Ngoài ra, việc không kiểm tra giá trị `amount` là một lỗ hổng bảo mật tiềm ẩn. Nếu `amount` có thể là một số âm, điều này sẽ làm giảm tổng giá trị thanh toán thay vì tăng lên, và người dùng có thể trả ít hơn hoặc không phải trả gì cả.

---
# 12. PoC và Patching - Đầu vào bất ngờ

Sau tất cả các thử nghiệm, chúng ta sẽ thử nghiệm lại những phát hiện của mình để xem liệu chúng ta có thể thực sự mua "cubes" miễn phí bằng cách khai thác lỗi kiểu dữ liệu mà chúng ta đã xác định hay không.

### **Proof of Concept (PoC)**
Giả sử chúng ta muốn có được "cubes" miễn phí hoặc với mức giá giảm. Chúng ta có thể thêm một mặt hàng với số lượng âm, điều này sẽ làm giảm giá trị tổng thanh toán. Ví dụ, nếu chúng ta đặt số lượng là `100 cubes`, giá của chúng sẽ là `10 USD` (theo các tính toán trước đó hoặc giao diện người dùng). Tuy nhiên, nếu chúng ta chỉ định số lượng là `-1`, giá trị tổng thanh toán sẽ giảm đi (10 * -1 = -10 USD).

Nếu chúng ta thêm một mặt hàng khác với số lượng bằng `1`, thì giá trị tổng sẽ là `0`, và số dư thẻ của chúng ta sẽ không bị thay đổi.

Chúng ta có thể sử dụng lại payload trước đó và điều chỉnh để phù hợp với các điều kiện trên:

```json
{
  "cardId": "64b85d58cabeffbc46ce76c9",
  "items": [
    {
      "name": "100",
      "category": "cubes",
      "price": 0,
      "amount": 1
    },
    {
      "name": "100",
      "category": "cubes",
      "price": 0,
      "amount": -1
    }
  ]
}
```

Khi chức năng xử lý yêu cầu này, nó sẽ thực hiện các bước sau:

1. **Kiểm tra `cardId`** – Đây là bước xác thực đầu vào cơ bản.
2. **Xử lý `items`** – Duyệt qua các mặt hàng và tính toán tổng giá trị. Trong lần đầu, tổng sẽ bị giảm đi `-10 USD` và trong lần thứ hai, tổng sẽ là `0 USD`.
3. **Kiểm tra số dư thẻ** – Tổng thanh toán sẽ là `0 USD`, nên không có sự thay đổi nào đối với số dư thẻ.
4. **Xử lý các mặt hàng** – Mặt hàng `cubes` đầu tiên sẽ được xử lý và mặt hàng có số lượng âm sẽ không được xử lý.
5. **Cập nhật số dư thẻ** – Số dư thẻ không bị thay đổi vì tổng là `0 USD`.

Khi gửi yêu cầu trên, chúng ta sẽ nhận được phản hồi xác nhận việc thanh toán đã được xử lý thành công với tổng là `0 USD`. Tiếp theo, khi đăng nhập vào giao diện người dùng, chúng ta sẽ thấy rằng số lượng "cubes" của chúng ta đã tăng lên mà không phải trả bất kỳ khoản phí nào.

### **Ý Nghĩa**
Sự kiện này cho thấy một sai sót nhỏ trong việc xác thực các mặt hàng trong giỏ hàng đã dẫn đến việc làm hỏng hệ thống thanh toán, cho phép chúng ta mua bất kỳ mặt hàng nào mà không phải trả tiền, ngay cả khi số dư thẻ của chúng ta bằng `0`.

### **Khó Khăn**
Chúng ta có thể thử thực hiện cuộc tấn công này chỉ bằng cách sử dụng trình duyệt và giao diện người dùng của web. Gợi ý: Hãy kiểm tra cách mà trình duyệt lưu trữ các mặt hàng trong giỏ hàng.

Ví dụ này minh họa tầm quan trọng của việc kiểm tra và xác thực đầy đủ tất cả các đầu vào từ người dùng, bao gồm cả các đối tượng con có thể được gửi trong yêu cầu. Nếu không có cơ chế xác thực chắc chắn, các vấn đề như thế này sẽ phát sinh, dẫn đến các lỗi logic và bảo mật nghiêm trọng.

---
# 13. Null Safety (An toàn Null)
Các ngôn ngữ hiện đại hỗ trợ **null safety** đảm bảo rằng các biến null không bị truy cập khi chưa có giá trị, bằng cách áp dụng các kiểm tra/quy tắc trong quá trình chỉnh sửa mã hoặc trước khi mã được biên dịch. Một số ngôn ngữ đã triển khai các giải pháp null safety bao gồm **TypeScript**, **Rust**, **C#**, **Swift**, **Kotlin**, và **Dart**.

Tuy nhiên, nhiều ngôn ngữ khác, như **JavaScript**, vẫn chưa hoàn toàn hỗ trợ null safety, vì vậy nhiều lập trình viên sử dụng các kiểm tra để đảm bảo rằng biến không phải là null trước khi truy cập vào nó. Ví dụ, một lập trình viên có thể kiểm tra nếu biến là null (ví dụ: `if (count === null)` hoặc `if (!(count))`), hoặc thực hiện các kiểm tra kiểu dữ liệu để đảm bảo giá trị hiện tại khớp với kiểu dữ liệu mong đợi và không phải null.

Dù có những kiểm tra như vậy, chúng ta vẫn không thể tránh hoàn toàn lỗi tham chiếu null, vì có thể có các trường hợp bất ngờ dẫn đến việc truy cập vào các biến trước khi chúng được gán giá trị.

### **Các khái niệm chính về Null Safety**
Các ngôn ngữ hỗ trợ null safety thường áp dụng những khái niệm cơ bản để tránh lỗi null reference. Một số khái niệm này bao gồm:

| **Khái niệm**              | **Mô tả**                                                                                                                                      | **Ví dụ**                     |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|
| **Biến không thể null**     | Biến phải được khởi tạo với giá trị và không thể chứa null khi sử dụng, nếu không sẽ báo lỗi.                                                  | `let count: number;`          |
| **Biến có thể null**        | Biến có thể chứa giá trị null, và cần được sử dụng cẩn thận.                                                                                   | `let count: number | null;`   |
| **Toán tử chuỗi null (`?.`)** | Dùng với biến có thể là null, cho phép chỉ truy cập vào các thuộc tính của đối tượng nếu biến không phải null.                                  | `total = list?.length`        |
| **Toán tử coalescing null (`??`)** | Dùng với biến có thể là null, cho phép đặt giá trị mặc định nếu biến null.                                                                      | `total = count ?? 0`          |
| **Toán tử khẳng định không null (`!`)** | Dùng với biến có thể là null, cho phép bỏ qua các kiểm tra null nếu chắc chắn rằng biến không phải null tại thời điểm đó.                    | `total = list!.length`        |

Các ngôn ngữ như TypeScript, Rust, C#, Swift, Kotlin, và Dart đã triển khai các giải pháp null safety, trong khi những ngôn ngữ như JavaScript vẫn chưa hỗ trợ đầy đủ. Tuy nhiên, JavaScript đã bắt đầu hỗ trợ một số toán tử như `??` để giảm thiểu lỗi liên quan đến null.

### **Các Vấn Đề với Null Safety**
Mặc dù các ngôn ngữ hỗ trợ null safety có thể giúp giảm thiểu lỗi, nhưng chúng vẫn có thể tạo ra các vấn đề liên quan đến logic khi sử dụng toán tử khẳng định không null (`!`) hoặc khi vô hiệu hóa kiểm tra null. Điều này có thể dẫn đến các lỗi logic do các kiểm tra an toàn bị bỏ qua.

### **Xác Định Lỗi Null**
Khác với các lỗi logic thông thường, các vấn đề liên quan đến null safety có thể được xác định một cách đáng tin cậy qua các công cụ, vì hầu hết các ngôn ngữ đã đề cập ở trên thực hiện kiểm tra này trong quá trình chỉnh sửa mã. Tuy nhiên, công cụ chỉ xác định được các trường hợp có thể xảy ra lỗi khi một biến có thể được truy cập khi là null, và không thực hiện phân tích logic để xem các ảnh hưởng nếu điều đó xảy ra.

Vì vậy, trong các ngôn ngữ hỗ trợ null safety, chúng ta cần tập trung vào việc kiểm tra các thao tác **vượt qua** các kiểm tra null safety, chẳng hạn như việc sử dụng toán tử khẳng định không null (`!`).

### **Các Bước Xác Định Null Bugs**
Để xác định các lỗi liên quan đến null safety, chúng ta có thể làm theo các bước sau:

1. **Đối với các ngôn ngữ không hỗ trợ null safety**: Tìm kiếm các biến chưa được khởi tạo hoặc bị gán null sau khi khai báo.
   
2. **Đối với các ngôn ngữ hỗ trợ null safety**: Kiểm tra việc sử dụng toán tử khẳng định không null (`!`) và xem liệu điều đó có thể dẫn đến lỗi tham chiếu null không.

Sau khi xác định các biến có thể gây lỗi null, chúng ta cần kiểm tra các kiểm tra an toàn null được thực hiện cho các biến này, chẳng hạn như các kiểm tra kiểu hoặc điều kiện `if (count !== null)`. Nếu chúng ta có thể xác định được trường hợp có thể bỏ qua các kiểm tra này, thì có thể là một bug cần được kiểm tra thêm.

---
# 14. Code Review (Biến Null) - An toàn Null trong JavaScript

Khi thực hiện **code review** liên quan đến **null variables** trong JavaScript, chúng ta cần chú ý đến những biến có thể mang giá trị null hoặc các tham số tùy chọn có thể không được gán giá trị mặc định. Việc nhận diện và xử lý các lỗi này là rất quan trọng để tránh những bug logic tiềm ẩn khi ứng dụng chạy.

#### **Các Lỗi Phổ Biến Liên Quan Đến Null trong JavaScript**

JavaScript có ba loại giá trị không xác định (không chứa giá trị) có thể dẫn đến lỗi khi kiểm tra các biến null:
1. **null**
2. **undefined**
3. **NaN**

JavaScript không tạo ra lỗi tại thời điểm chạy khi xử lý các giá trị null, undefined, hoặc NaN. Thay vào đó, nó tiếp tục thực thi mã như thể các biến này đã được gán giá trị hợp lệ, điều này có thể gây ra kết quả không mong muốn.

Ví dụ:
- **NaN** (Not-a-Number) trả về kiểu `number` dù nó không phải là một số hợp lệ.
- **undefined** và **null** có những đặc điểm khác nhau nhưng khi không so sánh chính xác bằng `===`, việc kiểm tra chúng có thể không hoạt động đúng, dẫn đến lỗi logic.

#### **Các Lỗi Kiểm Tra Null Không Chính Xác**

Trong JavaScript, kiểm tra biến có phải là null không bằng cách sử dụng dấu `!` có thể dẫn đến kết quả không chính xác. Ví dụ:

```javascript
const { count } = req.body;
if (!count) {
  throw new Error();
}
```

Trong trường hợp này, nếu giá trị `count` là `0` (số không), JavaScript sẽ coi `0` là `false`, và mã sẽ ném lỗi mặc dù `count` không phải là `null`. Đây là một ví dụ về lỗi logic có thể xảy ra khi kiểm tra null không chính xác, vì JavaScript không phân biệt giữa các giá trị "falsey" như `0`, `""` (chuỗi rỗng), `false`, `null`, và `undefined`.

**Giải pháp**: Sử dụng phép so sánh chặt chẽ `!==` hoặc `===` và kiểm tra cả `null` và `undefined`.

#### **Nhận Diện Các Biến Null**

Để xác định những biến có thể chứa null, có thể bắt đầu bằng cách tìm kiếm các khai báo biến không có giá trị khởi tạo trong mã nguồn. Trong JavaScript, khi sử dụng `let` hoặc `var`, các biến này có thể không được khởi tạo với giá trị, trong khi `const` yêu cầu phải có giá trị ngay lập tức.

Ví dụ, sử dụng biểu thức tìm kiếm regex trong VSCode như sau:
```
(let|var) [A-Za-z]*;
```

Điều này sẽ giúp chúng ta tìm ra các biến chưa được gán giá trị ngay từ đầu.

#### **Kiểm Tra Các Biến Null Trong Mã**

Ví dụ kiểm tra mã từ một ứng dụng web:

```javascript
const { user } = await User.findById(userId);
if (!user) {
  throw new Error('User not found');
}
```

Trong đoạn mã trên, nếu `user` không được tìm thấy (tức là nó có giá trị `null`), ứng dụng sẽ ném một lỗi và dừng thực thi. Đây là một cách hợp lý để xử lý giá trị null. Tuy nhiên, việc sử dụng `if (!user)` vẫn cần phải được kiểm tra kỹ lưỡng, vì trong một số trường hợp, nếu giá trị của `user` là một chuỗi rỗng hoặc `0`, điều này cũng có thể gây ra lỗi không mong muốn.

---
# 14. Code Review (Optional Parameters) - Null Safety in JavaScript

Trong phần này, chúng ta sẽ tiếp tục thảo luận về các vấn đề liên quan đến **null safety** trong JavaScript, nhưng lần này tập trung vào **optional parameters** (tham số tùy chọn). Như đã đề cập trong phần trước, các tham số tùy chọn có thể dẫn đến các lỗi logic nghiêm trọng nếu chúng không được kiểm tra kỹ lưỡng khi nhận giá trị `null`.

#### **Nhận Diện Tham Số Null trong Các API Endpoints**

Trong các ứng dụng web, đặc biệt là khi làm việc với API, có rất nhiều trường hợp tham số từ người dùng có thể là **optional** (tùy chọn) và có thể nhận giá trị **null**. Nếu các tham số này không được kiểm tra đúng cách trước khi sử dụng, ứng dụng có thể gặp phải các lỗi nghiêm trọng.

**Các vấn đề khi sử dụng tham số tùy chọn**:
- **Không kiểm tra giá trị null**: Nếu tham số tùy chọn không có giá trị mặc định và không được kiểm tra kỹ trước khi sử dụng, có thể dẫn đến lỗi khi ứng dụng cố gắng sử dụng chúng.
- **API endpoint không xác định rõ ràng các tham số yêu cầu**: Nếu một API yêu cầu các tham số nhưng lại không có kiểm tra hoặc không rõ ràng trong việc xác định tham số nào là **required** hay **optional**, điều này có thể tạo ra các lỗ hổng bảo mật hoặc lỗi logic.

#### **Required vs Optional Parameters**

Một trong những cách chính để kiểm tra null safety là phân biệt giữa **required parameters** (tham số bắt buộc) và **optional parameters** (tham số tùy chọn). Trong JavaScript, tham số có thể được khai báo dưới dạng **named parameters** (tham số có tên) hoặc **positional parameters** (tham số theo thứ tự). 

Ví dụ, với một endpoint có tham số là:
```javascript
function processOrder({ orderId, couponCode }) {
  // xử lý đơn hàng
}
```
Ở đây, tham số `couponCode` có thể là **optional** (tùy chọn), và nếu không được cung cấp, giá trị của nó có thể là `null`. Tuy nhiên, nếu không kiểm tra `null`, có thể dẫn đến lỗi khi ứng dụng cố gắng sử dụng giá trị này.

#### **Kiểm Tra Các Tham Số Tùy Chọn**

Chúng ta cần kiểm tra các endpoint sử dụng dữ liệu người dùng đầu vào (input) và xác định liệu các tham số có phải là **optional** và có **null checks** đầy đủ hay không.

1. **CouponCodeSchema**:
   - Được sử dụng để kiểm tra mã coupon, tham số này là **required** và không có tham số tùy chọn:
   ```javascript
   export const CouponCodeSchema = yup.object({
     coupon: yup.string().matches(/^[a-f0-9]{32}$/i, "Invalid coupon.").required(),
   });
   ```
   Không có tham số tùy chọn trong schema này.

2. **CartItemSchema**:
   - Cũng giống như `CouponCodeSchema`, tất cả các tham số trong `CartItemSchema` đều là **required**, không có tham số tùy chọn:
   ```javascript
   export const CartItemSchema = yup.object({
     name: yup.string().required(),
     category: yup.mixed().oneOf(["subscription", "exam", "cubes"]).required(),
     price: yup.number().positive().min(1).required(),
     amount: yup.number().positive().min(1).required(),
   }).required();
   ```
   Do đó, không có nguy cơ null safety trong trường hợp này.

3. **passwordResetSchema**:
   - Tham số trong schema này đều là **optional**:
   ```javascript
   const passwordResetSchema = object({
     id: mixed((value) => ObjectId.isValid(value)).typeError("Invalid id"),
     token: string().matches(/[0-9a-f]{32}/i, "Invalid token"),
     password: string().min(5),
   }).required();
   ```
   Ở đây, tất cả các tham số đều không có `.required()`, tức là chúng là **optional**. Điều này có thể gây ra vấn đề nếu các tham số này không được kiểm tra `null` trước khi sử dụng. Ví dụ, nếu `token` hoặc `password` là `null`, có thể dẫn đến lỗi khi thực hiện xác thực.

4. **UserSchema**:
   - Một trong những schema được sử dụng phổ biến nhất trong ứng dụng:
   ```javascript
   export const UserSchema = yup.object({
     id: yup.string(),
     name: yup.string(),
     username: yup.string(),
     email: yup.string().email().required(),
     password: yup.string().min(5).required(),
     registrationDate: yup.date(),
   }).required();
   ```
   Ở đây, các tham số `id`, `name`, `username`, và `registrationDate` là **optional**, trong khi `email` và `password` là **required**. Điều này có thể gây vấn đề nếu các endpoint không kiểm tra các tham số optional trước khi sử dụng. Nếu `id` hoặc `username` là `null`, hệ thống có thể không xử lý đúng, đặc biệt trong các chức năng như tạo người dùng hoặc đăng nhập.

---
# 15. Kiểm Tra Null Safety trong `UserSchema` và `PasswordResetSchema`

#### 1. **Null Safety của `UserSchema`**
Trong phần trước, chúng ta đã xác định rằng `UserSchema` có bốn tham số tùy chọn: `username`, `id`, `name`, và `registrationDate`. Những tham số này được sử dụng ở các endpoint khác nhau như `createUser`, `login`, `updateUserDetails`, và `requestPasswordResetLink`. Sau đây là cách kiểm tra các vấn đề liên quan đến null safety:

##### **Endpoint `createUser`:**
- **Kiểm tra null cho `name` và `username`:** 
  Endpoint này thực hiện kiểm tra rõ ràng các giá trị `null` hoặc `undefined` cho `name` và `username`. Tuy nhiên, nó sử dụng toán tử `!` để kiểm tra các giá trị falsy, điều này có thể gây vấn đề nếu, ví dụ, một chuỗi hợp lệ như `"0"` hoặc `" "` (khoảng trắng) được truyền vào, vì chúng sẽ không bị coi là null hoặc undefined. Việc sử dụng kiểm tra nghiêm ngặt sẽ giúp tránh các vấn đề này.

  ```js
  if (!name || !username) {
      // xử lý thiếu tham số
  }
  ```

  **Cải tiến:** Thay bằng kiểm tra nghiêm ngặt với `null` hoặc `undefined`:
  ```js
  if (name === null || name === undefined || username === null || username === undefined) {
      // xử lý thiếu tham số
  }
  ```

- **Vấn đề với việc điều kiện `required()`:**
  Một cách tiếp cận tốt hơn là sử dụng **yêu cầu có điều kiện** trong schema, nơi các trường như `name` hoặc `username` có thể được đánh dấu là bắt buộc tùy thuộc vào một số điều kiện (ví dụ: một cờ như `useUsername`). Ngoài ra, có thể tạo các schema riêng biệt cho từng trường hợp sử dụng để tránh việc lặp lại mã và đảm bảo kiểm tra hợp lệ.

##### **Endpoint `updateUserDetails`:**
- **Xử lý các trường tùy chọn:**
  Mặc dù `name` và `username` là tùy chọn trong schema, nhưng chúng lại được sử dụng trực tiếp trong việc cập nhật cơ sở dữ liệu mà không kiểm tra giá trị `null`. Đây là một **lỗi logic** vì giá trị null có thể được lưu trong cơ sở dữ liệu, và nếu sau đó mã truy xuất những giá trị null này mà không mong đợi, sẽ dẫn đến lỗi runtime.

  ```js
  const updateReq = await User.findByIdAndUpdate(
      req.user?.id,
      {
          email,
          name,
          username,
      },
      { returnOriginal: false }
  );
  ```

  **Cải tiến:** Thực hiện kiểm tra null hoặc kiểm tra điều kiện cập nhật để đảm bảo không có giá trị null được truyền vào cơ sở dữ liệu.

##### **Cải tiến chung cho `UserSchema`:**
- Thay vì phụ thuộc vào kiểm tra null thủ công trong controller, sẽ hiệu quả hơn nếu sử dụng **schema riêng biệt** cho từng endpoint hoặc thêm **xác thực có điều kiện** dựa trên các cờ cụ thể. Điều này sẽ giúp đảm bảo rằng việc kiểm tra hợp lệ được thực hiện một cách nhất quán và ngăn ngừa các vấn đề tiềm ẩn.

---

#### 2. **Null Safety của `PasswordResetSchema`**
`passwordResetSchema` có tất cả các tham số là tùy chọn, có nghĩa là ít nhất một trong ba tham số `id`, `token`, hoặc `password` cần phải được cung cấp. Tuy nhiên, nếu bất kỳ tham số nào trong số này được truyền dưới dạng `null`, nó có thể gây vấn đề trong endpoint nơi chúng được sử dụng.

##### **Xử lý tham số tùy chọn trong endpoint:**
- **Tham số `id`:**
  Tham số `id` được sử dụng để xác định người dùng, và nếu nó là `null`, endpoint sẽ cố gắng tìm người dùng với giá trị `null`, điều này có thể gây lỗi.

  ```js
  user = await User.findById(id);
  ```

  **Cải tiến:** Kiểm tra `null` hoặc `undefined` trước khi thực hiện truy vấn cơ sở dữ liệu để tránh các truy vấn không hợp lệ:
  ```js
  if (!id) {
      return next({ message: "ID người dùng không hợp lệ.", statusCode: 400 });
  }
  ```

- **Tham số `token`:**
  Tham số `token` được sử dụng để xác thực việc đặt lại mật khẩu. Nếu nó là `null`, endpoint sẽ bỏ qua việc xác thực, cho phép các token không hợp lệ hoặc rỗng.

  ```js
  if (token && token !== hashedToken) {
      return next({ message: "Token đặt lại mật khẩu không hợp lệ.", statusCode: 403 });
  }
  ```

  **Cải tiến:** Đảm bảo rằng `token` không phải là `null` trước khi so sánh:
  ```js
  if (!token) {
      return next({ message: "Token là bắt buộc.", statusCode: 400 });
  }
  if (token !== hashedToken) {
      return next({ message: "Token đặt lại mật khẩu không hợp lệ.", statusCode: 403 });
  }
  ```

##### **Cải tiến chung cho `PasswordResetSchema`:**
- Giống như `UserSchema`, **xác thực có điều kiện** hoặc **schema riêng biệt** cho các tình huống khác nhau (ví dụ: một schema khi chỉ có `id` và `token`, và một schema khác khi có `password`) sẽ đảm bảo việc xử lý các tham số tùy chọn tốt hơn.

---
# 16. Kiểm Tra Null Safety trong Các Hàm và Tấn Công Null Safety

#### 1. **Tấn Công Null Safety:**

Tấn công Null Safety có thể khó thực hiện hơn so với các tấn công Injection hay lỗ hổng loại an toàn kiểu dữ liệu, vì chúng ta chỉ có thể kiểm soát một giá trị duy nhất: `null`. Tuy nhiên, chúng vẫn có thể gây ra các vấn đề nghiêm trọng, đặc biệt là khi hệ thống không xử lý đúng các giá trị `null`. Các tấn công này thường dẫn đến lỗi thời gian chạy hoặc khiến server gặp sự cố, gây gián đoạn dịch vụ (DoS), hoặc thậm chí có thể làm hỏng cơ sở dữ liệu hoặc bỏ qua các biện pháp bảo mật nếu kết hợp với các lỗi logic khác.

#### 2. **Các Vấn Đề Null Safety Thường Gặp:**

Các vấn đề Null Safety thường dẫn đến các lỗi thời gian chạy hoặc khiến server gặp sự cố. Đây là một vấn đề nghiêm trọng và là mục tiêu phổ biến của các cuộc tấn công từ các đối tượng ác ý, đặc biệt nếu chúng có thể gây sự cố mà không cần mạng bot lớn (ví dụ, tấn công DDoS).

- **Hiệu quả của lỗi Null Safety:**
  - **Lỗi thời gian chạy**: Dẫn đến việc server bị sập hoặc không thể tiếp tục xử lý yêu cầu.
  - **Tấn công từ chối dịch vụ (DoS)**: Server có thể bị tấn công chỉ bằng cách gửi giá trị `null`, gây ảnh hưởng đến khả năng hoạt động của hệ thống.
  - **Lỗi logic**: Nếu giá trị `null` bị xử lý không đúng cách, có thể gây ra các lỗi nghiêm trọng như truy vấn cơ sở dữ liệu sai, bỏ qua kiểm tra bảo mật, hoặc thay đổi dữ liệu.

#### 3. **Tấn Công Vào `Update User Details`:**

Trong trường hợp cập nhật chi tiết người dùng (`updateUserDetails`), tham số `name` và `username` là tùy chọn, do đó, việc gán giá trị `null` cho chúng có thể dẫn đến những kết quả không mong muốn, như lưu giá trị `null` vào cơ sở dữ liệu nếu không có kiểm tra đúng cách.

- **Kiểm tra giá trị `null`:**
  Trong phần kiểm tra cập nhật người dùng, nếu không có giá trị `name` hoặc `username`, có thể các tham số này sẽ không được cập nhật trong cơ sở dữ liệu, hoặc nếu sử dụng các hàm cập nhật khác (như `set`), chúng có thể được thay đổi thành `null`, gây ra các vấn đề liên quan đến logic hoặc thậm chí làm hỏng cơ sở dữ liệu.
  
- **Kiểm tra lại trong cơ sở dữ liệu:**
  Trong trường hợp của bạn, mặc dù gửi yêu cầu không bao gồm tham số `name` và `username`, các giá trị trong cơ sở dữ liệu không bị thay đổi. Điều này có thể do cách gọi cơ sở dữ liệu sử dụng hàm `findByIdAndUpdate`, mà trong đó nếu tham số không có sự thay đổi thì sẽ không cập nhật gì cả.

#### 4. **Tấn Công Vào `Reset Password`:**

Trong endpoint đặt lại mật khẩu (`resetPassword`), các tham số như `id`, `token`, và `password` đều là tùy chọn và không được kiểm tra đúng cách trước khi sử dụng. Điều này có thể tạo ra các lỗi nghiêm trọng.

- **Tham số `id`:**
  Nếu `id` là `null`, mã có thể gặp lỗi khi không tìm thấy người dùng trong cơ sở dữ liệu. Tuy nhiên, điều này có thể được xử lý một cách an toàn nếu dùng MongoDB, và không phải lúc nào cũng gây ra sự cố nghiêm trọng.

- **Tham số `token`:**
  Lỗi logic lớn nằm ở chỗ mã không kiểm tra đúng giá trị của `token`. Nếu không có token (`null`), mã không thực hiện kiểm tra xác thực và vẫn tiếp tục thay đổi mật khẩu, dẫn đến lỗ hổng bảo mật lớn.
  
  ```js
  if (token && token !== hashedToken) {
      return next({
          message: "Invalid password reset token.",
          statusCode: 403,
      });
  }
  ```
  Nếu `token` là `null`, câu lệnh `if (token)` sẽ không được thực hiện, và mã sẽ bỏ qua phần kiểm tra token, điều này có thể cho phép người dùng thay đổi mật khẩu mà không có token hợp lệ.

- **Tham số `password`:**
  Khi tham số `password` là `null`, hàm bcrypt không được bao bọc trong `try/catch`, điều này có thể gây ra sự cố toàn bộ ứng dụng, đặc biệt nếu người dùng gửi yêu cầu đặt lại mật khẩu mà không cung cấp mật khẩu mới. Nếu `password` là `null`, hàm bcrypt sẽ gặp lỗi và có thể làm sập toàn bộ server.

  ```js
  const salt = await bcrypt.genSalt();
  const newHashPassword = await bcrypt.hash(password, salt);
  ```

  Nếu không có `password`, ứng dụng có thể gặp sự cố khi cố gắng tạo mã băm cho mật khẩu.

---
# 17. PoC và Patching - Null Safety

Trong phần này, chúng ta sẽ xác nhận tính khai thác của các vấn đề bảo mật liên quan đến Null Safety với một proof of concept (PoC), và sau đó thảo luận về cách áp dụng các bản vá để khắc phục các lỗ hổng.

### **Proof of Concept**

#### 1. **Chiếm đoạt tài khoản**
Chúng ta đã phát hiện ra rằng tham số `token` trong endpoint `resetPassword` không được kiểm tra đúng cách. Bằng cách bỏ qua tham số `token` và chỉ gửi `id` và `password`, chúng ta có thể khai thác lỗ hổng này để đặt lại mật khẩu của bất kỳ người dùng nào. Dưới đây là cách thực hiện:

1. **Chọn người dùng mục tiêu**: Chúng ta sẽ sử dụng người dùng có ID là `649f2893cba8d0d6e8412182`.
2. **Gửi yêu cầu POST** đến endpoint `/api/users/password/reset` với payload sau:
   ```json
   {
     "id": "649f2893cba8d0d6e8412182",
     "password": "123456"
   }
   ```
   Chúng ta không bao gồm tham số `token`, điều này cho phép bỏ qua việc kiểm tra token.

3. **Phản hồi**: Phản hồi sẽ là:
   ```
   Password updated successfully!
   ```

4. **Kiểm tra**: Nếu chúng ta thử đăng nhập với mật khẩu mới (`123456`), chúng ta sẽ đăng nhập thành công, chứng tỏ rằng cuộc tấn công đặt lại mật khẩu đã thành công.

#### 2. **Từ chối dịch vụ (Denial of Service - DoS)**
Bây giờ, chúng ta sẽ kiểm tra cách ứng dụng xử lý khi thiếu tham số `password`, điều này có thể gây sập máy chủ.

1. **Gửi yêu cầu POST** đến `/api/users/password/reset` với payload sau:
   ```json
   {
     "id": "649f2893cba8d0d6e8412182"
   }
   ```
   Chúng ta thiếu cả tham số `token` và `password`.

2. **Kết quả**: Máy chủ không phản hồi, và khi kiểm tra nhật ký (logs) của máy chủ trong Docker, chúng ta thấy ứng dụng đã bị sập.

3. **Tác động**: Máy chủ bị sập, gây ra tình trạng từ chối dịch vụ (DoS). Đây là một vấn đề nghiêm trọng, vì không người dùng nào có thể truy cập ứng dụng cho đến khi nó được khởi động lại.

### **Patching**

Để khắc phục các lỗ hổng này, chúng ta cần áp dụng các bản vá thích hợp trong mã nguồn:

#### 1. **Cập nhật `updateUserDetails`**
- **Vấn đề**: Tham số `username` trong `UserSchema` là tùy chọn, điều này có thể dẫn đến việc có giá trị null gây ra lỗi trong một số trường hợp.
- **Giải pháp**: Thực hiện kiểm tra điều kiện cho tham số `username` bằng cách sử dụng tham số boolean `useUsername`.

Ví dụ về schema đã được cập nhật:
```javascript
export const UserSchema = yup
  .object({
    useUsername: yup.boolean().default(false),
    id: yup.string(),
    name: yup.string(),
    username: yup
      .string()
      .when("useUsername", ([useUsername], schema) =>
        useUsername ? yup.string().required() : yup.string()
      ),
    email: yup.string().email().required(),
    password: yup.string().min(5).required(),
    registrationDate: yup.date(),
  })
  .required();
```

- Điều này đảm bảo rằng `username` chỉ được yêu cầu khi `useUsername` là `true`, tránh rủi ro giá trị null trong những trường hợp không sử dụng `username`.

#### 2. **Cập nhật `resetPassword`**
- **Vấn đề 1**: Tham số `token` không được kiểm tra kỹ lưỡng với null hoặc undefined, điều này cho phép người dùng bỏ qua việc xác thực token.
- **Vấn đề 2**: Hàm mặc định là thành công thay vì thất bại nếu token bị thiếu hoặc không hợp lệ.
- **Vấn đề 3**: Tham số `password` được sử dụng mà không có kiểm tra null safety, có thể gây sập ứng dụng khi tham số này thiếu.

**Giải pháp**:
1. **Yêu cầu tất cả các tham số**: Cập nhật `passwordResetSchema` để đảm bảo rằng tất cả các tham số (`id`, `token`, `password`) đều là bắt buộc.
   
Ví dụ về schema:
```javascript
const passwordResetSchema = object({
  id: mixed((value) => ObjectId.isValid(value))
    .typeError("Invalid id")
    .required(),
  token: string()
    .matches(/[0-9a-f]{32}/i, "Invalid token")
    .required(),
  password: string().min(5).required(),
}).required();
```

2. **Kiểm tra token**: Đảm bảo rằng token được so sánh chặt chẽ bằng `!==` để tránh sai lệch với null hoặc undefined.

Mã cập nhật:
```javascript
if (token !== hashedToken) {
  return next({
    message: "Invalid password reset token.",
    statusCode: 403,
  });
}
```

3. **Kiểm tra mật khẩu đúng cách**: Thêm khối `try/catch` quanh mã hash mật khẩu để tránh sập ứng dụng khi mật khẩu không hợp lệ hoặc null.

Mã cập nhật với `try/catch`:
```javascript
else {
  try {
    const salt = await bcrypt.genSalt();
    const newHashPassword = await bcrypt.hash(password, salt);
    // cập nhật mật khẩu người dùng
    <SNIP>
  } catch (err) {
    return next({
      message: "Error hashing password",
      statusCode: 500,
    });
  }
}
```

---
# 18. Tránh Lỗi Logic Tham Số

Đến thời điểm này, bạn đã có một hiểu biết rõ ràng về các loại lỗi logic liên quan đến đầu vào của người dùng và thao tác tham số. Bạn cũng đã có nhiều cơ hội để luyện tập cách nhận diện các lỗi logic này. Điều này giúp bạn có đủ kiến thức để tránh gây ra những lỗi logic này trong quá trình phát triển, cũng như nhận diện chúng khi xem xét mã nguồn.

Trong phần này, chúng ta sẽ tóm tắt một số mẹo để tránh việc gây ra các lỗi logic tham số trong mã của mình.

### **1. Logic Kiểm Tra (Validation Logic) Phân Cách**

Điều quan trọng nhất mà chúng ta cần lưu ý là **sự đồng nhất logic giữa front-end và back-end**. Chúng ta không thể chỉ dựa vào kiểm tra xác thực ở phía front-end, vì điều này có thể dẫn đến việc bỏ qua các hạn chế, hoặc kiểm tra chỉ ở phía back-end, vì điều này có thể gây ra trải nghiệm người dùng xấu và mất doanh thu. Mọi sự khác biệt giữa hai đầu (front-end và back-end) có thể dẫn đến hậu quả, như chúng ta đã thấy trong các ví dụ trước.

Điều này cũng áp dụng cho các kiểm tra kiểu và xác thực tham số. Vì vậy, tất cả các kiểm tra được thực hiện ở phía front-end phải được sao chép và thực hiện ở phía back-end, và ngược lại. Hơn nữa, các kiểm tra này cần phải giống nhau hoặc rất gần nhau để tránh gây ra các lỗi phân tách khác.

### **2. Đầu Vào Không Mong Muốn (Unexpected Input)**

Để tránh các lỗi logic phát sinh từ đầu vào không mong muốn, chúng ta nên thực hiện kiểm tra kiểu dữ liệu ở ba cấp độ khác nhau:
- **Client-side (Phía người dùng)** 
- **Server-side (Phía máy chủ)** 
- **Database (Cơ sở dữ liệu)**

Tất cả các cấp này nên bao gồm các kiểm tra như:
- Kiểm tra kiểu dữ liệu
- Các trường bắt buộc và tùy chọn
- Kiểm tra mẫu (pattern matching)
- Kiểm tra kích thước tham số
- Các kiểm tra khác để đảm bảo chỉ chấp nhận các giá trị đúng mà chúng ta mong muốn

Tất nhiên, chúng ta không cần phải lặp lại mã kiểm tra này ở mỗi cấp độ, vì điều này có thể gây ra sự phân tách và dư thừa do lỗi của con người. Thay vào đó, chúng ta có thể sử dụng các công cụ như **Yup schema**, công cụ này hỗ trợ cả phía front-end (ví dụ: React), back-end (ví dụ: Node/Express) và cơ sở dữ liệu với **mongoose**, giúp chúng ta sử dụng các schema giống nhau trên toàn bộ ứng dụng web.

Ngoài ra, các công cụ API như **tRPC**, **GraphQL**, cũng hỗ trợ việc xây dựng và sao chép API ở cả hai phía để đảm bảo không có sự xung đột hoặc trùng lặp công sức.

Nếu làm đúng, cách này sẽ giúp tránh các lỗi logic do đầu vào không mong muốn, vì cả máy chủ và cơ sở dữ liệu sẽ chỉ chấp nhận những giá trị khớp chính xác với những gì chúng ta đã thiết lập, và phía front-end sẽ giảm thiểu các lỗi từ phía máy chủ bằng cách chỉ gửi những kiểu dữ liệu được phép.

**Lưu ý**: Nên sử dụng các ngôn ngữ có kiểu dữ liệu mạnh như **TypeScript**, vì nó sẽ giúp phát hiện hầu hết các vấn đề liên quan đến kiểu dữ liệu và bảo mật null trong thời gian biên dịch, trước khi triển khai ứng dụng lên môi trường sản xuất.

### **3. Null Safety**

Để tránh các lỗi logic liên quan đến null safety, chúng ta cần đảm bảo rằng mã của chúng ta không bao giờ xử lý các biến chưa được gán giá trị. Điều này có thể khá khó khăn đối với các ngôn ngữ không hỗ trợ null safety tốt, nhưng nếu không có lựa chọn khác, chúng ta cần làm tất cả những gì có thể để tránh các vấn đề về null safety.

Khi khai báo các biến có thể null hoặc khi một hàm hoặc endpoint nhận các tham số tùy chọn, chúng ta phải:
- Đặt giá trị mặc định cho các biến, hoặc
- Thực hiện kiểm tra null đúng cách trước khi tiếp tục xử lý các biến này, và
- Bao quanh mã sử dụng những biến này bằng các khối `try/catch` để xử lý các lỗi phát sinh.

Đối với JavaScript, chúng ta nên sử dụng phép so sánh chặt chẽ (`===`), kiểm tra cả `null` và `undefined`. Tránh sử dụng toán tử phủ định (`!`) vì điều này có thể dễ dàng bị bỏ qua hoặc bị lừa.

**Đối với các tham số đầu vào tùy chọn của người dùng**, khi không sử dụng `.required()` (hoặc tương tự), chúng ta phải thực hiện các kiểm tra này mỗi khi sử dụng tham số, và không thể chỉ phụ thuộc vào xác thực từ schema. 

Một giải pháp lý tưởng là sử dụng các ngôn ngữ hỗ trợ null safety, nhưng ngay cả khi có null safety, chúng ta vẫn phải rất cẩn thận khi bỏ qua các biện pháp bảo vệ này và chỉ làm như vậy khi chắc chắn rằng biến đó **không bao giờ có thể là null** tại thời điểm đó trong mã.

### **4. Những Mẹo Khác**

- **Tránh sử dụng đầu vào của người dùng nếu có thể**: Ví dụ, thay vì yêu cầu người dùng gửi `uid` qua yêu cầu, chúng ta có thể sử dụng session của người dùng để lấy `uid` từ cơ sở dữ liệu.
  
- **Mặc định cấm truy cập thay vì cho phép**: Điều này rất quan trọng đối với bảo mật phía front-end, đặc biệt là trong các ứng dụng web hoặc di động. Một lỗi nhỏ trong logic null có thể cho phép người dùng truy cập vào các tài liệu trả phí chỉ dành cho thành viên, ví dụ như vậy.

- **Cung cấp sự bảo vệ với các token**: Đảm bảo rằng mã luôn kiểm tra sự hợp lệ của token trước khi tiếp tục xử lý, tránh việc bỏ qua token không hợp lệ, như chúng ta đã thấy trong ví dụ trước với `resetPassword`.

Với các mẹo trên và sự hiểu biết về các lỗi logic tham số, bạn có thể viết mã với logic vững chắc và tránh các lỗ hổng bảo mật này trong ứng dụng của mình.
