# 1. Introduction to Whitebox Attacks

Trong mô-đun này, chúng ta sẽ tìm hiểu về một số lỗ hổng bảo mật web nâng cao thông qua phương pháp *whitebox* (tấn công từ trong ra ngoài), cùng với cách khai thác chúng. Các lỗ hổng này bao gồm: 

- **Prototype Pollution**
- **Timing Attacks**
- **Race Conditions**
- **Type Juggling**

Để có thể hiểu và khai thác các lỗ hổng này, bạn cần có kiến thức vững về các lỗ hổng web cơ bản và cách khai thác chúng. Một nơi tốt để bắt đầu là mô-đun **Web Attacks**. Trong mô-đun này, chúng ta sẽ chủ yếu tập trung vào việc hiểu rõ nguyên nhân gốc rễ của các lỗ hổng này, thay vì tìm hiểu chi tiết toàn bộ mã nguồn của mỗi ứng dụng web có lỗ hổng. Kiến thức cơ bản về mã nguồn JavaScript, Python và PHP là cần thiết để hoàn thành mô-đun này.

---

### **Whitebox Attacks**

Tấn công *Whitebox* là phương pháp tấn công khi kẻ tấn công có thể truy cập vào mã nguồn hoặc cấu trúc hệ thống của ứng dụng, giúp chúng hiểu sâu về cách ứng dụng hoạt động. Phương pháp này khác với tấn công *Blackbox*, nơi kẻ tấn công không có quyền truy cập vào mã nguồn và chỉ tương tác với ứng dụng qua giao diện người dùng.

---

### **Prototype Pollution**

**Prototype Pollution** là một lỗ hổng bảo mật đặc trưng cho các ngôn ngữ lập trình theo mô hình *prototype-oriented* (theo mẫu đối tượng), như JavaScript. Lỗ hổng này xảy ra khi dữ liệu người dùng được sử dụng để thay đổi các thuộc tính của đối tượng JavaScript. Khi mã không kiểm tra đầu vào đúng cách, kẻ tấn công có thể thao túng đối tượng và dẫn đến các lỗ hổng bảo mật như:

- Tăng quyền (Privilege Escalation)
- Từ chối dịch vụ (Denial-of-Service - DoS)
- Thực thi mã từ xa (Remote Code Execution - RCE)

**Ví dụ:**  
Giả sử một ứng dụng web sử dụng dữ liệu từ người dùng để xây dựng đối tượng JavaScript mà không làm sạch đầu vào. Kẻ tấn công có thể thay đổi prototype của đối tượng và khai thác ứng dụng để chiếm quyền điều khiển.

---

### **Timing Attacks**

**Timing Attacks** là một loại tấn công dựa trên việc phân tích thời gian phản hồi của ứng dụng. Kẻ tấn công có thể lợi dụng sự khác biệt nhỏ trong thời gian xử lý để suy ra thông tin bí mật hoặc khai thác lỗ hổng. Các tấn công này có thể khai thác sự khác biệt trong thời gian mà ứng dụng xử lý dữ liệu, chẳng hạn như trong các kiểm tra xác thực mật khẩu.

**Ví dụ:**  
Nếu một ứng dụng kiểm tra mật khẩu bằng cách so sánh từng ký tự và phản hồi ngay khi ký tự sai, kẻ tấn công có thể đoán được mật khẩu bằng cách phân tích thời gian phản hồi cho mỗi ký tự.

---

### **Race Conditions**

**Race Condition** là một lỗ hổng bảo mật xảy ra khi một ứng dụng xử lý các tác vụ không đồng bộ mà không kiểm soát thứ tự thực thi của các tác vụ đó. Điều này có thể dẫn đến kết quả không mong muốn nếu nhiều tác vụ cố gắng truy cập hoặc thay đổi dữ liệu cùng lúc.

**Ví dụ:**  
Trong một hệ thống thanh toán, nếu một người dùng có thể thực hiện nhiều giao dịch đồng thời mà không có kiểm soát đúng cách, kẻ tấn công có thể lợi dụng tình huống này để thực hiện các giao dịch không hợp lệ.

---

### **Type Juggling**

**Type Juggling** là một vấn đề trong PHP khi các biến được chuyển đổi sang các kiểu dữ liệu khác nhau trong các ngữ cảnh cụ thể. PHP cho phép so sánh lỏng lẻo (sử dụng toán tử `==`), có thể dẫn đến việc so sánh các giá trị sau khi đã chuyển đổi kiểu, thay vì so sánh chính xác với toán tử `===`.

Khi sử dụng so sánh lỏng lẻo mà không cẩn thận, ứng dụng có thể gặp phải các lỗ hổng bảo mật, chẳng hạn như:

- **Bỏ qua xác thực** (Authentication Bypass)
- **Tăng quyền** (Privilege Escalation)

**Ví dụ:**  
Giả sử ứng dụng sử dụng so sánh lỏng lẻo giữa chuỗi và số mà không kiểm tra kiểu dữ liệu, kẻ tấn công có thể lợi dụng điều này để bỏ qua bước xác thực, như khi mật khẩu `0` được coi là hợp lệ thay vì mật khẩu thực sự.

---

s2
### **JavaScript Objects & Prototypes**

Trước khi tìm hiểu về lỗ hổng **Prototype Pollution**, chúng ta cần hiểu rõ về các đối tượng và **Prototype** trong JavaScript.

---

### **JavaScript Objects**

Trong JavaScript, một đối tượng (object) là một tập hợp các cặp *key-value* (khóa - giá trị). Các giá trị này có thể là bất kỳ kiểu dữ liệu nào, bao gồm cả hàm (function) hoặc các đối tượng khác.

**Ví dụ:**

```javascript
let module = {
  name: "HTB Academy",
  author: "John Doe",
  tier: 3
};
```

Trong ví dụ trên, `module` là một đối tượng có các thuộc tính như `name`, `author`, và `tier`.

---

### **Prototypes in JavaScript**

JavaScript sử dụng một hệ thống kế thừa có sẵn để cung cấp chức năng cơ bản cho tất cả các đối tượng. Hệ thống này được thực hiện thông qua **Object prototypes** (Mẫu đối tượng).

Mỗi đối tượng trong JavaScript có một thuộc tính gọi là **prototype**, mà bản thân nó cũng là một đối tượng. Thuộc tính **prototype** này có thể chứa các thuộc tính hoặc phương thức mà đối tượng đó kế thừa. Mỗi đối tượng sẽ kế thừa các thuộc tính và phương thức từ prototype của nó, và tiếp tục kế thừa từ prototype của prototype, tạo thành một chuỗi gọi là **prototype chain** (chuỗi prototype).

**Ví dụ:**

```javascript
let module = {
  name: "HTB Academy",
  author: "John Doe",
  tier: 3
};

console.log(module.toString());  // Output: "[object Object]"
```

Ở đây, phương thức `toString()` không được định nghĩa trực tiếp trong đối tượng `module`, nhưng nó vẫn có thể sử dụng được. Điều này là vì đối tượng `module` kế thừa phương thức `toString()` từ prototype của nó, tức là từ đối tượng `Object.prototype`.

---

### **Prototype Chain**

Khi bạn cố gắng truy cập một thuộc tính của một đối tượng mà không tồn tại trong chính đối tượng đó, JavaScript sẽ tìm thuộc tính đó trong **prototype** của đối tượng. Nếu không tìm thấy, JavaScript sẽ tiếp tục tìm trong prototype của prototype, và cứ như vậy cho đến khi đến cuối chuỗi prototype. Nếu không tìm thấy thuộc tính ở bất kỳ đâu trong chuỗi prototype, JavaScript sẽ trả về `undefined`.

**Kiểm tra Prototype:**

Để kiểm tra prototype của một đối tượng, bạn có thể truy cập thuộc tính `__proto__`:

```javascript
console.log(module.__proto__);  // Output: Object.prototype
```

Trong trường hợp này, chúng ta có thể thấy rằng prototype của `module` là `Object.prototype`, đây là prototype cơ bản mà tất cả các đối tượng trong JavaScript đều kế thừa.

---

### **Overriding Prototype Properties (Shadowing)**

Bạn có thể ghi đè (override) các thuộc tính hoặc phương thức kế thừa từ prototype để đáp ứng các yêu cầu cụ thể của đối tượng. Điều này gọi là **shadowing** (che khuất).

**Ví dụ:**

```javascript
module.toString = function() {
  return "This is the HTB Academy module: " + this.name;
};

console.log(module.toString());  // Output: "This is the HTB Academy module: HTB Academy"
```

Ở đây, phương thức `toString()` đã được ghi đè để trả về một chuỗi tùy chỉnh thay vì chuỗi mặc định `[object Object]`. Khi gọi `module.toString()`, hàm `toString` mới của đối tượng `module` sẽ được thực thi, thay vì phương thức `toString` kế thừa từ `Object.prototype`.

---

### **Prototype Pollution**

Lỗ hổng **Prototype Pollution** xảy ra khi dữ liệu người dùng được sử dụng để thay đổi các thuộc tính trong prototype của một đối tượng. Điều này có thể dẫn đến các lỗ hổng bảo mật nghiêm trọng, vì kẻ tấn công có thể thay đổi hành vi của các đối tượng trong toàn bộ ứng dụng.

**Ví dụ:**

Giả sử một ứng dụng web cho phép người dùng gửi dữ liệu để tạo đối tượng JavaScript mà không kiểm tra hoặc làm sạch đầu vào. Kẻ tấn công có thể thao túng dữ liệu đầu vào để thay đổi prototype của một đối tượng.

```javascript
// Người dùng cung cấp dữ liệu này
let userInput = { "__proto__.isAdmin": true };

// Áp dụng dữ liệu vào đối tượng
Object.assign(module, userInput);

// Kiểm tra
console.log(module.isAdmin);  // Output: true
```

Trong ví dụ trên, người dùng có thể thay đổi prototype của đối tượng `module`, tạo ra thuộc tính `isAdmin` mà lẽ ra không tồn tại. Điều này có thể dẫn đến những hành vi không mong muốn hoặc các lỗ hổng bảo mật.

---

s3
### **Giới Thiệu về Prototype Pollution**

Sau khi đã hiểu cách JavaScript khởi tạo các đối tượng và khái niệm về **prototype**, chúng ta sẽ đi vào tìm hiểu về **Prototype Pollution**.

---

### **Prototype Pollution là gì?**

**Prototype Pollution** (Ô nhiễm Prototype) là một lỗ hổng bảo mật xảy ra trong JavaScript khi dữ liệu người dùng có thể thay đổi thuộc tính của prototype (mẫu đối tượng) của một đối tượng. Do prototype của một đối tượng chỉ là một tham chiếu đến một đối tượng khác, chúng ta có thể chỉnh sửa các thuộc tính của prototype giống như việc chỉnh sửa thuộc tính của bất kỳ đối tượng nào, thông qua thuộc tính `__proto__`.

Khi một đối tượng bị ô nhiễm prototype, nó có thể dẫn đến các lỗ hổng bảo mật nghiêm trọng như:

- **Denial-of-Service (DoS)**: Tấn công từ chối dịch vụ.
- **Privilege Escalation**: Tăng quyền không mong muốn.
- **Remote Code Execution (RCE)**: Thực thi mã từ xa.
- Và các lỗ hổng bảo mật khác.

**Ví dụ về ô nhiễm prototype:**

Giả sử chúng ta có đối tượng `module` và muốn thay đổi thuộc tính `toString()` trong prototype của nó:

```javascript
module.__proto__.toString = function () { return "shadowed"; }
```

Sau khi thay đổi thuộc tính này, nếu bạn tạo một đối tượng mới và gọi phương thức `toString()`, đối tượng mới sẽ sử dụng phương thức mà chúng ta đã thay đổi trong prototype:

```javascript
let newObject = new Module();
console.log(newObject.toString());  // Output: "shadowed"
```

Điều này là do tất cả các đối tượng trong JavaScript kế thừa từ `Object.prototype`, và khi chúng ta thay đổi thuộc tính trong prototype này, tất cả đối tượng mới đều kế thừa sự thay đổi.

---

### **Khai Thác Prototype Pollution**

Lỗ hổng **Prototype Pollution** xảy ra khi một hàm không kiểm tra đầu vào đúng cách và cho phép người dùng thay đổi các thuộc tính trong prototype của đối tượng. Lỗi này có thể xảy ra khi dữ liệu người dùng được sử dụng để thiết lập các thuộc tính của đối tượng.

**Ví dụ về mã lỗ hổng:**

Giả sử có một hàm tạo đối tượng `Module`:

```javascript
function Module(name, author, tier) {
  this.name = name;
  this.author = author;
  this.tier = tier;
}
```

Bây giờ, nếu bạn tạo một đối tượng `webAttacks` từ hàm này:

```javascript
var webAttacks = new Module("Web Attacks", "21y4d", 2);
```

Lúc này, `webAttacks` sẽ có các thuộc tính như `name`, `author`, và `tier`. Tuy nhiên, nếu chúng ta có thể thiết lập một thuộc tính tùy ý trong prototype của `webAttacks`, thì chúng ta có thể "ô nhiễm" prototype của đối tượng này, ảnh hưởng đến tất cả các đối tượng JavaScript mới.

**Ví dụ về tấn công Prototype Pollution:**

Giả sử chúng ta muốn ô nhiễm thuộc tính `academy` trong prototype của `webAttacks`. Ta có thể làm như sau:

```javascript
webAttacks.__proto__.__proto__.academy = "polluted";
```

Lúc này, mọi đối tượng mới được khởi tạo sẽ kế thừa thuộc tính `academy` mà ta đã thêm vào prototype:

```javascript
let newObject = new Module("New Object", "Author", 1);
console.log(newObject.academy);  // Output: "polluted"
```

---

### **Các Lỗ Hổng Prototype Pollution**

Các lỗ hổng **Prototype Pollution** xảy ra chủ yếu khi dữ liệu người dùng được sử dụng để thiết lập các thuộc tính của đối tượng mà không có kiểm tra đúng cách. Trong một ứng dụng web, nếu người dùng có thể gửi JSON để cập nhật đối tượng, và không có biện pháp bảo vệ, thì rất có thể lỗ hổng này sẽ xảy ra.

**Ví dụ về một hàm có lỗ hổng Prototype Pollution:**

Giả sử một ứng dụng web cho phép người dùng gửi dữ liệu dưới dạng JSON để cập nhật đối tượng `module`, như sau:

```javascript
function merge(target, source) {
  for (let key in source) {
    if (isObject(target[key]) && isObject(source[key])) {
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}
```

Nếu hàm này không kiểm tra dữ liệu đầu vào đúng cách, một người dùng có thể gửi JSON như sau:

```json
{"__proto__": {"poc": "pwned"}}
```

Khi dữ liệu này được hợp nhất vào đối tượng mà không có kiểm tra đầu vào, prototype của đối tượng sẽ bị ô nhiễm. Các đối tượng mới được tạo ra sẽ có thuộc tính `poc` kế thừa từ prototype:

```javascript
let newObject = new Module("New Object", "Author", 1);
console.log(newObject.poc);  // Output: "pwned"
```

---

s4
### **Privilege Escalation qua Prototype Pollution**

Trong phần này, chúng ta sẽ tìm hiểu về một ứng dụng web dễ bị tấn công thông qua **Prototype Pollution** dẫn đến **Privilege Escalation** (leo thang quyền). Mục tiêu là phát hiện lỗ hổng bảo mật này thông qua việc phân tích mã nguồn ứng dụng web và tạo ra một phương pháp khai thác để leo thang quyền.

---

### **Xem Xét Mã Nguồn - Phát Hiện Lỗ Hổng**

Để xác định lỗ hổng **Prototype Pollution**, chúng ta bắt đầu bằng cách xem xét các phụ thuộc (dependencies) trong tệp `package.json`. Đây là nơi quản lý các thư viện được cài đặt thông qua **npm**, trình quản lý gói cho Node.js.

#### Các phụ thuộc của ứng dụng:
```json
"dependencies": {
  "bcryptjs": "^2.4.3",
  "cookie-parser": "^1.4.6",
  "express": "^4.18.2",
  "jsonwebtoken": "^9.0.0",
  "jsrender": "^1.0.12",
  "nodemon": "^2.0.20",
  "path": "^0.12.7",
  "sequelize": "^6.28.0",
  "sqlite3": "^5.1.4",
  "node.extend": "1.1.6"
}
```

#### Phát hiện lỗ hổng **Prototype Pollution**:
Chúng ta chú ý đến thư viện `node.extend`, một thư viện thực hiện việc **hợp nhất (merge)** các đối tượng. Một số phiên bản của `node.extend` có lỗ hổng **Prototype Pollution**, và phiên bản 1.1.6 mà ứng dụng này sử dụng là một trong những phiên bản dễ bị tấn công (CVE-2018-16491).

---

### **Phân Tích Lỗi và Khai Thác**

Tiếp theo, chúng ta cần kiểm tra xem liệu người dùng có thể cung cấp dữ liệu để khai thác lỗ hổng này không. Cụ thể, trong tệp `utils/log.js`, thư viện `node.extend` được sử dụng để hợp nhất các đối tượng, trong đó có thể có các dữ liệu từ người dùng:

```javascript
const extend = require("node.extend");
const log = (request) => {
  var log = extend(true, {date: Date.now()}, request);
  console.log("## Login activity: " + JSON.stringify(log));
}
module.exports = { log };
```

Hàm `log` này được gọi từ route `/login` và nhận đầu vào là `req.body` (dữ liệu gửi từ phía người dùng). Nếu người dùng gửi một **payload** có chứa thuộc tính `__proto__`, lỗ hổng **Prototype Pollution** sẽ xảy ra.

#### Tìm Đầu Vào Người Dùng:
Ta tìm kiếm trong mã nguồn và xác định rằng hàm `log` được gọi tại route `/login` trong tệp `routes/index.js`:

```javascript
router.post("/login", async (req, res) => {
  // log all login attempts for security purposes
  log(req.body);
  <SNIP>
}
```

---

### **Chạy Ứng Dụng Web Loca**

Trước khi thực hiện khai thác, chúng ta cần chạy ứng dụng web cục bộ để xác nhận sự tồn tại của lỗ hổng và kiểm tra các bước khai thác. Cài đặt Node.js và `npm` là cần thiết để cài các phụ thuộc.

- Cài đặt Node.js: 
  ```bash
  sudo apt install npm
  ```
- Cài đặt các phụ thuộc:
  ```bash
  npm install
  ```

Sau khi chạy ứng dụng web, chúng ta có thể kiểm tra xem liệu có thể đăng nhập và truy cập trang admin hay không.

---

### **Xác Nhận Lỗ Hổng và Thực Hiện Tấn Công**

Khi đã xác nhận rằng chúng ta có thể đăng nhập vào ứng dụng, ta tiếp tục tìm cách tấn công vào trang admin để leo thang quyền. Một trong các cách là lợi dụng việc **Prototype Pollution** để thao túng quyền truy cập vào trang admin, dù chúng ta không phải là người dùng admin.

#### Phát Hiện Lỗ Hổng Quản Lý Phiên Đăng Nhập:
Trong quá trình kiểm tra mã nguồn của route `/admin`, chúng ta nhận thấy rằng ứng dụng sử dụng một **JWT** (JSON Web Token) để kiểm tra xem người dùng có quyền truy cập vào trang admin không. Tuy nhiên, nếu không có thông tin về quyền admin trong JWT, hệ thống sẽ mặc định sử dụng giá trị `false`.

---

### **Khai Thác Prototype Pollution**

Để khai thác lỗ hổng này, ta có thể sử dụng **Prototype Pollution** để thêm thuộc tính `isAdmin` vào `Object.prototype`. Khi đó, bất kỳ đối tượng nào được tạo ra đều sẽ có thuộc tính `isAdmin = true` nếu truy cập qua prototype.

#### Các Bước Thực Hiện:

1. **Khai thác thông qua Payload**: Gửi một yêu cầu **POST** đến route `/login` với payload như sau:
   ```json
   {
     "__proto__": {
       "isAdmin": true
     }
   }
   ```

2. **Xác Nhận**: Khi payload này được hợp nhất vào đối tượng, thuộc tính `isAdmin` sẽ được thêm vào prototype của các đối tượng mới, bao gồm đối tượng `session` của người dùng. Điều này dẫn đến việc người dùng có quyền truy cập vào trang admin.

3. **Thực Hiện Tấn Công**: Khi chúng ta thực hiện yêu cầu này, ứng dụng sẽ không nhận ra rằng người dùng không phải là admin, do thuộc tính `isAdmin` đã được thêm vào prototype, cho phép chúng ta truy cập vào trang quản trị mà không cần phải đăng nhập với quyền admin thực sự.

---

s5
### Phân tích và khai thác lỗi **Prototype Pollution** trong ứng dụng web

Trong phần này, chúng ta sẽ tiếp tục nghiên cứu về cách khai thác lỗi **Prototype Pollution** trong một ứng dụng web để thực hiện tấn công **Command Injection**. Chúng ta sẽ tìm hiểu mã nguồn của ứng dụng, xác định các lỗ hổng và phát triển một exploit để thực hiện việc leo thang quyền truy cập hoặc điều khiển hệ thống.

#### 1. **Phát hiện lỗ hổng Prototype Pollution trong ứng dụng**

Đầu tiên, chúng ta tìm thấy một đoạn mã trong `routes/index.js` có khả năng bị tấn công bằng cách sử dụng **Prototype Pollution**. Cụ thể, trong endpoint `/ping`, có một đoạn mã sử dụng hàm `exec` để thực thi lệnh hệ thống mà không kiểm tra đúng cách đối với đầu vào từ người dùng:

```js
exec(`ping -c 1 ${userObject.deviceIP}`, (error, stdout, stderr) => {
    return res.render("ping", { ping_result: stdout.replace(/\n/g, "<br/>") + stderr.replace(/\n/g, "<br/>") });
});
```

Hàm `exec` thực thi lệnh `ping` với thông tin IP được lấy từ `userObject.deviceIP`. Nếu không có biện pháp lọc đầu vào phù hợp, kẻ tấn công có thể chèn mã độc vào trường `deviceIP` và thực thi các lệnh hệ thống thông qua lỗ hổng **Command Injection**.

#### 2. **Lỗ hổng Prototype Pollution trong hàm `merge`**

Trong endpoint `/update`, hàm `merge` của thư viện **lodash** được sử dụng để hợp nhất dữ liệu đầu vào từ người dùng vào đối tượng `userObject`. Tuy nhiên, phiên bản **lodash.merge** mà ứng dụng đang sử dụng có lỗ hổng **Prototype Pollution**:

```js
_.merge(userObject, req.body);
```

Điều này cho phép kẻ tấn công thay đổi các thuộc tính trong **prototype** của đối tượng, bao gồm `User.prototype.deviceIP`, mà không cần phải cung cấp một giá trị hợp lệ cho `deviceIP`. Thay vì chỉ thay đổi giá trị của `deviceIP`, kẻ tấn công có thể thay đổi thuộc tính này trong **prototype**, dẫn đến khả năng chèn lệnh vào khi hàm `exec` được gọi.

#### 3. **Khai thác lỗi Prototype Pollution để thực hiện Command Injection**

Khi tiến hành khai thác, kẻ tấn công sẽ thực hiện các bước sau:

- Đăng ký một người dùng mới mà không cung cấp giá trị cho `deviceIP` (mặc định là `null`).
- Sau đó, họ gửi một yêu cầu cập nhật profile người dùng với một payload **Prototype Pollution** để chèn một giá trị lệnh vào `deviceIP`:

```json
{
  "__proto__": {
    "deviceIP": "127.0.0.1; whoami"
  }
}
```

Payload này sẽ không bị lọc bởi vì nó sử dụng thuộc tính `__proto__` để thay đổi prototype của đối tượng, khiến lệnh `whoami` được thực thi khi hàm `ping` gọi `exec`.

#### 4. **Xác nhận và thực hiện tấn công**

Khi tấn công thành công, hệ thống sẽ thực thi lệnh `whoami` và trả về kết quả trên giao diện web trong trang `/ping`, chứng tỏ rằng **Command Injection** đã thành công.

---
s6
### **Code Review - Xác định Lỗ Hổng**

Phần này sẽ hướng dẫn cách nhận diện lỗ hổng *prototype pollution* phía client mà không cần truy cập vào mã nguồn của ứng dụng web, chỉ tập trung vào mã nguồn frontend. Khi bắt đầu với mục tiêu của bài lab, chúng ta có thể nhận thấy đây là một ứng dụng PHP nhờ vào phần mở rộng `.php` trong tham số `color`. Tuy nhiên, tham số này đã được làm sạch đúng cách bằng **DOMPurify**, giúp ngăn ngừa các lỗ hổng XSS. Tuy vậy, nếu chúng ta tìm kiếm các lỗ hổng *prototype pollution* trong các thư viện client-side, chúng ta sẽ phát hiện ra một vấn đề.

**Ví dụ:**  
Chúng ta thấy rằng thư viện **jQuery-deparam** có lỗ hổng *prototype pollution*. Để kiểm tra, chúng ta có thể sử dụng PoC (Proof of Concept) có sẵn trên trang GitHub để kích hoạt lỗ hổng *prototype pollution* bằng cách truy cập vào URL sau:

```
/profile.php?__proto__[poc]=polluted
```

Sau khi truy cập URL này, chúng ta có thể mở công cụ **JavaScript console** trong trình duyệt (ấn **F12**) và xác nhận lỗ hổng *prototype pollution* bằng cách kiểm tra đối tượng `Object.prototype`.

---

### **Công Cụ Hỗ Trợ**

Sau khi đã thảo luận về cách nhận diện và khai thác các lỗ hổng *prototype pollution* phía client, chúng ta sẽ tìm hiểu một công cụ hỗ trợ rất hữu ích trong quá trình này, đó là **DOM Invader**, một công cụ tích hợp trên Burp Suite.

Để sử dụng **DOM Invader**, chúng ta cần khởi động trình duyệt **Chromium** tích hợp trong **Burp Suite**. Phần mở rộng **DOM Invader** sẽ được cài đặt tự động. Các bước để sử dụng công cụ này như sau:

1. **Mở Burp Suite**: Chúng ta vào phần *Extensions* ở thanh URL của Burp Suite và ghim biểu tượng **Burp Suite Extension**.
2. **Kích hoạt DOM Invader**: Nhấn vào biểu tượng **Burp Suite Extension**, sau đó vào tab **DOM Invader** và bật tính năng này.
3. **Chọn Loại Tấn Công**: Vào phần **Attack types** và kích hoạt **Prototype Pollution**.
4. **Tải lại Trang**: Nhấn **Reload** và truy cập vào trang có lỗ hổng, trong ví dụ này là `/profile.php`.

Khi đó, **DOM Invader** sẽ tự động kiểm tra trang này để tìm kiếm các lỗ hổng *prototype pollution*. Kết quả kiểm tra sẽ hiển thị trong tab **DOM Invader** sau khi chúng ta mở công cụ phát triển trình duyệt (ấn **F12**).

---

### **Khai Thác và Xác Nhận Vulnerability**

Trong ứng dụng mẫu của chúng ta, **DOM Invader** phát hiện được lỗ hổng *prototype pollution* đã được đề cập trước đó. Tuy nhiên, công cụ này cung cấp hai vector khai thác có thể, sử dụng `constructor[prototype]`. Chúng ta có thể nhấp vào `__proto__` và thử nghiệm với các lỗ hổng để xác nhận chúng.

**Ví dụ:**  
URL bị tấn công sẽ được mở trong một tab mới, và chúng ta có thể hiển thị đối tượng `Object.prototype` trong console JavaScript để xác nhận rằng lỗ hổng *prototype pollution* đã xảy ra. Khi quan sát đối tượng này, chúng ta sẽ thấy các thay đổi không mong muốn được tạo ra bởi dữ liệu bị ô nhiễm.

---

### **Tìm Kiếm Script Gadgets**

Cuối cùng, **DOM Invader** có thể giúp tìm các *script gadgets* cho phép chúng ta biến lỗ hổng *prototype pollution* thành một lỗ hổng XSS. Để làm điều này, chúng ta có thể nhấn **Scan for gadgets** để **DOM Invader** tìm kiếm các *script gadgets* có thể khai thác. Sau khi quá trình quét hoàn tất, kết quả sẽ được hiển thị trong tab **DOM Invader** của công cụ phát triển trình duyệt. Tuy nhiên, trong ví dụ này, **DOM Invader** không phát hiện ra vector XSS mà chúng ta đã khai thác trước đó.

**Ví dụ:**  
Nếu **DOM Invader** phát hiện được một *script gadget*, chúng ta có thể thử khai thác để chuyển lỗ hổng *prototype pollution* thành XSS. Tuy nhiên, trong trường hợp này, không có lỗ hổng XSS nào được phát hiện, cho thấy rằng mặc dù lỗ hổng *prototype pollution* tồn tại, nhưng không thể chuyển nó thành XSS.

---

s7
### **Exploitation Remarks & Prevention (Nhận Định Về Việc Khai Thác và Phòng Ngừa)**

Bây giờ chúng ta đã cùng tìm hiểu và khai thác các lỗ hổng *prototype pollution*, hãy thảo luận về những nhận định quan trọng khi xác định và khai thác chúng trong môi trường thực tế. Bên cạnh đó, phần này sẽ kết thúc với các phương pháp phòng ngừa các lỗ hổng *prototype pollution*.

---

### **Exploitation Remarks (Nhận Định Khi Khai Thác)**

Như đã đề cập trước đó, việc ô nhiễm các prototype có thể dẫn đến các tác dụng phụ không mong muốn, có thể làm hỏng toàn bộ ứng dụng web. Do đó, không nên đơn giản tấn công một ứng dụng web sản xuất bằng cách gửi các payload *prototype pollution* và hy vọng sẽ thành công. **Kiểm tra và điều chỉnh payload** *prototype pollution* trên bản sao cục bộ của ứng dụng web là điều được khuyến cáo.

Mặc dù trong mô-đun này chúng ta tập trung vào việc phát hiện và khai thác các lỗ hổng *prototype pollution* từ phương pháp **whitebox**, nhưng trong thực tế, chúng ta không phải lúc nào cũng có quyền truy cập vào mã nguồn của ứng dụng web mục tiêu và cần phải có khả năng nhận diện chúng bằng phương pháp **black-box**. May mắn thay, một số kỹ thuật có thể giúp phát hiện *prototype pollution* một cách an toàn theo phương pháp **black-box**.

---

### **Các Kỹ Thuật Phát Hiện Prototype Pollution**

1. **Status Code (Mã Trạng Thái)**

Kỹ thuật đầu tiên và phổ biến nhất là **manipulating the status code** (tác động vào mã trạng thái trả về khi ứng dụng web gặp sự cố). Trước tiên, chúng ta cần xác định cách ứng dụng web phản hồi khi nhận được một yêu cầu JSON không hợp lệ. Ví dụ, nếu ứng dụng trả về mã trạng thái HTTP **400**, điều này có thể là dấu hiệu cho thấy ứng dụng không xử lý đúng dữ liệu.

Để xác nhận *prototype pollution*, chúng ta có thể tác động vào mã trạng thái bằng cách **ô nhiễm thuộc tính `status`** của đối tượng `Object.prototype` bằng cách sử dụng một payload giống như sau:

```javascript
{"__proto__":{"status":"polluted"}}
```

Tùy thuộc vào cách triển khai của ứng dụng, chúng ta có thể cần phải đi qua nhiều bước trong chuỗi prototype để có thể ô nhiễm đúng thuộc tính `status`.

---

2. **Parameter Limiting (Giới Hạn Tham Số)**

Kỹ thuật thứ hai yêu cầu ứng dụng web có một điểm kết nối (endpoint) phản ánh tham số **GET** theo một cách nào đó. Ví dụ, trong trường hợp đơn giản sau, thân của phản hồi phản ánh các tham số **GET** dưới dạng một đối tượng **JSON**:

```json
{
    "param1": "value1",
    "param2": "value2"
}
```

Chúng ta có thể thay đổi số lượng tham số **GET** được phản hồi bằng cách ô nhiễm thuộc tính `parameterLimit` của đối tượng `Object.prototype`. Nếu chúng ta gửi chuỗi thử nghiệm này tới ứng dụng, nó sẽ phản ánh chính xác như sau mà không bị giải mã **UTF-7**:

```javascript
{"__proto__":{"parameterLimit":1000}}
```

Chúng ta có thể thao tác với giá trị của **Content-Type Header** được sử dụng bởi ứng dụng bằng cách ô nhiễm thuộc tính `content-type` của `Object.prototype`.

---

### **Phòng Ngừa Prototype Pollution**

Để ngăn ngừa các lỗ hổng *prototype pollution*, có một số phương pháp bảo mật mà các nhà phát triển có thể áp dụng:

1. **Sanitizing Keys (Làm Sạch Các Khóa)**

Cách rõ ràng nhất là làm sạch các khóa để đảm bảo rằng kẻ tấn công không thể tiêm các khóa tham chiếu đến prototype. Tuy nhiên, mặc dù cách tiếp cận này có vẻ đơn giản, việc triển khai một công cụ làm sạch như vậy không phải là điều dễ dàng. Như đã thấy trong các phần trước, việc chỉ chặn khóa `__proto__` là không đủ để ngăn chặn hoàn toàn *prototype pollution*. Có thể kẻ tấn công sẽ sử dụng các khóa khác như `constructor` hoặc `prototype` để tham chiếu tới prototype.

Do đó, công cụ làm sạch nên ít nhất phải chặn ba khóa: `__proto__`, `constructor`, và `prototype`. Một cách tiếp cận bảo mật hơn là sử dụng **whitelist** (danh sách cho phép), trong đó chỉ những khóa được liệt kê rõ ràng mới được phép sử dụng trong ứng dụng. Các khóa này cần được chọn lựa cẩn thận tùy theo ngữ cảnh và có thể giúp ngăn chặn các lỗ hổng khác như **Mass Assignment**.

2. **Object.freeze()**

Một phương pháp khác để ngăn ngừa *prototype pollution* là **đóng băng đối tượng**, nghĩa là không cho phép đối tượng đó bị thay đổi. Điều này có thể thực hiện bằng cách sử dụng hàm `Object.freeze()`. Khi gọi hàm này trên đối tượng `Object.prototype` toàn cục (mà tất cả các đối tượng đều kế thừa), mọi thay đổi đối với nó sẽ bị cấm.

**Ví dụ:**

```javascript
Object.freeze(Object.prototype);

let obj = {};
obj.polluted = true;
console.log(obj.polluted); // undefined
```

Như ví dụ trên, khi chúng ta đóng băng đối tượng `Object.prototype`, thuộc tính `polluted` sẽ không được thêm vào đối tượng `obj` nữa, giúp ngăn chặn việc ô nhiễm prototype.

---

s8
